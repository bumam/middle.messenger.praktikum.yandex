// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"jVewE":[function(require,module,exports) {
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "4a236f9275d0a351";
module.bundle.HMR_BUNDLE_ID = "4ad54d68d60b904b";
"use strict";
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] 🚨 Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] ✨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>💡 ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) return true;
    var parents = getParents(module.bundle.root, id); // If no parents, the asset is new. Prevent reloading the page.
    if (!parents.length) return true;
    return parents.some(function(v) {
        return hmrAcceptCheck(v[0], v[1], null);
    });
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"egpFc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _chats = require("../src/components/chats/chats");
var _chatsDefault = parcelHelpers.interopDefault(_chats);
var _error = require("../src/components/error/error");
var _errorDefault = parcelHelpers.interopDefault(_error);
var _login = require("../src/components/login/login");
var _loginDefault = parcelHelpers.interopDefault(_login);
var _modalAvatar = require("../src/components/modal-avatar/modalAvatar");
var _modalAvatarDefault = parcelHelpers.interopDefault(_modalAvatar);
var _profile = require("../src/components/profile/profile");
var _profileDefault = parcelHelpers.interopDefault(_profile);
var _signIn = require("../src/components/signin/signIn");
var _signInDefault = parcelHelpers.interopDefault(_signIn);
const root = document.querySelector("#root");
window.addEventListener("hashchange", ()=>{
    let currentURL = location.hash;
    switch(currentURL){
        case "#login":
            return root.innerHTML = _loginDefault.default;
        case "#signin":
            return root.innerHTML = _signInDefault.default;
        case "#profile":
            return root.innerHTML = _profileDefault.default;
        case "#avatar-modal":
            return root.innerHTML = _modalAvatarDefault.default;
        case "#chats":
            return root.innerHTML = _chatsDefault.default;
        case "#error404":
            return root.innerHTML = _errorDefault.default;
        default:
            return root.innerHTML = "";
    }
});

},{"../src/components/chats/chats":"bMetx","../src/components/error/error":"7fBG1","../src/components/login/login":"4yaFC","../src/components/modal-avatar/modalAvatar":"kGPJH","../src/components/profile/profile":"aQyB6","../src/components/signin/signIn":"gbR8G","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bMetx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pug = require("pug");
var _pugDefault = parcelHelpers.interopDefault(_pug);
var _chatsTmpl = require("./chats.tmpl");
var _chatsTmplDefault = parcelHelpers.interopDefault(_chatsTmpl);
const chat = _pugDefault.default.compile(_chatsTmplDefault.default);
const data = {
    user: "Андрей",
    dsplayUser: true,
    activeChat: true,
    chatDate: "Вчера",
    activeChatContent: [
        {
            type: "current-chat__message--in",
            text: `Привет!`,
            time: "12:23"
        },
        {
            type: "current-chat__message--in",
            text: `Привет! Смотри, тут всплыл интересный кусок лунной космической истории — НАСА в какой-то момент попросила Хассельблад адаптировать модель SWC для полетов на Луну. Сейчас мы все знаем что астронавты летали с моделью 500 EL — и к слову говоря, все тушки этих камер все еще находятся на поверхности Луны, так как астронавты с собой забрали только кассеты с пленкой. Хассельблад в итоге адаптировал SWC для космоса, но что-то пошло не так и на ракету они так никогда и не попали. Всего их было произведено 25 штук, одну из них недавно продали на аукционе за 45000 евро.`,
            time: "12:23"
        },
        {
            type: "current-chat__message--out",
            text: `Вау`,
            time: "15:13"
        }, 
    ],
    activeChatCompanion: "Денис",
    chatInput: {
        type: "text",
        name: "message"
    },
    emptyChatText: "Выберите чат чтобы отправить сообщение",
    search: false,
    searchResult: "Киноклуб",
    searchText: "Кино",
    chatSettings: false,
    chatoptions: false,
    dialogs: [
        {
            from: "Юля",
            content: "Изображение",
            time: "10:00",
            unreadCount: 2,
            answer: ""
        },
        {
            from: "Киноклуб",
            content: "Привет! Сколько лет сколько зим",
            time: "Пн",
            unreadCount: 10,
            answer: ""
        },
        {
            from: "Саня",
            content: "",
            time: "15:40",
            unreadCount: 0,
            answer: "круто"
        }, 
    ]
};
exports.default = chat(data);

},{"pug":"cV7MS","./chats.tmpl":"48QSg","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cV7MS":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
'use strict';
/*!
 * Pug
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */ /**
 * Module dependencies.
 */ var fs = require('fs');
var path1 = require('path');
var lex = require('pug-lexer');
var stripComments = require('pug-strip-comments');
var parse = require('pug-parser');
var load = require('pug-load');
var filters = require('pug-filters');
var link = require('pug-linker');
var generateCode = require('pug-code-gen');
var runtime = require('pug-runtime');
var runtimeWrap = require('pug-runtime/wrap');
/**
 * Name for detection
 */ exports.name = 'Pug';
/**
 * Pug runtime helpers.
 */ exports.runtime = runtime;
/**
 * Template function cache.
 */ exports.cache = {
};
function applyPlugins(value1, options, plugins, name) {
    return plugins.reduce(function(value, plugin) {
        return plugin[name] ? plugin[name](value, options) : value;
    }, value1);
}
function findReplacementFunc(plugins, name) {
    var eligiblePlugins = plugins.filter(function(plugin) {
        return plugin[name];
    });
    if (eligiblePlugins.length > 1) throw new Error('Two or more plugins all implement ' + name + ' method.');
    else if (eligiblePlugins.length) return eligiblePlugins[0][name].bind(eligiblePlugins[0]);
    return null;
}
/**
 * Object for global custom filters.  Note that you can also just pass a `filters`
 * option to any other method.
 */ exports.filters = {
};
/**
 * Compile the given `str` of pug and return a function body.
 *
 * @param {String} str
 * @param {Object} options
 * @return {Object}
 * @api private
 */ function compileBody(str1, options1) {
    var debug_sources = {
    };
    debug_sources[options1.filename] = str1;
    var dependencies = [];
    var plugins = options1.plugins || [];
    var ast = load.string(str1, {
        filename: options1.filename,
        basedir: options1.basedir,
        lex: function(str, options) {
            var lexOptions = {
            };
            Object.keys(options).forEach(function(key) {
                lexOptions[key] = options[key];
            });
            lexOptions.plugins = plugins.filter(function(plugin) {
                return !!plugin.lex;
            }).map(function(plugin) {
                return plugin.lex;
            });
            var contents = applyPlugins(str, {
                filename: options.filename
            }, plugins, 'preLex');
            return applyPlugins(lex(contents, lexOptions), options, plugins, 'postLex');
        },
        parse: function(tokens, options) {
            tokens = tokens.map(function(token) {
                if (token.type === 'path' && path1.extname(token.val) === '') return {
                    type: 'path',
                    loc: token.loc,
                    val: token.val + '.pug'
                };
                return token;
            });
            tokens = stripComments(tokens, options);
            tokens = applyPlugins(tokens, options, plugins, 'preParse');
            var parseOptions = {
            };
            Object.keys(options).forEach(function(key) {
                parseOptions[key] = options[key];
            });
            parseOptions.plugins = plugins.filter(function(plugin) {
                return !!plugin.parse;
            }).map(function(plugin) {
                return plugin.parse;
            });
            return applyPlugins(applyPlugins(parse(tokens, parseOptions), options, plugins, 'postParse'), options, plugins, 'preLoad');
        },
        resolve: function(filename, source, loadOptions) {
            var replacementFunc = findReplacementFunc(plugins, 'resolve');
            if (replacementFunc) return replacementFunc(filename, source, options1);
            return load.resolve(filename, source, loadOptions);
        },
        read: function(filename, loadOptions) {
            dependencies.push(filename);
            var contents;
            var replacementFunc = findReplacementFunc(plugins, 'read');
            if (replacementFunc) contents = replacementFunc(filename, options1);
            else contents = load.read(filename, loadOptions);
            debug_sources[filename] = Buffer.isBuffer(contents) ? contents.toString('utf8') : contents;
            return contents;
        }
    });
    ast = applyPlugins(ast, options1, plugins, 'postLoad');
    ast = applyPlugins(ast, options1, plugins, 'preFilters');
    var filtersSet = {
    };
    Object.keys(exports.filters).forEach(function(key) {
        filtersSet[key] = exports.filters[key];
    });
    if (options1.filters) Object.keys(options1.filters).forEach(function(key) {
        filtersSet[key] = options1.filters[key];
    });
    ast = filters.handleFilters(ast, filtersSet, options1.filterOptions, options1.filterAliases);
    ast = applyPlugins(ast, options1, plugins, 'postFilters');
    ast = applyPlugins(ast, options1, plugins, 'preLink');
    ast = link(ast);
    ast = applyPlugins(ast, options1, plugins, 'postLink');
    // Compile
    ast = applyPlugins(ast, options1, plugins, 'preCodeGen');
    var js = (findReplacementFunc(plugins, 'generateCode') || generateCode)(ast, {
        pretty: options1.pretty,
        compileDebug: options1.compileDebug,
        doctype: options1.doctype,
        inlineRuntimeFunctions: options1.inlineRuntimeFunctions,
        globals: options1.globals,
        self: options1.self,
        includeSources: options1.includeSources ? debug_sources : false,
        templateName: options1.templateName
    });
    js = applyPlugins(js, options1, plugins, 'postCodeGen');
    // Debug compiler
    if (options1.debug) console.error('\nCompiled Function:\n\n\u001b[90m%s\u001b[0m', js.replace(/^/gm, '  '));
    return {
        body: js,
        dependencies: dependencies
    };
}
/**
 * Get the template from a string or a file, either compiled on-the-fly or
 * read from cache (if enabled), and cache the template if needed.
 *
 * If `str` is not set, the file specified in `options.filename` will be read.
 *
 * If `options.cache` is true, this function reads the file from
 * `options.filename` so it must be set prior to calling this function.
 *
 * @param {Object} options
 * @param {String=} str
 * @return {Function}
 * @api private
 */ function handleTemplateCache(options, str) {
    var key = options.filename;
    if (options.cache && exports.cache[key]) return exports.cache[key];
    else {
        if (str === undefined) str = fs.readFileSync(options.filename, 'utf8');
        var templ = exports.compile(str, options);
        if (options.cache) exports.cache[key] = templ;
        return templ;
    }
}
/**
 * Compile a `Function` representation of the given pug `str`.
 *
 * Options:
 *
 *   - `compileDebug` when `false` debugging code is stripped from the compiled
       template, when it is explicitly `true`, the source code is included in
       the compiled template for better accuracy.
 *   - `filename` used to improve errors when `compileDebug` is not `false` and to resolve imports/extends
 *
 * @param {String} str
 * @param {Options} options
 * @return {Function}
 * @api public
 */ exports.compile = function(str, options) {
    var options = options || {
    };
    str = String(str);
    var parsed = compileBody(str, {
        compileDebug: options.compileDebug !== false,
        filename: options.filename,
        basedir: options.basedir,
        pretty: options.pretty,
        doctype: options.doctype,
        inlineRuntimeFunctions: options.inlineRuntimeFunctions,
        globals: options.globals,
        self: options.self,
        includeSources: options.compileDebug === true,
        debug: options.debug,
        templateName: 'template',
        filters: options.filters,
        filterOptions: options.filterOptions,
        filterAliases: options.filterAliases,
        plugins: options.plugins
    });
    var res = options.inlineRuntimeFunctions ? new Function('', parsed.body + ';return template;')() : runtimeWrap(parsed.body);
    res.dependencies = parsed.dependencies;
    return res;
};
/**
 * Compile a JavaScript source representation of the given pug `str`.
 *
 * Options:
 *
 *   - `compileDebug` When it is `true`, the source code is included in
 *     the compiled template for better error messages.
 *   - `filename` used to improve errors when `compileDebug` is not `true` and to resolve imports/extends
 *   - `name` the name of the resulting function (defaults to "template")
 *   - `module` when it is explicitly `true`, the source code include export module syntax
 *
 * @param {String} str
 * @param {Options} options
 * @return {Object}
 * @api public
 */ exports.compileClientWithDependenciesTracked = function(str, options) {
    var options = options || {
    };
    str = String(str);
    var parsed = compileBody(str, {
        compileDebug: options.compileDebug,
        filename: options.filename,
        basedir: options.basedir,
        pretty: options.pretty,
        doctype: options.doctype,
        inlineRuntimeFunctions: options.inlineRuntimeFunctions !== false,
        globals: options.globals,
        self: options.self,
        includeSources: options.compileDebug,
        debug: options.debug,
        templateName: options.name || 'template',
        filters: options.filters,
        filterOptions: options.filterOptions,
        filterAliases: options.filterAliases,
        plugins: options.plugins
    });
    var body = parsed.body;
    if (options.module) {
        if (options.inlineRuntimeFunctions === false) body = 'var pug = require("pug-runtime");' + body;
        body += ' module.exports = ' + (options.name || 'template') + ';';
    }
    return {
        body: body,
        dependencies: parsed.dependencies
    };
};
/**
 * Compile a JavaScript source representation of the given pug `str`.
 *
 * Options:
 *
 *   - `compileDebug` When it is `true`, the source code is included in
 *     the compiled template for better error messages.
 *   - `filename` used to improve errors when `compileDebug` is not `true` and to resolve imports/extends
 *   - `name` the name of the resulting function (defaults to "template")
 *
 * @param {String} str
 * @param {Options} options
 * @return {String}
 * @api public
 */ exports.compileClient = function(str, options) {
    return exports.compileClientWithDependenciesTracked(str, options).body;
};
/**
 * Compile a `Function` representation of the given pug file.
 *
 * Options:
 *
 *   - `compileDebug` when `false` debugging code is stripped from the compiled
       template, when it is explicitly `true`, the source code is included in
       the compiled template for better accuracy.
 *
 * @param {String} path
 * @param {Options} options
 * @return {Function}
 * @api public
 */ exports.compileFile = function(path, options) {
    options = options || {
    };
    options.filename = path;
    return handleTemplateCache(options);
};
/**
 * Render the given `str` of pug.
 *
 * Options:
 *
 *   - `cache` enable template caching
 *   - `filename` filename required for `include` / `extends` and caching
 *
 * @param {String} str
 * @param {Object|Function} options or fn
 * @param {Function|undefined} fn
 * @returns {String}
 * @api public
 */ exports.render = function(str, options, fn) {
    // support callback API
    if ('function' == typeof options) fn = options, options = undefined;
    if (typeof fn === 'function') {
        var res;
        try {
            res = exports.render(str, options);
        } catch (ex) {
            return fn(ex);
        }
        return fn(null, res);
    }
    options = options || {
    };
    // cache requires .filename
    if (options.cache && !options.filename) throw new Error('the "filename" option is required for caching');
    return handleTemplateCache(options, str)(options);
};
/**
 * Render a Pug file at the given `path`.
 *
 * @param {String} path
 * @param {Object|Function} options or callback
 * @param {Function|undefined} fn
 * @returns {String}
 * @api public
 */ exports.renderFile = function(path, options, fn) {
    // support callback API
    if ('function' == typeof options) fn = options, options = undefined;
    if (typeof fn === 'function') {
        var res;
        try {
            res = exports.renderFile(path, options);
        } catch (ex) {
            return fn(ex);
        }
        return fn(null, res);
    }
    options = options || {
    };
    options.filename = path;
    return handleTemplateCache(options)(options);
};
/**
 * Compile a Pug file at the given `path` for use on the client.
 *
 * @param {String} path
 * @param {Object} options
 * @returns {String}
 * @api public
 */ exports.compileFileClient = function(path, options) {
    var key = path + ':client';
    options = options || {
    };
    options.filename = path;
    if (options.cache && exports.cache[key]) return exports.cache[key];
    var str = fs.readFileSync(options.filename, 'utf8');
    var out = exports.compileClient(str, options);
    if (options.cache) exports.cache[key] = out;
    return out;
};
/**
 * Express support.
 */ exports.__express = function(path, options, fn) {
    options.compileDebug;
    exports.renderFile(path, options, fn);
};

},{"buffer":"bOetu","fs":"joWnX","path":"dTeSu","pug-lexer":"6jl9i","pug-strip-comments":"i1wRT","pug-parser":"vqQq1","pug-load":"a0t0I","pug-filters":"ejdey","pug-linker":"j76HK","pug-code-gen":"cjaX6","pug-runtime":"dOa8V","pug-runtime/wrap":"lOpgd"}],"bOetu":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ 'use strict';
var base64 = require('base64-js');
var ieee754 = require('ieee754');
var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 2147483647;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === 'number') throw new TypeError('The "value" argument must not be of type number. Received type number');
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';
    if (!Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
    var length = byteLength1(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for(var i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + ' bytes');
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) Buffer.from(buf).copy(buffer, pos);
            else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength1(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== 'string') throw new TypeError("The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type " + typeof string);
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
            return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength1;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return '';
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return '';
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return '';
    if (!encoding) encoding = 'utf8';
    while(true)switch(encoding){
        case 'hex':
            return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return utf8Slice(this, start, end);
        case 'ascii':
            return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return latin1Slice(this, start, end);
        case 'base64':
            return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(var i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(var i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(var i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError("The \"target\" argument must be one of type Buffer or Uint8Array. Received type " + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 2147483647) byteOffset = 2147483647;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 255 // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i1;
    if (dir) {
        var foundIndex = -1;
        for(i1 = byteOffset; i1 < arrLength; i1++)if (read(arr, i1) === read(val, foundIndex === -1 ? 0 : i1 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i1;
            if (i1 - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i1 -= i1 - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i1 = byteOffset; i1 >= 0; i1--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i1 + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i1;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');
    if (!encoding) encoding = 'utf8';
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'hex':
            return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
            return asciiWrite(this, string, offset, length);
        case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 127);
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';
    for(var i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(var i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 256))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while(byteLength > 0 && (mul *= 256))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 256))val += this[offset + i] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 256))val += this[offset + --i] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 255;
    while(++i < byteLength && (mul *= 256))this[offset + i] = value / mul & 255;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 255;
    while(--i >= 0 && (mul *= 256))this[offset + i] = value / mul & 255;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while(++i < byteLength && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 255;
    while(--i >= 0 && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === 'number') val = val & 255;
    else if (typeof val === 'boolean') val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + '=';
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 55295 && codePoint < 57344) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 56319) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 56320) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else throw new Error('Invalid code point');
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 255);
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function() {
    var alphabet = '0123456789abcdef';
    var table = new Array(256);
    for(var i = 0; i < 16; ++i){
        var i16 = i * 16;
        for(var j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();

},{"base64-js":"nR26C","ieee754":"ljh7N"}],"nR26C":[function(require,module,exports) {
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i1 = 0, len1 = code.length; i1 < len1; ++i1){
    lookup[i1] = code[i1];
    revLookup[code.charCodeAt(i1)] = i1;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + '=');
    }
    return parts.join('');
}

},{}],"ljh7N":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"joWnX":[function(require,module,exports) {
"use strict";

},{}],"dTeSu":[function(require,module,exports) {
var process = require("process");
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
function assertPath(path) {
    if (typeof path !== 'string') throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
}
// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
    var res = '';
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for(var i = 0; i <= path.length; ++i){
        if (i < path.length) code = path.charCodeAt(i);
        else if (code === 47 /*/*/ ) break;
        else code = 47 /*/*/ ;
        if (code === 47 /*/*/ ) {
            if (lastSlash === i - 1 || dots === 1) ;
            else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/  || res.charCodeAt(res.length - 2) !== 46 /*.*/ ) {
                    if (res.length > 2) {
                        var lastSlashIndex = res.lastIndexOf('/');
                        if (lastSlashIndex !== res.length - 1) {
                            if (lastSlashIndex === -1) {
                                res = '';
                                lastSegmentLength = 0;
                            } else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    } else if (res.length === 2 || res.length === 1) {
                        res = '';
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += '/..';
                    else res = '..';
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 /*.*/  && dots !== -1) ++dots;
        else dots = -1;
    }
    return res;
}
function _format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve() {
        var resolvedPath = '';
        var resolvedAbsolute = false;
        var cwd;
        for(var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--){
            var path;
            if (i >= 0) path = arguments[i];
            else {
                if (cwd === undefined) cwd = process.cwd();
                path = cwd;
            }
            assertPath(path);
            // Skip empty entries
            if (path.length === 0) continue;
            resolvedPath = path + '/' + resolvedPath;
            resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/ ;
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        // Normalize the path
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
            if (resolvedPath.length > 0) return '/' + resolvedPath;
            else return '/';
        } else if (resolvedPath.length > 0) return resolvedPath;
        else return '.';
    },
    normalize: function normalize(path) {
        assertPath(path);
        if (path.length === 0) return '.';
        var isAbsolute = path.charCodeAt(0) === 47 /*/*/ ;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/ ;
        // Normalize the path
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute) path = '.';
        if (path.length > 0 && trailingSeparator) path += '/';
        if (isAbsolute) return '/' + path;
        return path;
    },
    isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47 /*/*/ ;
    },
    join: function join() {
        if (arguments.length === 0) return '.';
        var joined;
        for(var i = 0; i < arguments.length; ++i){
            var arg = arguments[i];
            assertPath(arg);
            if (arg.length > 0) {
                if (joined === undefined) joined = arg;
                else joined += '/' + arg;
            }
        }
        if (joined === undefined) return '.';
        return posix.normalize(joined);
    },
    relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return '';
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return '';
        // Trim any leading backslashes
        var fromStart = 1;
        for(; fromStart < from.length; ++fromStart){
            if (from.charCodeAt(fromStart) !== 47 /*/*/ ) break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        // Trim any leading backslashes
        var toStart = 1;
        for(; toStart < to.length; ++toStart){
            if (to.charCodeAt(toStart) !== 47 /*/*/ ) break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        // Compare paths to find the longest common path from root
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for(; i <= length; ++i){
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === 47 /*/*/ ) // We get here if `from` is the exact base path for `to`.
                    // For example: from='/foo/bar'; to='/foo/bar/baz'
                    return to.slice(toStart + i + 1);
                    else if (i === 0) // We get here if `from` is the root
                    // For example: from='/'; to='/foo'
                    return to.slice(toStart + i);
                } else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === 47 /*/*/ ) // We get here if `to` is the exact base path for `from`.
                    // For example: from='/foo/bar/baz'; to='/foo/bar'
                    lastCommonSep = i;
                    else if (i === 0) // We get here if `to` is the root.
                    // For example: from='/foo'; to='/'
                    lastCommonSep = 0;
                }
                break;
            }
            var fromCode = from.charCodeAt(fromStart + i);
            var toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode) break;
            else if (fromCode === 47 /*/*/ ) lastCommonSep = i;
        }
        var out = '';
        // Generate the relative path based on the path difference between `to`
        // and `from`
        for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i)if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/ ) {
            if (out.length === 0) out += '..';
            else out += '/..';
        }
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts
        if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
        else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === 47 /*/*/ ) ++toStart;
            return to.slice(toStart);
        }
    },
    _makeLong: function _makeLong(path) {
        return path;
    },
    dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0) return '.';
        var code = path.charCodeAt(0);
        var hasRoot = code === 47 /*/*/ ;
        var end = -1;
        var matchedSlash = true;
        for(var i = path.length - 1; i >= 1; --i){
            code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            } else // We saw the first non-path separator
            matchedSlash = false;
        }
        if (end === -1) return hasRoot ? '/' : '.';
        if (hasRoot && end === 1) return '//';
        return path.slice(0, end);
    },
    basename: function basename(path, ext) {
        if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path) return '';
            var extIdx = ext.length - 1;
            var firstNonSlashEnd = -1;
            for(i = path.length - 1; i >= 0; --i){
                var code = path.charCodeAt(i);
                if (code === 47 /*/*/ ) // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                } else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) // We matched the extension, so mark this as the end of our path
                            // component
                            end = i;
                        } else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end) end = firstNonSlashEnd;
            else if (end === -1) end = path.length;
            return path.slice(start, end);
        } else {
            for(i = path.length - 1; i >= 0; --i){
                if (path.charCodeAt(i) === 47 /*/*/ ) // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                } else if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // path component
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1) return '';
            return path.slice(start, end);
        }
    },
    extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        var preDotState = 0;
        for(var i = path.length - 1; i >= 0; --i){
            var code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46 /*.*/ ) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) // We saw a non-dot and non-path separator before our dot, so we should
            // have a good chance at having a non-empty extension
            preDotState = -1;
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) return '';
        return path.slice(startDot, end);
    },
    format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== 'object') throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        return _format('/', pathObject);
    },
    parse: function parse(path) {
        assertPath(path);
        var ret = {
            root: '',
            dir: '',
            base: '',
            ext: '',
            name: ''
        };
        if (path.length === 0) return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47 /*/*/ ;
        var start;
        if (isAbsolute) {
            ret.root = '/';
            start = 1;
        } else start = 0;
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        var preDotState = 0;
        // Get non-dir info
        for(; i >= start; --i){
            code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46 /*.*/ ) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) // We saw a non-dot and non-path separator before our dot, so we should
            // have a good chance at having a non-empty extension
            preDotState = -1;
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);
                else ret.base = ret.name = path.slice(startPart, end);
            }
        } else {
            if (startPart === 0 && isAbsolute) {
                ret.name = path.slice(1, startDot);
                ret.base = path.slice(1, end);
            } else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = '/';
        return ret;
    },
    sep: '/',
    delimiter: ':',
    win32: null,
    posix: null
};
posix.posix = posix;
module.exports = posix;

},{"process":"lDnB8"}],"lDnB8":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {
};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e1) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {
};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {
};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function() {
    return '/';
};
process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() {
    return 0;
};

},{}],"6jl9i":[function(require,module,exports) {
'use strict';
var assert = require('assert');
var isExpression = require('is-expression');
var characterParser = require('character-parser');
var error = require('pug-error');
module.exports = lex;
module.exports.Lexer = Lexer;
function lex(str, options) {
    var lexer = new Lexer(str, options);
    return JSON.parse(JSON.stringify(lexer.getTokens()));
}
/**
 * Initialize `Lexer` with the given `str`.
 *
 * @param {String} str
 * @param {String} filename
 * @api private
 */ function Lexer(str, options) {
    options = options || {
    };
    if (typeof str !== 'string') throw new Error('Expected source code to be a string but got "' + typeof str + '"');
    if (typeof options !== 'object') throw new Error('Expected "options" to be an object but got "' + typeof options + '"');
    //Strip any UTF-8 BOM off of the start of `str`, if it exists.
    str = str.replace(/^\uFEFF/, '');
    this.input = str.replace(/\r\n|\r/g, '\n');
    this.originalInput = this.input;
    this.filename = options.filename;
    this.interpolated = options.interpolated || false;
    this.lineno = options.startingLine || 1;
    this.colno = options.startingColumn || 1;
    this.plugins = options.plugins || [];
    this.indentStack = [
        0
    ];
    this.indentRe = null;
    // If #{}, !{} or #[] syntax is allowed when adding text
    this.interpolationAllowed = true;
    this.whitespaceRe = /[ \n\t]/;
    this.tokens = [];
    this.ended = false;
}
/**
 * Lexer prototype.
 */ Lexer.prototype = {
    constructor: Lexer,
    error: function(code, message) {
        var err = error(code, message, {
            line: this.lineno,
            column: this.colno,
            filename: this.filename,
            src: this.originalInput
        });
        throw err;
    },
    assert: function(value, message) {
        if (!value) this.error('ASSERT_FAILED', message);
    },
    isExpression: function(exp) {
        return isExpression(exp, {
            throw: true
        });
    },
    assertExpression: function(exp, noThrow) {
        //this verifies that a JavaScript expression is valid
        try {
            this.callLexerFunction('isExpression', exp);
            return true;
        } catch (ex) {
            if (noThrow) return false;
            // not coming from acorn
            if (!ex.loc) throw ex;
            this.incrementLine(ex.loc.line - 1);
            this.incrementColumn(ex.loc.column);
            var msg = 'Syntax Error: ' + ex.message.replace(/ \([0-9]+:[0-9]+\)$/, '');
            this.error('SYNTAX_ERROR', msg);
        }
    },
    assertNestingCorrect: function(exp) {
        //this verifies that code is properly nested, but allows
        //invalid JavaScript such as the contents of `attributes`
        var res = characterParser(exp);
        if (res.isNesting()) this.error('INCORRECT_NESTING', 'Nesting must match on expression `' + exp + '`');
    },
    /**
   * Construct a token with the given `type` and `val`.
   *
   * @param {String} type
   * @param {String} val
   * @return {Object}
   * @api private
   */ tok: function(type, val) {
        var res = {
            type: type,
            loc: {
                start: {
                    line: this.lineno,
                    column: this.colno
                },
                filename: this.filename
            }
        };
        if (val !== undefined) res.val = val;
        return res;
    },
    /**
   * Set the token's `loc.end` value.
   *
   * @param {Object} tok
   * @returns {Object}
   * @api private
   */ tokEnd: function(tok) {
        tok.loc.end = {
            line: this.lineno,
            column: this.colno
        };
        return tok;
    },
    /**
   * Increment `this.lineno` and reset `this.colno`.
   *
   * @param {Number} increment
   * @api private
   */ incrementLine: function(increment) {
        this.lineno += increment;
        if (increment) this.colno = 1;
    },
    /**
   * Increment `this.colno`.
   *
   * @param {Number} increment
   * @api private
   */ incrementColumn: function(increment) {
        this.colno += increment;
    },
    /**
   * Consume the given `len` of input.
   *
   * @param {Number} len
   * @api private
   */ consume: function(len) {
        this.input = this.input.substr(len);
    },
    /**
   * Scan for `type` with the given `regexp`.
   *
   * @param {String} type
   * @param {RegExp} regexp
   * @return {Object}
   * @api private
   */ scan: function(regexp, type) {
        var captures;
        if (captures = regexp.exec(this.input)) {
            var len = captures[0].length;
            var val = captures[1];
            var diff = len - (val ? val.length : 0);
            var tok = this.tok(type, val);
            this.consume(len);
            this.incrementColumn(diff);
            return tok;
        }
    },
    scanEndOfLine: function(regexp, type) {
        var captures;
        if (captures = regexp.exec(this.input)) {
            var whitespaceLength = 0;
            var whitespace;
            var tok;
            if (whitespace = /^([ ]+)([^ ]*)/.exec(captures[0])) {
                whitespaceLength = whitespace[1].length;
                this.incrementColumn(whitespaceLength);
            }
            var newInput = this.input.substr(captures[0].length);
            if (newInput[0] === ':') {
                this.input = newInput;
                tok = this.tok(type, captures[1]);
                this.incrementColumn(captures[0].length - whitespaceLength);
                return tok;
            }
            if (/^[ \t]*(\n|$)/.test(newInput)) {
                this.input = newInput.substr(/^[ \t]*/.exec(newInput)[0].length);
                tok = this.tok(type, captures[1]);
                this.incrementColumn(captures[0].length - whitespaceLength);
                return tok;
            }
        }
    },
    /**
   * Return the indexOf `(` or `{` or `[` / `)` or `}` or `]` delimiters.
   *
   * Make sure that when calling this function, colno is at the character
   * immediately before the beginning.
   *
   * @return {Number}
   * @api private
   */ bracketExpression: function(skip) {
        skip = skip || 0;
        var start = this.input[skip];
        assert(start === '(' || start === '{' || start === '[', 'The start character should be "(", "{" or "["');
        var end = characterParser.BRACKETS[start];
        var range;
        try {
            range = characterParser.parseUntil(this.input, end, {
                start: skip + 1
            });
        } catch (ex) {
            if (ex.index !== undefined) {
                var idx = ex.index;
                // starting from this.input[skip]
                var tmp = this.input.substr(skip).indexOf('\n');
                // starting from this.input[0]
                var nextNewline = tmp + skip;
                var ptr = 0;
                while(idx > nextNewline && tmp !== -1){
                    this.incrementLine(1);
                    idx -= nextNewline + 1;
                    ptr += nextNewline + 1;
                    tmp = nextNewline = this.input.substr(ptr).indexOf('\n');
                }
                this.incrementColumn(idx);
            }
            if (ex.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') this.error('NO_END_BRACKET', 'The end of the string reached with no closing bracket ' + end + ' found.');
            else if (ex.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') this.error('BRACKET_MISMATCH', ex.message);
            throw ex;
        }
        return range;
    },
    scanIndentation: function() {
        var captures, re;
        // established regexp
        if (this.indentRe) captures = this.indentRe.exec(this.input);
        else {
            // tabs
            re = /^\n(\t*) */;
            captures = re.exec(this.input);
            // spaces
            if (captures && !captures[1].length) {
                re = /^\n( *)/;
                captures = re.exec(this.input);
            }
            // established
            if (captures && captures[1].length) this.indentRe = re;
        }
        return captures;
    },
    /**
   * end-of-source.
   */ eos: function() {
        if (this.input.length) return;
        if (this.interpolated) this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.');
        for(var i = 0; this.indentStack[i]; i++)this.tokens.push(this.tokEnd(this.tok('outdent')));
        this.tokens.push(this.tokEnd(this.tok('eos')));
        this.ended = true;
        return true;
    },
    /**
   * Blank line.
   */ blank: function() {
        var captures;
        if (captures = /^\n[ \t]*\n/.exec(this.input)) {
            this.consume(captures[0].length - 1);
            this.incrementLine(1);
            return true;
        }
    },
    /**
   * Comment.
   */ comment: function() {
        var captures;
        if (captures = /^\/\/(-)?([^\n]*)/.exec(this.input)) {
            this.consume(captures[0].length);
            var tok = this.tok('comment', captures[2]);
            tok.buffer = '-' != captures[1];
            this.interpolationAllowed = tok.buffer;
            this.tokens.push(tok);
            this.incrementColumn(captures[0].length);
            this.tokEnd(tok);
            this.callLexerFunction('pipelessText');
            return true;
        }
    },
    /**
   * Interpolated tag.
   */ interpolation: function() {
        if (/^#\{/.test(this.input)) {
            var match = this.bracketExpression(1);
            this.consume(match.end + 1);
            var tok = this.tok('interpolation', match.src);
            this.tokens.push(tok);
            this.incrementColumn(2); // '#{'
            this.assertExpression(match.src);
            var splitted = match.src.split('\n');
            var lines = splitted.length - 1;
            this.incrementLine(lines);
            this.incrementColumn(splitted[lines].length + 1); // + 1 → '}'
            this.tokEnd(tok);
            return true;
        }
    },
    /**
   * Tag.
   */ tag: function() {
        var captures;
        if (captures = /^(\w(?:[-:\w]*\w)?)/.exec(this.input)) {
            var tok, name = captures[1], len = captures[0].length;
            this.consume(len);
            tok = this.tok('tag', name);
            this.tokens.push(tok);
            this.incrementColumn(len);
            this.tokEnd(tok);
            return true;
        }
    },
    /**
   * Filter.
   */ filter: function(opts) {
        var tok = this.scan(/^:([\w\-]+)/, 'filter');
        var inInclude = opts && opts.inInclude;
        if (tok) {
            this.tokens.push(tok);
            this.incrementColumn(tok.val.length);
            this.tokEnd(tok);
            this.callLexerFunction('attrs');
            if (!inInclude) {
                this.interpolationAllowed = false;
                this.callLexerFunction('pipelessText');
            }
            return true;
        }
    },
    /**
   * Doctype.
   */ doctype: function() {
        var node = this.scanEndOfLine(/^doctype *([^\n]*)/, 'doctype');
        if (node) {
            this.tokens.push(this.tokEnd(node));
            return true;
        }
    },
    /**
   * Id.
   */ id: function() {
        var tok = this.scan(/^#([\w-]+)/, 'id');
        if (tok) {
            this.tokens.push(tok);
            this.incrementColumn(tok.val.length);
            this.tokEnd(tok);
            return true;
        }
        if (/^#/.test(this.input)) this.error('INVALID_ID', '"' + /.[^ \t\(\#\.\:]*/.exec(this.input.substr(1))[0] + '" is not a valid ID.');
    },
    /**
   * Class.
   */ className: function() {
        var tok = this.scan(/^\.([_a-z0-9\-]*[_a-z][_a-z0-9\-]*)/i, 'class');
        if (tok) {
            this.tokens.push(tok);
            this.incrementColumn(tok.val.length);
            this.tokEnd(tok);
            return true;
        }
        if (/^\.[_a-z0-9\-]+/i.test(this.input)) this.error('INVALID_CLASS_NAME', 'Class names must contain at least one letter or underscore.');
        if (/^\./.test(this.input)) this.error('INVALID_CLASS_NAME', '"' + /.[^ \t\(\#\.\:]*/.exec(this.input.substr(1))[0] + '" is not a valid class name.  Class names can only contain "_", "-", a-z and 0-9, and must contain at least one of "_", or a-z');
    },
    /**
   * Text.
   */ endInterpolation: function() {
        if (this.interpolated && this.input[0] === ']') {
            this.input = this.input.substr(1);
            this.ended = true;
            return true;
        }
    },
    addText: function(type, value, prefix, escaped) {
        var tok;
        if (value + prefix === '') return;
        prefix = prefix || '';
        escaped = escaped || 0;
        var indexOfEnd = this.interpolated ? value.indexOf(']') : -1;
        var indexOfStart = this.interpolationAllowed ? value.indexOf('#[') : -1;
        var indexOfEscaped = this.interpolationAllowed ? value.indexOf('\\#[') : -1;
        var matchOfStringInterp = /(\\)?([#!]){((?:.|\n)*)$/.exec(value);
        var indexOfStringInterp = this.interpolationAllowed && matchOfStringInterp ? matchOfStringInterp.index : Infinity;
        if (indexOfEnd === -1) indexOfEnd = Infinity;
        if (indexOfStart === -1) indexOfStart = Infinity;
        if (indexOfEscaped === -1) indexOfEscaped = Infinity;
        if (indexOfEscaped !== Infinity && indexOfEscaped < indexOfEnd && indexOfEscaped < indexOfStart && indexOfEscaped < indexOfStringInterp) {
            prefix = prefix + value.substring(0, indexOfEscaped) + '#[';
            return this.addText(type, value.substring(indexOfEscaped + 3), prefix, escaped + 1);
        }
        if (indexOfStart !== Infinity && indexOfStart < indexOfEnd && indexOfStart < indexOfEscaped && indexOfStart < indexOfStringInterp) {
            tok = this.tok(type, prefix + value.substring(0, indexOfStart));
            this.incrementColumn(prefix.length + indexOfStart + escaped);
            this.tokens.push(this.tokEnd(tok));
            tok = this.tok('start-pug-interpolation');
            this.incrementColumn(2);
            this.tokens.push(this.tokEnd(tok));
            var child = new this.constructor(value.substr(indexOfStart + 2), {
                filename: this.filename,
                interpolated: true,
                startingLine: this.lineno,
                startingColumn: this.colno,
                plugins: this.plugins
            });
            var interpolated;
            try {
                interpolated = child.getTokens();
            } catch (ex) {
                if (ex.code && /^PUG:/.test(ex.code)) {
                    this.colno = ex.column;
                    this.error(ex.code.substr(4), ex.msg);
                }
                throw ex;
            }
            this.colno = child.colno;
            this.tokens = this.tokens.concat(interpolated);
            tok = this.tok('end-pug-interpolation');
            this.incrementColumn(1);
            this.tokens.push(this.tokEnd(tok));
            this.addText(type, child.input);
            return;
        }
        if (indexOfEnd !== Infinity && indexOfEnd < indexOfStart && indexOfEnd < indexOfEscaped && indexOfEnd < indexOfStringInterp) {
            if (prefix + value.substring(0, indexOfEnd)) this.addText(type, value.substring(0, indexOfEnd), prefix);
            this.ended = true;
            this.input = value.substr(value.indexOf(']') + 1) + this.input;
            return;
        }
        if (indexOfStringInterp !== Infinity) {
            if (matchOfStringInterp[1]) {
                prefix = prefix + value.substring(0, indexOfStringInterp) + matchOfStringInterp[2] + '{';
                return this.addText(type, value.substring(indexOfStringInterp + 3), prefix, escaped + 1);
            }
            var before = value.substr(0, indexOfStringInterp);
            if (prefix || before) {
                before = prefix + before;
                tok = this.tok(type, before);
                this.incrementColumn(before.length + escaped);
                this.tokens.push(this.tokEnd(tok));
            }
            var rest = matchOfStringInterp[3];
            var range;
            tok = this.tok('interpolated-code');
            this.incrementColumn(2);
            try {
                range = characterParser.parseUntil(rest, '}');
            } catch (ex) {
                if (ex.index !== undefined) this.incrementColumn(ex.index);
                if (ex.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.');
                else if (ex.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') this.error('BRACKET_MISMATCH', ex.message);
                else throw ex;
            }
            tok.mustEscape = matchOfStringInterp[2] === '#';
            tok.buffer = true;
            tok.val = range.src;
            this.assertExpression(range.src);
            if (range.end + 1 < rest.length) {
                rest = rest.substr(range.end + 1);
                this.incrementColumn(range.end + 1);
                this.tokens.push(this.tokEnd(tok));
                this.addText(type, rest);
            } else {
                this.incrementColumn(rest.length);
                this.tokens.push(this.tokEnd(tok));
            }
            return;
        }
        value = prefix + value;
        tok = this.tok(type, value);
        this.incrementColumn(value.length + escaped);
        this.tokens.push(this.tokEnd(tok));
    },
    text: function() {
        var tok = this.scan(/^(?:\| ?| )([^\n]+)/, 'text') || this.scan(/^( )/, 'text') || this.scan(/^\|( ?)/, 'text');
        if (tok) {
            this.addText('text', tok.val);
            return true;
        }
    },
    textHtml: function() {
        var tok = this.scan(/^(<[^\n]*)/, 'text-html');
        if (tok) {
            this.addText('text-html', tok.val);
            return true;
        }
    },
    /**
   * Dot.
   */ dot: function() {
        var tok;
        if (tok = this.scanEndOfLine(/^\./, 'dot')) {
            this.tokens.push(this.tokEnd(tok));
            this.callLexerFunction('pipelessText');
            return true;
        }
    },
    /**
   * Extends.
   */ extends: function() {
        var tok = this.scan(/^extends?(?= |$|\n)/, 'extends');
        if (tok) {
            this.tokens.push(this.tokEnd(tok));
            if (!this.callLexerFunction('path')) this.error('NO_EXTENDS_PATH', 'missing path for extends');
            return true;
        }
        if (this.scan(/^extends?\b/)) this.error('MALFORMED_EXTENDS', 'malformed extends');
    },
    /**
   * Block prepend.
   */ prepend: function() {
        var captures;
        if (captures = /^(?:block +)?prepend +([^\n]+)/.exec(this.input)) {
            var name = captures[1].trim();
            var comment = '';
            if (name.indexOf('//') !== -1) {
                comment = '//' + name.split('//').slice(1).join('//');
                name = name.split('//')[0].trim();
            }
            if (!name) return;
            var tok = this.tok('block', name);
            var len = captures[0].length - comment.length;
            while(this.whitespaceRe.test(this.input.charAt(len - 1)))len--;
            this.incrementColumn(len);
            tok.mode = 'prepend';
            this.tokens.push(this.tokEnd(tok));
            this.consume(captures[0].length - comment.length);
            this.incrementColumn(captures[0].length - comment.length - len);
            return true;
        }
    },
    /**
   * Block append.
   */ append: function() {
        var captures;
        if (captures = /^(?:block +)?append +([^\n]+)/.exec(this.input)) {
            var name = captures[1].trim();
            var comment = '';
            if (name.indexOf('//') !== -1) {
                comment = '//' + name.split('//').slice(1).join('//');
                name = name.split('//')[0].trim();
            }
            if (!name) return;
            var tok = this.tok('block', name);
            var len = captures[0].length - comment.length;
            while(this.whitespaceRe.test(this.input.charAt(len - 1)))len--;
            this.incrementColumn(len);
            tok.mode = 'append';
            this.tokens.push(this.tokEnd(tok));
            this.consume(captures[0].length - comment.length);
            this.incrementColumn(captures[0].length - comment.length - len);
            return true;
        }
    },
    /**
   * Block.
   */ block: function() {
        var captures;
        if (captures = /^block +([^\n]+)/.exec(this.input)) {
            var name = captures[1].trim();
            var comment = '';
            if (name.indexOf('//') !== -1) {
                comment = '//' + name.split('//').slice(1).join('//');
                name = name.split('//')[0].trim();
            }
            if (!name) return;
            var tok = this.tok('block', name);
            var len = captures[0].length - comment.length;
            while(this.whitespaceRe.test(this.input.charAt(len - 1)))len--;
            this.incrementColumn(len);
            tok.mode = 'replace';
            this.tokens.push(this.tokEnd(tok));
            this.consume(captures[0].length - comment.length);
            this.incrementColumn(captures[0].length - comment.length - len);
            return true;
        }
    },
    /**
   * Mixin Block.
   */ mixinBlock: function() {
        var tok;
        if (tok = this.scanEndOfLine(/^block/, 'mixin-block')) {
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * Yield.
   */ yield: function() {
        var tok = this.scanEndOfLine(/^yield/, 'yield');
        if (tok) {
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * Include.
   */ include: function() {
        var tok = this.scan(/^include(?=:| |$|\n)/, 'include');
        if (tok) {
            this.tokens.push(this.tokEnd(tok));
            while(this.callLexerFunction('filter', {
                inInclude: true
            }));
            if (!this.callLexerFunction('path')) {
                if (/^[^ \n]+/.test(this.input)) // if there is more text
                this.fail();
                else // if not
                this.error('NO_INCLUDE_PATH', 'missing path for include');
            }
            return true;
        }
        if (this.scan(/^include\b/)) this.error('MALFORMED_INCLUDE', 'malformed include');
    },
    /**
   * Path
   */ path: function() {
        var tok = this.scanEndOfLine(/^ ([^\n]+)/, 'path');
        if (tok && (tok.val = tok.val.trim())) {
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * Case.
   */ case: function() {
        var tok = this.scanEndOfLine(/^case +([^\n]+)/, 'case');
        if (tok) {
            this.incrementColumn(-tok.val.length);
            this.assertExpression(tok.val);
            this.incrementColumn(tok.val.length);
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
        if (this.scan(/^case\b/)) this.error('NO_CASE_EXPRESSION', 'missing expression for case');
    },
    /**
   * When.
   */ when: function() {
        var tok = this.scanEndOfLine(/^when +([^:\n]+)/, 'when');
        if (tok) {
            var parser = characterParser(tok.val);
            while(parser.isNesting() || parser.isString()){
                var rest = /:([^:\n]+)/.exec(this.input);
                if (!rest) break;
                tok.val += rest[0];
                this.consume(rest[0].length);
                this.incrementColumn(rest[0].length);
                parser = characterParser(tok.val);
            }
            this.incrementColumn(-tok.val.length);
            this.assertExpression(tok.val);
            this.incrementColumn(tok.val.length);
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
        if (this.scan(/^when\b/)) this.error('NO_WHEN_EXPRESSION', 'missing expression for when');
    },
    /**
   * Default.
   */ default: function() {
        var tok = this.scanEndOfLine(/^default/, 'default');
        if (tok) {
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
        if (this.scan(/^default\b/)) this.error('DEFAULT_WITH_EXPRESSION', 'default should not have an expression');
    },
    /**
   * Call mixin.
   */ call: function() {
        var tok, captures, increment;
        if (captures = /^\+(\s*)(([-\w]+)|(#\{))/.exec(this.input)) {
            // try to consume simple or interpolated call
            if (captures[3]) {
                // simple call
                increment = captures[0].length;
                this.consume(increment);
                tok = this.tok('call', captures[3]);
            } else {
                // interpolated call
                var match = this.bracketExpression(2 + captures[1].length);
                increment = match.end + 1;
                this.consume(increment);
                this.assertExpression(match.src);
                tok = this.tok('call', '#{' + match.src + '}');
            }
            this.incrementColumn(increment);
            tok.args = null;
            // Check for args (not attributes)
            if (captures = /^ *\(/.exec(this.input)) {
                var range = this.bracketExpression(captures[0].length - 1);
                if (!/^\s*[-\w]+ *=/.test(range.src)) {
                    // not attributes
                    this.incrementColumn(1);
                    this.consume(range.end + 1);
                    tok.args = range.src;
                    this.assertExpression('[' + tok.args + ']');
                    for(var i = 0; i <= tok.args.length; i++)if (tok.args[i] === '\n') this.incrementLine(1);
                    else this.incrementColumn(1);
                }
            }
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * Mixin.
   */ mixin: function() {
        var captures;
        if (captures = /^mixin +([-\w]+)(?: *\((.*)\))? */.exec(this.input)) {
            this.consume(captures[0].length);
            var tok = this.tok('mixin', captures[1]);
            tok.args = captures[2] || null;
            this.incrementColumn(captures[0].length);
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * Conditional.
   */ conditional: function() {
        var captures;
        if (captures = /^(if|unless|else if|else)\b([^\n]*)/.exec(this.input)) {
            this.consume(captures[0].length);
            var type = captures[1].replace(/ /g, '-');
            var js = captures[2] && captures[2].trim();
            // type can be "if", "else-if" and "else"
            var tok = this.tok(type, js);
            this.incrementColumn(captures[0].length - js.length);
            switch(type){
                case 'if':
                case 'else-if':
                    this.assertExpression(js);
                    break;
                case 'unless':
                    this.assertExpression(js);
                    tok.val = '!(' + js + ')';
                    tok.type = 'if';
                    break;
                case 'else':
                    if (js) this.error('ELSE_CONDITION', '`else` cannot have a condition, perhaps you meant `else if`');
                    break;
            }
            this.incrementColumn(js.length);
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * While.
   */ while: function() {
        var captures, tok;
        if (captures = /^while +([^\n]+)/.exec(this.input)) {
            this.consume(captures[0].length);
            this.assertExpression(captures[1]);
            tok = this.tok('while', captures[1]);
            this.incrementColumn(captures[0].length);
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
        if (this.scan(/^while\b/)) this.error('NO_WHILE_EXPRESSION', 'missing expression for while');
    },
    /**
   * Each.
   */ each: function() {
        var captures;
        if (captures = /^(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? * in *([^\n]+)/.exec(this.input)) {
            this.consume(captures[0].length);
            var tok = this.tok('each', captures[1]);
            tok.key = captures[2] || null;
            this.incrementColumn(captures[0].length - captures[3].length);
            this.assertExpression(captures[3]);
            tok.code = captures[3];
            this.incrementColumn(captures[3].length);
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
        const name = /^each\b/.exec(this.input) ? 'each' : 'for';
        if (this.scan(/^(?:each|for)\b/)) this.error('MALFORMED_EACH', 'This `' + name + '` has a syntax error. `' + name + '` statements should be of the form: `' + name + ' VARIABLE_NAME of JS_EXPRESSION`');
        if (captures = /^- *(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? +in +([^\n]+)/.exec(this.input)) this.error('MALFORMED_EACH', 'Pug each and for should no longer be prefixed with a dash ("-"). They are pug keywords and not part of JavaScript.');
    },
    /**
   * EachOf.
   */ eachOf: function() {
        var captures;
        if (captures = /^(?:each|for) (.*?) of *([^\n]+)/.exec(this.input)) {
            this.consume(captures[0].length);
            var tok = this.tok('eachOf', captures[1]);
            tok.value = captures[1];
            this.incrementColumn(captures[0].length - captures[2].length);
            this.assertExpression(captures[2]);
            tok.code = captures[2];
            this.incrementColumn(captures[2].length);
            this.tokens.push(this.tokEnd(tok));
            if (!(/^[a-zA-Z_$][\w$]*$/.test(tok.value.trim()) || /^\[ *[a-zA-Z_$][\w$]* *\, *[a-zA-Z_$][\w$]* *\]$/.test(tok.value.trim()))) this.error('MALFORMED_EACH_OF_LVAL', 'The value variable for each must either be a valid identifier (e.g. `item`) or a pair of identifiers in square brackets (e.g. `[key, value]`).');
            return true;
        }
        if (captures = /^- *(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? +of +([^\n]+)/.exec(this.input)) this.error('MALFORMED_EACH', 'Pug each and for should not be prefixed with a dash ("-"). They are pug keywords and not part of JavaScript.');
    },
    /**
   * Code.
   */ code: function() {
        var captures;
        if (captures = /^(!?=|-)[ \t]*([^\n]+)/.exec(this.input)) {
            var flags = captures[1];
            var code = captures[2];
            var shortened = 0;
            if (this.interpolated) {
                var parsed;
                try {
                    parsed = characterParser.parseUntil(code, ']');
                } catch (err) {
                    if (err.index !== undefined) this.incrementColumn(captures[0].length - code.length + err.index);
                    if (err.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.');
                    else if (err.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') this.error('BRACKET_MISMATCH', err.message);
                    else throw err;
                }
                shortened = code.length - parsed.end;
                code = parsed.src;
            }
            var consumed = captures[0].length - shortened;
            this.consume(consumed);
            var tok = this.tok('code', code);
            tok.mustEscape = flags.charAt(0) === '=';
            tok.buffer = flags.charAt(0) === '=' || flags.charAt(1) === '=';
            // p #[!=    abc] hey
            //     ^              original colno
            //     -------------- captures[0]
            //           -------- captures[2]
            //     ------         captures[0] - captures[2]
            //           ^        after colno
            // =   abc
            // ^                  original colno
            // -------            captures[0]
            //     ---            captures[2]
            // ----               captures[0] - captures[2]
            //     ^              after colno
            this.incrementColumn(captures[0].length - captures[2].length);
            if (tok.buffer) this.assertExpression(code);
            this.tokens.push(tok);
            // p #[!=    abc] hey
            //           ^        original colno
            //              ----- shortened
            //           ---      code
            //              ^     after colno
            // =   abc
            //     ^              original colno
            //                    shortened
            //     ---            code
            //        ^           after colno
            this.incrementColumn(code.length);
            this.tokEnd(tok);
            return true;
        }
    },
    /**
   * Block code.
   */ blockCode: function() {
        var tok;
        if (tok = this.scanEndOfLine(/^-/, 'blockcode')) {
            this.tokens.push(this.tokEnd(tok));
            this.interpolationAllowed = false;
            this.callLexerFunction('pipelessText');
            return true;
        }
    },
    /**
   * Attribute Name.
   */ attribute: function(str) {
        var quote = '';
        var quoteRe = /['"]/;
        var key = '';
        var i;
        // consume all whitespace before the key
        for(i = 0; i < str.length; i++){
            if (!this.whitespaceRe.test(str[i])) break;
            if (str[i] === '\n') this.incrementLine(1);
            else this.incrementColumn(1);
        }
        if (i === str.length) return '';
        var tok = this.tok('attribute');
        // quote?
        if (quoteRe.test(str[i])) {
            quote = str[i];
            this.incrementColumn(1);
            i++;
        }
        // start looping through the key
        for(; i < str.length; i++){
            if (quote) {
                if (str[i] === quote) {
                    this.incrementColumn(1);
                    i++;
                    break;
                }
            } else {
                if (this.whitespaceRe.test(str[i]) || str[i] === '!' || str[i] === '=' || str[i] === ',') break;
            }
            key += str[i];
            if (str[i] === '\n') this.incrementLine(1);
            else this.incrementColumn(1);
        }
        tok.name = key;
        var valueResponse = this.attributeValue(str.substr(i));
        if (valueResponse.val) {
            tok.val = valueResponse.val;
            tok.mustEscape = valueResponse.mustEscape;
        } else {
            // was a boolean attribute (ex: `input(disabled)`)
            tok.val = true;
            tok.mustEscape = true;
        }
        str = valueResponse.remainingSource;
        this.tokens.push(this.tokEnd(tok));
        for(i = 0; i < str.length; i++){
            if (!this.whitespaceRe.test(str[i])) break;
            if (str[i] === '\n') this.incrementLine(1);
            else this.incrementColumn(1);
        }
        if (str[i] === ',') {
            this.incrementColumn(1);
            i++;
        }
        return str.substr(i);
    },
    /**
   * Attribute Value.
   */ attributeValue: function(str) {
        var quoteRe = /['"]/;
        var val = '';
        var done, i, x;
        var escapeAttr = true;
        var state = characterParser.defaultState();
        var col = this.colno;
        var line = this.lineno;
        // consume all whitespace before the equals sign
        for(i = 0; i < str.length; i++){
            if (!this.whitespaceRe.test(str[i])) break;
            if (str[i] === '\n') {
                line++;
                col = 1;
            } else col++;
        }
        if (i === str.length) return {
            remainingSource: str
        };
        if (str[i] === '!') {
            escapeAttr = false;
            col++;
            i++;
            if (str[i] !== '=') this.error('INVALID_KEY_CHARACTER', 'Unexpected character ' + str[i] + ' expected `=`');
        }
        if (str[i] !== '=') {
            // check for anti-pattern `div("foo"bar)`
            if (i === 0 && str && !this.whitespaceRe.test(str[0]) && str[0] !== ',') this.error('INVALID_KEY_CHARACTER', 'Unexpected character ' + str[0] + ' expected `=`');
            else return {
                remainingSource: str
            };
        }
        this.lineno = line;
        this.colno = col + 1;
        i++;
        // consume all whitespace before the value
        for(; i < str.length; i++){
            if (!this.whitespaceRe.test(str[i])) break;
            if (str[i] === '\n') this.incrementLine(1);
            else this.incrementColumn(1);
        }
        line = this.lineno;
        col = this.colno;
        // start looping through the value
        for(; i < str.length; i++){
            // if the character is in a string or in parentheses/brackets/braces
            if (!(state.isNesting() || state.isString())) {
                if (this.whitespaceRe.test(str[i])) {
                    done = false;
                    // find the first non-whitespace character
                    for(x = i; x < str.length; x++)if (!this.whitespaceRe.test(str[x])) {
                        // if it is a JavaScript punctuator, then assume that it is
                        // a part of the value
                        const isNotPunctuator = !characterParser.isPunctuator(str[x]);
                        const isQuote = quoteRe.test(str[x]);
                        const isColon = str[x] === ':';
                        const isSpreadOperator = str[x] + str[x + 1] + str[x + 2] === '...';
                        if ((isNotPunctuator || isQuote || isColon || isSpreadOperator) && this.assertExpression(val, true)) done = true;
                        break;
                    }
                    // if everything else is whitespace, return now so last attribute
                    // does not include trailing whitespace
                    if (done || x === str.length) break;
                }
                // if there's no whitespace and the character is not ',', the
                // attribute did not end.
                if (str[i] === ',' && this.assertExpression(val, true)) break;
            }
            state = characterParser.parseChar(str[i], state);
            val += str[i];
            if (str[i] === '\n') {
                line++;
                col = 1;
            } else col++;
        }
        this.assertExpression(val);
        this.lineno = line;
        this.colno = col;
        return {
            val: val,
            mustEscape: escapeAttr,
            remainingSource: str.substr(i)
        };
    },
    /**
   * Attributes.
   */ attrs: function() {
        var tok;
        if ('(' == this.input.charAt(0)) {
            tok = this.tok('start-attributes');
            var index = this.bracketExpression().end;
            var str = this.input.substr(1, index - 1);
            this.incrementColumn(1);
            this.tokens.push(this.tokEnd(tok));
            this.assertNestingCorrect(str);
            this.consume(index + 1);
            while(str)str = this.attribute(str);
            tok = this.tok('end-attributes');
            this.incrementColumn(1);
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * &attributes block
   */ attributesBlock: function() {
        if (/^&attributes\b/.test(this.input)) {
            var consumed = 11;
            this.consume(consumed);
            var tok = this.tok('&attributes');
            this.incrementColumn(consumed);
            var args = this.bracketExpression();
            consumed = args.end + 1;
            this.consume(consumed);
            tok.val = args.src;
            this.incrementColumn(consumed);
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * Indent | Outdent | Newline.
   */ indent: function() {
        var captures = this.scanIndentation();
        var tok;
        if (captures) {
            var indents = captures[1].length;
            this.incrementLine(1);
            this.consume(indents + 1);
            if (' ' == this.input[0] || '\t' == this.input[0]) this.error('INVALID_INDENTATION', 'Invalid indentation, you can use tabs or spaces but not both');
            // blank line
            if ('\n' == this.input[0]) {
                this.interpolationAllowed = true;
                return this.tokEnd(this.tok('newline'));
            }
            // outdent
            if (indents < this.indentStack[0]) {
                var outdent_count = 0;
                while(this.indentStack[0] > indents){
                    if (this.indentStack[1] < indents) this.error('INCONSISTENT_INDENTATION', 'Inconsistent indentation. Expecting either ' + this.indentStack[1] + ' or ' + this.indentStack[0] + ' spaces/tabs.');
                    outdent_count++;
                    this.indentStack.shift();
                }
                while(outdent_count--){
                    this.colno = 1;
                    tok = this.tok('outdent');
                    this.colno = this.indentStack[0] + 1;
                    this.tokens.push(this.tokEnd(tok));
                }
            // indent
            } else if (indents && indents != this.indentStack[0]) {
                tok = this.tok('indent', indents);
                this.colno = 1 + indents;
                this.tokens.push(this.tokEnd(tok));
                this.indentStack.unshift(indents);
            // newline
            } else {
                tok = this.tok('newline');
                this.colno = 1 + Math.min(this.indentStack[0] || 0, indents);
                this.tokens.push(this.tokEnd(tok));
            }
            this.interpolationAllowed = true;
            return true;
        }
    },
    pipelessText: function pipelessText(indents) {
        while(this.callLexerFunction('blank'));
        var captures = this.scanIndentation();
        indents = indents || captures && captures[1].length;
        if (indents > this.indentStack[0]) {
            this.tokens.push(this.tokEnd(this.tok('start-pipeless-text')));
            var tokens = [];
            var token_indent = [];
            var isMatch;
            // Index in this.input. Can't use this.consume because we might need to
            // retry lexing the block.
            var stringPtr = 0;
            do {
                // text has `\n` as a prefix
                var i = this.input.substr(stringPtr + 1).indexOf('\n');
                if (-1 == i) i = this.input.length - stringPtr - 1;
                var str = this.input.substr(stringPtr + 1, i);
                var lineCaptures = this.indentRe.exec('\n' + str);
                var lineIndents = lineCaptures && lineCaptures[1].length;
                isMatch = lineIndents >= indents;
                token_indent.push(isMatch);
                isMatch = isMatch || !str.trim();
                if (isMatch) {
                    // consume test along with `\n` prefix if match
                    stringPtr += str.length + 1;
                    tokens.push(str.substr(indents));
                } else if (lineIndents > this.indentStack[0]) {
                    // line is indented less than the first line but is still indented
                    // need to retry lexing the text block
                    this.tokens.pop();
                    return pipelessText.call(this, lineCaptures[1].length);
                }
            }while (this.input.length - stringPtr && isMatch)
            this.consume(stringPtr);
            while(this.input.length === 0 && tokens[tokens.length - 1] === '')tokens.pop();
            tokens.forEach((function(token, i) {
                var tok;
                this.incrementLine(1);
                if (i !== 0) tok = this.tok('newline');
                if (token_indent[i]) this.incrementColumn(indents);
                if (tok) this.tokens.push(this.tokEnd(tok));
                this.addText('text', token);
            }).bind(this));
            this.tokens.push(this.tokEnd(this.tok('end-pipeless-text')));
            return true;
        }
    },
    /**
   * Slash.
   */ slash: function() {
        var tok = this.scan(/^\//, 'slash');
        if (tok) {
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * ':'
   */ colon: function() {
        var tok = this.scan(/^: +/, ':');
        if (tok) {
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    fail: function() {
        this.error('UNEXPECTED_TEXT', 'unexpected text "' + this.input.substr(0, 5) + '"');
    },
    callLexerFunction: function(func) {
        var rest = [];
        for(var i = 1; i < arguments.length; i++)rest.push(arguments[i]);
        var pluginArgs = [
            this
        ].concat(rest);
        for(var i = 0; i < this.plugins.length; i++){
            var plugin = this.plugins[i];
            if (plugin[func] && plugin[func].apply(plugin, pluginArgs)) return true;
        }
        return this[func].apply(this, rest);
    },
    /**
   * Move to the next token
   *
   * @api private
   */ advance: function() {
        return this.callLexerFunction('blank') || this.callLexerFunction('eos') || this.callLexerFunction('endInterpolation') || this.callLexerFunction('yield') || this.callLexerFunction('doctype') || this.callLexerFunction('interpolation') || this.callLexerFunction('case') || this.callLexerFunction('when') || this.callLexerFunction('default') || this.callLexerFunction('extends') || this.callLexerFunction('append') || this.callLexerFunction('prepend') || this.callLexerFunction('block') || this.callLexerFunction('mixinBlock') || this.callLexerFunction('include') || this.callLexerFunction('mixin') || this.callLexerFunction('call') || this.callLexerFunction('conditional') || this.callLexerFunction('eachOf') || this.callLexerFunction('each') || this.callLexerFunction('while') || this.callLexerFunction('tag') || this.callLexerFunction('filter') || this.callLexerFunction('blockCode') || this.callLexerFunction('code') || this.callLexerFunction('id') || this.callLexerFunction('dot') || this.callLexerFunction('className') || this.callLexerFunction('attrs') || this.callLexerFunction('attributesBlock') || this.callLexerFunction('indent') || this.callLexerFunction('text') || this.callLexerFunction('textHtml') || this.callLexerFunction('comment') || this.callLexerFunction('slash') || this.callLexerFunction('colon') || this.fail();
    },
    /**
   * Return an array of tokens for the current file
   *
   * @returns {Array.<Token>}
   * @api public
   */ getTokens: function() {
        while(!this.ended)this.callLexerFunction('advance');
        return this.tokens;
    }
};

},{"assert":"bTbxk","is-expression":"bitOz","character-parser":"g0oN1","pug-error":"lbNNk"}],"bTbxk":[function(require,module,exports) {
var process = require("process");
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
function _typeof(obj1) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj1);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
var _require = require('./internal/errors'), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
var AssertionError = require('./internal/assert/assertion_error');
var _require2 = require('util/'), inspect = _require2.inspect;
var _require$types = require('util/').types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
var objectAssign = Object.assign ? Object.assign : require('es6-object-assign').assign;
var objectIs = Object.is ? Object.is : require('object-is');
var errorCache = new Map();
var isDeepEqual;
var isDeepStrictEqual;
var parseExpressionAt;
var findNodeAround;
var decoder;
function lazyLoadComparison() {
    var comparison = require('./internal/util/comparisons');
    isDeepEqual = comparison.isDeepEqual;
    isDeepStrictEqual = comparison.isDeepStrictEqual;
} // Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex
var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
var meta = [
    "\\u0000",
    "\\u0001",
    "\\u0002",
    "\\u0003",
    "\\u0004",
    "\\u0005",
    "\\u0006",
    "\\u0007",
    '\\b',
    '',
    '',
    "\\u000b",
    '\\f',
    '',
    "\\u000e",
    "\\u000f",
    "\\u0010",
    "\\u0011",
    "\\u0012",
    "\\u0013",
    "\\u0014",
    "\\u0015",
    "\\u0016",
    "\\u0017",
    "\\u0018",
    "\\u0019",
    "\\u001a",
    "\\u001b",
    "\\u001c",
    "\\u001d",
    "\\u001e",
    "\\u001f"
];
var escapeFn = function escapeFn(str) {
    return meta[str.charCodeAt(0)];
};
var warned = false; // The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.
var assert = module.exports = ok;
var NO_EXCEPTION_SENTINEL = {
}; // All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.
function innerFail(obj) {
    if (obj.message instanceof Error) throw obj.message;
    throw new AssertionError(obj);
}
function fail(actual, expected, message, operator, stackStartFn) {
    var argsLen = arguments.length;
    var internalMessage;
    if (argsLen === 0) internalMessage = 'Failed';
    else if (argsLen === 1) {
        message = actual;
        actual = undefined;
    } else {
        if (warned === false) {
            warned = true;
            var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
            warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", 'DeprecationWarning', 'DEP0094');
        }
        if (argsLen === 2) operator = '!=';
    }
    if (message instanceof Error) throw message;
    var errArgs = {
        actual: actual,
        expected: expected,
        operator: operator === undefined ? 'fail' : operator,
        stackStartFn: stackStartFn || fail
    };
    if (message !== undefined) errArgs.message = message;
    var err = new AssertionError(errArgs);
    if (internalMessage) {
        err.message = internalMessage;
        err.generatedMessage = true;
    }
    throw err;
}
assert.fail = fail; // The AssertionError is defined in internal/error.
assert.AssertionError = AssertionError;
function innerOk(fn, argLen, value, message) {
    if (!value) {
        var generatedMessage = false;
        if (argLen === 0) {
            generatedMessage = true;
            message = 'No value argument passed to `assert.ok()`';
        } else if (message instanceof Error) throw message;
        var err = new AssertionError({
            actual: value,
            expected: true,
            message: message,
            operator: '==',
            stackStartFn: fn
        });
        err.generatedMessage = generatedMessage;
        throw err;
    }
} // Pure assertion tests whether a value is truthy, as determined
// by !!value.
function ok() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
    innerOk.apply(void 0, [
        ok,
        args.length
    ].concat(args));
}
assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.
/* eslint-disable no-restricted-properties */ assert.equal = function equal(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS('actual', 'expected');
     // eslint-disable-next-line eqeqeq
    if (actual != expected) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: '==',
        stackStartFn: equal
    });
}; // The non-equality assertion tests for whether two objects are not
// equal with !=.
assert.notEqual = function notEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS('actual', 'expected');
     // eslint-disable-next-line eqeqeq
    if (actual == expected) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: '!=',
        stackStartFn: notEqual
    });
}; // The equivalence assertion tests a deep equality relation.
assert.deepEqual = function deepEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS('actual', 'expected');
    if (isDeepEqual === undefined) lazyLoadComparison();
    if (!isDeepEqual(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: 'deepEqual',
        stackStartFn: deepEqual
    });
}; // The non-equivalence assertion tests for any deep inequality.
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS('actual', 'expected');
    if (isDeepEqual === undefined) lazyLoadComparison();
    if (isDeepEqual(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: 'notDeepEqual',
        stackStartFn: notDeepEqual
    });
};
/* eslint-enable */ assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS('actual', 'expected');
    if (isDeepEqual === undefined) lazyLoadComparison();
    if (!isDeepStrictEqual(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: 'deepStrictEqual',
        stackStartFn: deepStrictEqual
    });
};
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS('actual', 'expected');
    if (isDeepEqual === undefined) lazyLoadComparison();
    if (isDeepStrictEqual(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: 'notDeepStrictEqual',
        stackStartFn: notDeepStrictEqual
    });
}
assert.strictEqual = function strictEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS('actual', 'expected');
    if (!objectIs(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: 'strictEqual',
        stackStartFn: strictEqual
    });
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS('actual', 'expected');
    if (objectIs(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: 'notStrictEqual',
        stackStartFn: notStrictEqual
    });
};
var Comparison1 = function Comparison(obj, keys, actual) {
    var _this = this;
    _classCallCheck(this, Comparison);
    keys.forEach(function(key) {
        if (key in obj) {
            if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) _this[key] = actual[key];
            else _this[key] = obj[key];
        }
    });
};
function compareExceptionKey(actual, expected, key, message, keys, fn) {
    if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
        if (!message) {
            // Create placeholder objects to create a nice output.
            var a = new Comparison1(actual, keys);
            var b = new Comparison1(expected, keys, actual);
            var err = new AssertionError({
                actual: a,
                expected: b,
                operator: 'deepStrictEqual',
                stackStartFn: fn
            });
            err.actual = actual;
            err.expected = expected;
            err.operator = fn.name;
            throw err;
        }
        innerFail({
            actual: actual,
            expected: expected,
            message: message,
            operator: fn.name,
            stackStartFn: fn
        });
    }
}
function expectedException(actual, expected, msg, fn) {
    if (typeof expected !== 'function') {
        if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.
        if (arguments.length === 2) throw new ERR_INVALID_ARG_TYPE('expected', [
            'Function',
            'RegExp'
        ], expected);
         // Handle primitives properly.
        if (_typeof(actual) !== 'object' || actual === null) {
            var err = new AssertionError({
                actual: actual,
                expected: expected,
                message: msg,
                operator: 'deepStrictEqual',
                stackStartFn: fn
            });
            err.operator = fn.name;
            throw err;
        }
        var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
        // as well.
        if (expected instanceof Error) keys.push('name', 'message');
        else if (keys.length === 0) throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
        if (isDeepEqual === undefined) lazyLoadComparison();
        keys.forEach(function(key) {
            if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) return;
            compareExceptionKey(actual, expected, key, msg, keys, fn);
        });
        return true;
    } // Guard instanceof against arrow functions as they don't have a prototype.
    if (expected.prototype !== undefined && actual instanceof expected) return true;
    if (Error.isPrototypeOf(expected)) return false;
    return expected.call({
    }, actual) === true;
}
function getActual(fn) {
    if (typeof fn !== 'function') throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
    try {
        fn();
    } catch (e) {
        return e;
    }
    return NO_EXCEPTION_SENTINEL;
}
function checkIsPromise(obj) {
    // Accept native ES6 promises and promises that are implemented in a similar
    // way. Do not accept thenables that use a function as `obj` and that have no
    // `catch` handler.
    // TODO: thenables are checked up until they have the correct methods,
    // but according to documentation, the `then` method should receive
    // the `fulfill` and `reject` arguments as well or it may be never resolved.
    return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
}
function waitForActual(promiseFn) {
    return Promise.resolve().then(function() {
        var resultPromise;
        if (typeof promiseFn === 'function') {
            // Return a rejected promise if `promiseFn` throws synchronously.
            resultPromise = promiseFn(); // Fail in case no promise is returned.
            if (!checkIsPromise(resultPromise)) throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
        } else if (checkIsPromise(promiseFn)) resultPromise = promiseFn;
        else throw new ERR_INVALID_ARG_TYPE('promiseFn', [
            'Function',
            'Promise'
        ], promiseFn);
        return Promise.resolve().then(function() {
            return resultPromise;
        }).then(function() {
            return NO_EXCEPTION_SENTINEL;
        }).catch(function(e) {
            return e;
        });
    });
}
function expectsError(stackStartFn, actual, error, message) {
    if (typeof error === 'string') {
        if (arguments.length === 4) throw new ERR_INVALID_ARG_TYPE('error', [
            'Object',
            'Error',
            'Function',
            'RegExp'
        ], error);
        if (_typeof(actual) === 'object' && actual !== null) {
            if (actual.message === error) throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
        } else if (actual === error) throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
        message = error;
        error = undefined;
    } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') throw new ERR_INVALID_ARG_TYPE('error', [
        'Object',
        'Error',
        'Function',
        'RegExp'
    ], error);
    if (actual === NO_EXCEPTION_SENTINEL) {
        var details = '';
        if (error && error.name) details += " (".concat(error.name, ")");
        details += message ? ": ".concat(message) : '.';
        var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
        innerFail({
            actual: undefined,
            expected: error,
            operator: stackStartFn.name,
            message: "Missing expected ".concat(fnType).concat(details),
            stackStartFn: stackStartFn
        });
    }
    if (error && !expectedException(actual, error, message, stackStartFn)) throw actual;
}
function expectsNoError(stackStartFn, actual, error, message) {
    if (actual === NO_EXCEPTION_SENTINEL) return;
    if (typeof error === 'string') {
        message = error;
        error = undefined;
    }
    if (!error || expectedException(actual, error)) {
        var details = message ? ": ".concat(message) : '.';
        var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
        innerFail({
            actual: actual,
            expected: error,
            operator: stackStartFn.name,
            message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
            stackStartFn: stackStartFn
        });
    }
    throw actual;
}
assert.throws = function throws(promiseFn) {
    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)args[_key2 - 1] = arguments[_key2];
    expectsError.apply(void 0, [
        throws,
        getActual(promiseFn)
    ].concat(args));
};
assert.rejects = function rejects(promiseFn) {
    for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++)args[_key3 - 1] = arguments[_key3];
    return waitForActual(promiseFn).then(function(result) {
        return expectsError.apply(void 0, [
            rejects,
            result
        ].concat(args));
    });
};
assert.doesNotThrow = function doesNotThrow(fn) {
    for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++)args[_key4 - 1] = arguments[_key4];
    expectsNoError.apply(void 0, [
        doesNotThrow,
        getActual(fn)
    ].concat(args));
};
assert.doesNotReject = function doesNotReject(fn) {
    for(var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++)args[_key5 - 1] = arguments[_key5];
    return waitForActual(fn).then(function(result) {
        return expectsNoError.apply(void 0, [
            doesNotReject,
            result
        ].concat(args));
    });
};
assert.ifError = function ifError(err) {
    if (err !== null && err !== undefined) {
        var message = 'ifError got unwanted exception: ';
        if (_typeof(err) === 'object' && typeof err.message === 'string') {
            if (err.message.length === 0 && err.constructor) message += err.constructor.name;
            else message += err.message;
        } else message += inspect(err);
        var newErr = new AssertionError({
            actual: err,
            expected: null,
            operator: 'ifError',
            message: message,
            stackStartFn: ifError
        }); // Make sure we actually have a stack trace!
        var origStack = err.stack;
        if (typeof origStack === 'string') {
            // This will remove any duplicated frames from the error frames taken
            // from within `ifError` and add the original error frames to the newly
            // created ones.
            var tmp2 = origStack.split('\n');
            tmp2.shift(); // Filter all frames existing in err.stack.
            var tmp1 = newErr.stack.split('\n');
            for(var i = 0; i < tmp2.length; i++){
                // Find the first occurrence of the frame.
                var pos = tmp1.indexOf(tmp2[i]);
                if (pos !== -1) {
                    // Only keep new frames.
                    tmp1 = tmp1.slice(0, pos);
                    break;
                }
            }
            newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
        }
        throw newErr;
    }
}; // Expose a strict only variant of assert
function strict() {
    for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++)args[_key6] = arguments[_key6];
    innerOk.apply(void 0, [
        strict,
        args.length
    ].concat(args));
}
assert.strict = objectAssign(strict, assert, {
    equal: assert.strictEqual,
    deepEqual: assert.deepStrictEqual,
    notEqual: assert.notStrictEqual,
    notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

},{"process":"lDnB8","./internal/errors":"LSymQ","./internal/assert/assertion_error":"1yuNT","util/":"fZQoa","es6-object-assign":"fc6lQ","object-is":"V34yE","./internal/util/comparisons":"56qKQ"}],"LSymQ":[function(require,module,exports) {
// Currently in sync with Node.js lib/internal/errors.js
// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f
/* eslint node-core/documented-errors: "error" */ /* eslint node-core/alphabetize-errors: "error" */ /* eslint node-core/prefer-util-format-errors: "error" */ 'use strict'; // The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.
function _typeof(obj1) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj1);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _getPrototypeOf(o1) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o1);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o2, p1) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o2, p1);
}
var codes = {
}; // Lazy loaded
var assert;
var util;
function createErrorType(code, message, Base) {
    if (!Base) Base = Error;
    function getMessage(arg1, arg2, arg3) {
        if (typeof message === 'string') return message;
        else return message(arg1, arg2, arg3);
    }
    var NodeError1 = /*#__PURE__*/ function(_Base) {
        _inherits(NodeError, _Base);
        function NodeError(arg1, arg2, arg3) {
            var _this;
            _classCallCheck(this, NodeError);
            _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
            _this.code = code;
            return _this;
        }
        return NodeError;
    }(Base);
    codes[code] = NodeError1;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
            return String(i);
        });
        if (len > 2) return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
        else if (len === 2) return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        else return "of ".concat(thing, " ").concat(expected[0]);
    } else return "of ".concat(thing, " ").concat(String(expected));
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) this_len = str.length;
    return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
    if (typeof start !== 'number') start = 0;
    if (start + search.length > str.length) return false;
    else return str.indexOf(search, start) !== -1;
}
createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function(name, expected, actual) {
    if (assert === undefined) assert = require('../assert');
    assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'
    var determiner;
    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
        determiner = 'must not be';
        expected = expected.replace(/^not /, '');
    } else determiner = 'must be';
    var msg;
    if (endsWith(name, ' argument')) // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
    else {
        var type = includes(name, '.') ? 'property' : 'argument';
        msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
    } // TODO(BridgeAR): Improve the output by showing `null` and similar.
    msg += ". Received type ".concat(_typeof(actual));
    return msg;
}, TypeError);
createErrorType('ERR_INVALID_ARG_VALUE', function(name, value) {
    var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
    if (util === undefined) util = require('util/');
    var inspected = util.inspect(value);
    if (inspected.length > 128) inspected = "".concat(inspected.slice(0, 128), "...");
    return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
createErrorType('ERR_INVALID_RETURN_VALUE', function(input, name, value) {
    var type;
    if (value && value.constructor && value.constructor.name) type = "instance of ".concat(value.constructor.name);
    else type = "type ".concat(_typeof(value));
    return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
}, TypeError);
createErrorType('ERR_MISSING_ARGS', function() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
    if (assert === undefined) assert = require('../assert');
    assert(args.length > 0, 'At least one arg needs to be specified');
    var msg = 'The ';
    var len = args.length;
    args = args.map(function(a) {
        return "\"".concat(a, "\"");
    });
    switch(len){
        case 1:
            msg += "".concat(args[0], " argument");
            break;
        case 2:
            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
            break;
        default:
            msg += args.slice(0, len - 1).join(', ');
            msg += ", and ".concat(args[len - 1], " arguments");
            break;
    }
    return "".concat(msg, " must be specified");
}, TypeError);
module.exports.codes = codes;

},{"../assert":"bTbxk","util/":"fZQoa"}],"fZQoa":[function(require,module,exports) {
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {
    };
    for(var i = 0; i < keys.length; i++)descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    return descriptors;
};
var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
    if (!isString(f)) {
        var objects = [];
        for(var i = 0; i < arguments.length; i++)objects.push(inspect(arguments[i]));
        return objects.join(' ');
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%') return '%';
        if (i >= len) return x;
        switch(x){
            case '%s':
                return String(args[i++]);
            case '%d':
                return Number(args[i++]);
            case '%j':
                try {
                    return JSON.stringify(args[i++]);
                } catch (_) {
                    return '[Circular]';
                }
            default:
                return x;
        }
    });
    for(var x1 = args[i]; i < len; x1 = args[++i])if (isNull(x1) || !isObject(x1)) str += ' ' + x1;
    else str += ' ' + inspect(x1);
    return str;
};
// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
    if (typeof process !== 'undefined' && process.noDeprecation === true) return fn;
    // Allow for deprecating things in the process of starting up.
    if (typeof process === 'undefined') return function() {
        return exports.deprecate(fn, msg).apply(this, arguments);
    };
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (process.throwDeprecation) throw new Error(msg);
            else if (process.traceDeprecation) console.trace(msg);
            else console.error(msg);
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
};
var debugs = {
};
var debugEnvRegex = /^$/;
var debugEnv;
exports.debuglog = function(set) {
    set = set.toUpperCase();
    if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
            var pid = process.pid;
            debugs[set] = function() {
                var msg = exports.format.apply(exports, arguments);
                console.error('%s %d: %s', set, pid, msg);
            };
        } else debugs[set] = function() {
        };
    }
    return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
    // default options
    var ctx = {
        seen: [],
        stylize: stylizeNoColor
    };
    // legacy...
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts)) // legacy...
    ctx.showHidden = opts;
    else if (opts) // got an "options" object
    exports._extend(ctx, opts);
    // set default options
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;
// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
    'bold': [
        1,
        22
    ],
    'italic': [
        3,
        23
    ],
    'underline': [
        4,
        24
    ],
    'inverse': [
        7,
        27
    ],
    'white': [
        37,
        39
    ],
    'grey': [
        90,
        39
    ],
    'black': [
        30,
        39
    ],
    'blue': [
        34,
        39
    ],
    'cyan': [
        36,
        39
    ],
    'green': [
        32,
        39
    ],
    'magenta': [
        35,
        39
    ],
    'red': [
        31,
        39
    ],
    'yellow': [
        33,
        39
    ]
};
// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    // "name": intentionally not styling
    'regexp': 'red'
};
function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];
    if (style) return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
    else return str;
}
function stylizeNoColor(str, styleType) {
    return str;
}
function arrayToHash(array) {
    var hash = {
    };
    array.forEach(function(val, idx) {
        hash[val] = true;
    });
    return hash;
}
function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) ret = formatValue(ctx, ret, recurseTimes);
        return ret;
    }
    // Primitive types cannot have properties
    var primitive = formatPrimitive(ctx, value);
    if (primitive) return primitive;
    // Look up the keys of the object.
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);
    if (ctx.showHidden) keys = Object.getOwnPropertyNames(value);
    // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) return formatError(value);
    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
        if (isFunction(value)) {
            var name = value.name ? ': ' + value.name : '';
            return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        if (isDate(value)) return ctx.stylize(Date.prototype.toString.call(value), 'date');
        if (isError(value)) return formatError(value);
    }
    var base = '', array = false, braces = [
        '{',
        '}'
    ];
    // Make Array say that they are Array
    if (isArray(value)) {
        array = true;
        braces = [
            '[',
            ']'
        ];
    }
    // Make functions say that they are functions
    if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
    }
    // Make RegExps say that they are RegExps
    if (isRegExp(value)) base = ' ' + RegExp.prototype.toString.call(value);
    // Make dates with properties first say the date
    if (isDate(value)) base = ' ' + Date.prototype.toUTCString.call(value);
    // Make error with message first say the error
    if (isError(value)) base = ' ' + formatError(value);
    if (keys.length === 0 && (!array || value.length == 0)) return braces[0] + base + braces[1];
    if (recurseTimes < 0) {
        if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        else return ctx.stylize('[Object]', 'special');
    }
    ctx.seen.push(value);
    var output;
    if (array) output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    else output = keys.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
    if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
    }
    if (isNumber(value)) return ctx.stylize('' + value, 'number');
    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
    // For some reason typeof null is "object", so special case here.
    if (isNull(value)) return ctx.stylize('null', 'null');
}
function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for(var i = 0, l = value.length; i < l; ++i)if (hasOwnProperty(value, String(i))) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    else output.push('');
    keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    });
    return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
    };
    if (desc.get) {
        if (desc.set) str = ctx.stylize('[Getter/Setter]', 'special');
        else str = ctx.stylize('[Getter]', 'special');
    } else if (desc.set) str = ctx.stylize('[Setter]', 'special');
    if (!hasOwnProperty(visibleKeys, key)) name = '[' + key + ']';
    if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) str = formatValue(ctx, desc.value, null);
            else str = formatValue(ctx, desc.value, recurseTimes - 1);
            if (str.indexOf('\n') > -1) {
                if (array) str = str.split('\n').map(function(line) {
                    return '  ' + line;
                }).join('\n').substr(2);
                else str = '\n' + str.split('\n').map(function(line) {
                    return '   ' + line;
                }).join('\n');
            }
        } else str = ctx.stylize('[Circular]', 'special');
    }
    if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) return str;
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, 'name');
        } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, 'string');
        }
    }
    return name + ': ' + str;
}
function reduceToSingleString(output, base, braces) {
    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);
    if (length > 60) return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = require('./support/types');
function isArray(ar) {
    return Array.isArray(ar);
}
exports.isArray = isArray;
function isBoolean(arg) {
    return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;
function isNull(arg) {
    return arg === null;
}
exports.isNull = isNull;
function isNullOrUndefined(arg) {
    return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
    return typeof arg === 'number';
}
exports.isNumber = isNumber;
function isString(arg) {
    return typeof arg === 'string';
}
exports.isString = isString;
function isSymbol(arg) {
    return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;
function isUndefined(arg) {
    return arg === void 0;
}
exports.isUndefined = isUndefined;
function isRegExp(re) {
    return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;
function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;
function isDate(d) {
    return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;
function isError(e) {
    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;
function isFunction(arg) {
    return typeof arg === 'function';
}
exports.isFunction = isFunction;
function isPrimitive(arg) {
    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;
exports.isBuffer = require('./support/isBuffer');
function objectToString(o) {
    return Object.prototype.toString.call(o);
}
function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
}
var months = [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec'
];
// 26 Feb 16:19:34
function timestamp() {
    var d = new Date();
    var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
    ].join(':');
    return [
        d.getDate(),
        months[d.getMonth()],
        time
    ].join(' ');
}
// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
    console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ exports.inherits = require('inherits');
exports._extend = function(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;
    var keys = Object.keys(add);
    var i = keys.length;
    while(i--)origin[keys[i]] = add[keys[i]];
    return origin;
};
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;
exports.promisify = function promisify(original) {
    if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== 'function') throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
        return fn;
    }
    function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
        });
        var args = [];
        for(var i = 0; i < arguments.length; i++)args.push(arguments[i]);
        args.push(function(err, value) {
            if (err) promiseReject(err);
            else promiseResolve(value);
        });
        try {
            original.apply(this, args);
        } catch (err) {
            promiseReject(err);
        }
        return promise;
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};
exports.promisify.custom = kCustomPromisifiedSymbol;
function callbackifyOnRejected(reason, cb) {
    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
    // Because `null` is a special error value in callbacks which means "no error
    // occurred", we error-wrap so the callback consumer can distinguish between
    // "the promise rejected with null" or "the promise fulfilled with undefined".
    if (!reason) {
        var newReason = new Error('Promise was rejected with a falsy value');
        newReason.reason = reason;
        reason = newReason;
    }
    return cb(reason);
}
function callbackify(original) {
    if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
    // We DO NOT return the promise as it gives the user a false sense that
    // the promise is actually somehow related to the callback's execution
    // and that the callback throwing will reject the promise.
    function callbackified() {
        var args = [];
        for(var i = 0; i < arguments.length; i++)args.push(arguments[i]);
        var maybeCb = args.pop();
        if (typeof maybeCb !== 'function') throw new TypeError('The last argument must be of type Function');
        var self = this;
        var cb = function() {
            return maybeCb.apply(self, arguments);
        };
        // In true node style we process the callback on `nextTick` with all the
        // implications (stack, `uncaughtException`, `async_hooks`)
        original.apply(this, args).then(function(ret) {
            process.nextTick(cb.bind(null, null, ret));
        }, function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
        });
    }
    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
    return callbackified;
}
exports.callbackify = callbackify;

},{"process":"lDnB8","./support/types":"9tAOj","./support/isBuffer":"k1wGR","inherits":"d3hL2"}],"9tAOj":[function(require,module,exports) {
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
'use strict';
var isArgumentsObject = require('is-arguments');
var isGeneratorFunction = require('is-generator-function');
var whichTypedArray = require('which-typed-array');
var isTypedArray = require('is-typed-array');
function uncurryThis(f) {
    return f.call.bind(f);
}
var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';
var ObjectToString = uncurryThis(Object.prototype.toString);
var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);
if (BigIntSupported) var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
if (SymbolSupported) var symbolValue = uncurryThis(Symbol.prototype.valueOf);
function checkBoxedPrimitive(value, prototypeValueOf) {
    if (typeof value !== 'object') return false;
    try {
        prototypeValueOf(value);
        return true;
    } catch (e) {
        return false;
    }
}
exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;
// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
    return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
}
exports.isPromise = isPromise;
function isArrayBufferView(value) {
    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) return ArrayBuffer.isView(value);
    return isTypedArray(value) || isDataView(value);
}
exports.isArrayBufferView = isArrayBufferView;
function isUint8Array(value) {
    return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;
function isUint8ClampedArray(value) {
    return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;
function isUint16Array(value) {
    return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;
function isUint32Array(value) {
    return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;
function isInt8Array(value) {
    return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;
function isInt16Array(value) {
    return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;
function isInt32Array(value) {
    return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;
function isFloat32Array(value) {
    return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;
function isFloat64Array(value) {
    return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;
function isBigInt64Array(value) {
    return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;
function isBigUint64Array(value) {
    return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;
function isMapToString(value) {
    return ObjectToString(value) === '[object Map]';
}
isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());
function isMap(value) {
    if (typeof Map === 'undefined') return false;
    return isMapToString.working ? isMapToString(value) : value instanceof Map;
}
exports.isMap = isMap;
function isSetToString(value) {
    return ObjectToString(value) === '[object Set]';
}
isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());
function isSet(value) {
    if (typeof Set === 'undefined') return false;
    return isSetToString.working ? isSetToString(value) : value instanceof Set;
}
exports.isSet = isSet;
function isWeakMapToString(value) {
    return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());
function isWeakMap(value) {
    if (typeof WeakMap === 'undefined') return false;
    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;
function isWeakSetToString(value) {
    return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());
function isWeakSet(value) {
    return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;
function isArrayBufferToString(value) {
    return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());
function isArrayBuffer(value) {
    if (typeof ArrayBuffer === 'undefined') return false;
    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;
function isDataViewToString(value) {
    return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
function isDataView(value) {
    if (typeof DataView === 'undefined') return false;
    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
}
exports.isDataView = isDataView;
// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
    return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
    if (typeof SharedArrayBufferCopy === 'undefined') return false;
    if (typeof isSharedArrayBufferToString.working === 'undefined') isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;
function isAsyncFunction(value) {
    return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;
function isMapIterator(value) {
    return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;
function isSetIterator(value) {
    return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;
function isGeneratorObject(value) {
    return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;
function isWebAssemblyCompiledModule(value) {
    return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
function isNumberObject(value) {
    return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;
function isStringObject(value) {
    return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;
function isBooleanObject(value) {
    return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;
function isBigIntObject(value) {
    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;
function isSymbolObject(value) {
    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;
function isBoxedPrimitive(value) {
    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
}
exports.isBoxedPrimitive = isBoxedPrimitive;
function isAnyArrayBuffer(value) {
    return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;
[
    'isProxy',
    'isExternal',
    'isModuleNamespaceObject'
].forEach(function(method) {
    Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
            throw new Error(method + ' is not supported in userland');
        }
    });
});

},{"is-arguments":"8gHs4","is-generator-function":"kT8Ou","which-typed-array":"iDM4O","is-typed-array":"6c7tM"}],"8gHs4":[function(require,module,exports) {
'use strict';
var hasToStringTag = require('has-tostringtag/shams')();
var callBound = require('call-bind/callBound');
var $toString = callBound('Object.prototype.toString');
var isStandardArguments = function isArguments(value) {
    if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) return false;
    return $toString(value) === '[object Arguments]';
};
var isLegacyArguments = function isArguments(value) {
    if (isStandardArguments(value)) return true;
    return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && $toString(value.callee) === '[object Function]';
};
var supportsStandardArguments = function() {
    return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{"has-tostringtag/shams":"7aneK","call-bind/callBound":"f0fyo"}],"7aneK":[function(require,module,exports) {
'use strict';
var hasSymbols = require('has-symbols/shams');
module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
};

},{"has-symbols/shams":"lhOu9"}],"lhOu9":[function(require,module,exports) {
'use strict';
/* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports = function hasSymbols() {
    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') return false;
    if (typeof Symbol.iterator === 'symbol') return true;
    var obj = {
    };
    var sym = Symbol('test');
    var symObj = Object(sym);
    if (typeof sym === 'string') return false;
    if (Object.prototype.toString.call(sym) !== '[object Symbol]') return false;
    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') return false;
    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
    var symVal = 42;
    obj[sym] = symVal;
    for(sym in obj)return false;
     // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) return false;
    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) return false;
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) return false;
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
    if (typeof Object.getOwnPropertyDescriptor === 'function') {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) return false;
    }
    return true;
};

},{}],"f0fyo":[function(require,module,exports) {
'use strict';
var GetIntrinsic = require('get-intrinsic');
var callBind = require('./');
var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
module.exports = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) return callBind(intrinsic);
    return intrinsic;
};

},{"get-intrinsic":"4hk6k","./":"bPDkM"}],"4hk6k":[function(require,module,exports) {
'use strict';
var undefined;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;
// eslint-disable-next-line consistent-return
var getEvalledConstructor = function(expressionSyntax) {
    try {
        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
    } catch (e) {
    }
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) try {
    $gOPD({
    }, '');
} catch (e) {
    $gOPD = null; // this is IE 8, which has a broken gOPD
}
var throwTypeError = function() {
    throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
    try {
        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
        arguments.callee; // IE 8 does not throw here
        return throwTypeError;
    } catch (calleeThrows) {
        try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, 'callee').get;
        } catch (gOPDthrows) {
            return throwTypeError;
        }
    }
}() : throwTypeError;
var hasSymbols = require('has-symbols')();
var getProto = Object.getPrototypeOf || function(x) {
    return x.__proto__;
}; // eslint-disable-line no-proto
var needsEval = {
};
var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);
var INTRINSICS = {
    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
    '%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
    '%AsyncFromSyncIteratorPrototype%': undefined,
    '%AsyncFunction%': needsEval,
    '%AsyncGenerator%': needsEval,
    '%AsyncGeneratorFunction%': needsEval,
    '%AsyncIteratorPrototype%': needsEval,
    '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
    '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': Error,
    '%eval%': eval,
    '%EvalError%': EvalError,
    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
    '%Function%': $Function,
    '%GeneratorFunction%': needsEval,
    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
    '%JSON%': typeof JSON === 'object' ? JSON : undefined,
    '%Map%': typeof Map === 'undefined' ? undefined : Map,
    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': Object,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
    '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
    '%RangeError%': RangeError,
    '%ReferenceError%': ReferenceError,
    '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set === 'undefined' ? undefined : Set,
    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
    '%Symbol%': hasSymbols ? Symbol : undefined,
    '%SyntaxError%': $SyntaxError,
    '%ThrowTypeError%': ThrowTypeError,
    '%TypedArray%': TypedArray,
    '%TypeError%': $TypeError,
    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
    '%URIError%': URIError,
    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};
var doEval1 = function doEval(name) {
    var value;
    if (name === '%AsyncFunction%') value = getEvalledConstructor('async function () {}');
    else if (name === '%GeneratorFunction%') value = getEvalledConstructor('function* () {}');
    else if (name === '%AsyncGeneratorFunction%') value = getEvalledConstructor('async function* () {}');
    else if (name === '%AsyncGenerator%') {
        var fn = doEval('%AsyncGeneratorFunction%');
        if (fn) value = fn.prototype;
    } else if (name === '%AsyncIteratorPrototype%') {
        var gen = doEval('%AsyncGenerator%');
        if (gen) value = getProto(gen.prototype);
    }
    INTRINSICS[name] = value;
    return value;
};
var LEGACY_ALIASES = {
    '%ArrayBufferPrototype%': [
        'ArrayBuffer',
        'prototype'
    ],
    '%ArrayPrototype%': [
        'Array',
        'prototype'
    ],
    '%ArrayProto_entries%': [
        'Array',
        'prototype',
        'entries'
    ],
    '%ArrayProto_forEach%': [
        'Array',
        'prototype',
        'forEach'
    ],
    '%ArrayProto_keys%': [
        'Array',
        'prototype',
        'keys'
    ],
    '%ArrayProto_values%': [
        'Array',
        'prototype',
        'values'
    ],
    '%AsyncFunctionPrototype%': [
        'AsyncFunction',
        'prototype'
    ],
    '%AsyncGenerator%': [
        'AsyncGeneratorFunction',
        'prototype'
    ],
    '%AsyncGeneratorPrototype%': [
        'AsyncGeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%BooleanPrototype%': [
        'Boolean',
        'prototype'
    ],
    '%DataViewPrototype%': [
        'DataView',
        'prototype'
    ],
    '%DatePrototype%': [
        'Date',
        'prototype'
    ],
    '%ErrorPrototype%': [
        'Error',
        'prototype'
    ],
    '%EvalErrorPrototype%': [
        'EvalError',
        'prototype'
    ],
    '%Float32ArrayPrototype%': [
        'Float32Array',
        'prototype'
    ],
    '%Float64ArrayPrototype%': [
        'Float64Array',
        'prototype'
    ],
    '%FunctionPrototype%': [
        'Function',
        'prototype'
    ],
    '%Generator%': [
        'GeneratorFunction',
        'prototype'
    ],
    '%GeneratorPrototype%': [
        'GeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%Int8ArrayPrototype%': [
        'Int8Array',
        'prototype'
    ],
    '%Int16ArrayPrototype%': [
        'Int16Array',
        'prototype'
    ],
    '%Int32ArrayPrototype%': [
        'Int32Array',
        'prototype'
    ],
    '%JSONParse%': [
        'JSON',
        'parse'
    ],
    '%JSONStringify%': [
        'JSON',
        'stringify'
    ],
    '%MapPrototype%': [
        'Map',
        'prototype'
    ],
    '%NumberPrototype%': [
        'Number',
        'prototype'
    ],
    '%ObjectPrototype%': [
        'Object',
        'prototype'
    ],
    '%ObjProto_toString%': [
        'Object',
        'prototype',
        'toString'
    ],
    '%ObjProto_valueOf%': [
        'Object',
        'prototype',
        'valueOf'
    ],
    '%PromisePrototype%': [
        'Promise',
        'prototype'
    ],
    '%PromiseProto_then%': [
        'Promise',
        'prototype',
        'then'
    ],
    '%Promise_all%': [
        'Promise',
        'all'
    ],
    '%Promise_reject%': [
        'Promise',
        'reject'
    ],
    '%Promise_resolve%': [
        'Promise',
        'resolve'
    ],
    '%RangeErrorPrototype%': [
        'RangeError',
        'prototype'
    ],
    '%ReferenceErrorPrototype%': [
        'ReferenceError',
        'prototype'
    ],
    '%RegExpPrototype%': [
        'RegExp',
        'prototype'
    ],
    '%SetPrototype%': [
        'Set',
        'prototype'
    ],
    '%SharedArrayBufferPrototype%': [
        'SharedArrayBuffer',
        'prototype'
    ],
    '%StringPrototype%': [
        'String',
        'prototype'
    ],
    '%SymbolPrototype%': [
        'Symbol',
        'prototype'
    ],
    '%SyntaxErrorPrototype%': [
        'SyntaxError',
        'prototype'
    ],
    '%TypedArrayPrototype%': [
        'TypedArray',
        'prototype'
    ],
    '%TypeErrorPrototype%': [
        'TypeError',
        'prototype'
    ],
    '%Uint8ArrayPrototype%': [
        'Uint8Array',
        'prototype'
    ],
    '%Uint8ClampedArrayPrototype%': [
        'Uint8ClampedArray',
        'prototype'
    ],
    '%Uint16ArrayPrototype%': [
        'Uint16Array',
        'prototype'
    ],
    '%Uint32ArrayPrototype%': [
        'Uint32Array',
        'prototype'
    ],
    '%URIErrorPrototype%': [
        'URIError',
        'prototype'
    ],
    '%WeakMapPrototype%': [
        'WeakMap',
        'prototype'
    ],
    '%WeakSetPrototype%': [
        'WeakSet',
        'prototype'
    ]
};
var bind = require('function-bind');
var hasOwn = require('has');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === '%' && last !== '%') throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
    else if (last === '%' && first !== '%') throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
    });
    return result;
};
/* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = '%' + alias[0] + '%';
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) value = doEval1(intrinsicName);
        if (typeof value === 'undefined' && !allowMissing) throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
        return {
            alias: alias,
            name: intrinsicName,
            value: value
        };
    }
    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};
module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== 'string' || name.length === 0) throw new $TypeError('intrinsic name must be a non-empty string');
    if (arguments.length > 1 && typeof allowMissing !== 'boolean') throw new $TypeError('"allowMissing" argument must be a boolean');
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([
            0,
            1
        ], alias));
    }
    for(var i = 1, isOwn = true; i < parts.length; i += 1){
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) throw new $SyntaxError('property names with quotes must have matching quotes');
        if (part === 'constructor' || !isOwn) skipFurtherCaching = true;
        intrinsicBaseName += '.' + part;
        intrinsicRealName = '%' + intrinsicBaseName + '%';
        if (hasOwn(INTRINSICS, intrinsicRealName)) value = INTRINSICS[intrinsicRealName];
        else if (value != null) {
            if (!(part in value)) {
                if (!allowMissing) throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;
                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) value = desc.get;
                else value = value[part];
            } else {
                isOwn = hasOwn(value, part);
                value = value[part];
            }
            if (isOwn && !skipFurtherCaching) INTRINSICS[intrinsicRealName] = value;
        }
    }
    return value;
};

},{"has-symbols":"iwqSm","function-bind":"13Udp","has":"6Inba"}],"iwqSm":[function(require,module,exports) {
'use strict';
var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');
module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== 'function') return false;
    if (typeof Symbol !== 'function') return false;
    if (typeof origSymbol('foo') !== 'symbol') return false;
    if (typeof Symbol('bar') !== 'symbol') return false;
    return hasSymbolSham();
};

},{"./shams":"lhOu9"}],"13Udp":[function(require,module,exports) {
'use strict';
var implementation = require('./implementation');
module.exports = Function.prototype.bind || implementation;

},{"./implementation":"iyrnl"}],"iyrnl":[function(require,module,exports) {
'use strict';
/* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';
module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) throw new TypeError(ERROR_MESSAGE + target);
    var args = slice.call(arguments, 1);
    var bound;
    var binder = function() {
        if (this instanceof bound) {
            var result = target.apply(this, args.concat(slice.call(arguments)));
            if (Object(result) === result) return result;
            return this;
        } else return target.apply(that, args.concat(slice.call(arguments)));
    };
    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for(var i = 0; i < boundLength; i++)boundArgs.push('$' + i);
    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);
    if (target.prototype) {
        var Empty = function Empty() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
};

},{}],"6Inba":[function(require,module,exports) {
'use strict';
var bind = require('function-bind');
module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":"13Udp"}],"bPDkM":[function(require,module,exports) {
'use strict';
var bind = require('function-bind');
var GetIntrinsic = require('get-intrinsic');
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');
if ($defineProperty) try {
    $defineProperty({
    }, 'a', {
        value: 1
    });
} catch (e) {
    // IE 8 has a broken defineProperty
    $defineProperty = null;
}
module.exports = function callBind(originalFunction) {
    var func = $reflectApply(bind, $call, arguments);
    if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, 'length');
        if (desc.configurable) // original length, plus the receiver, minus any additional arguments (after the receiver)
        $defineProperty(func, 'length', {
            value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
        });
    }
    return func;
};
var applyBind = function applyBind() {
    return $reflectApply(bind, $apply, arguments);
};
if ($defineProperty) $defineProperty(module.exports, 'apply', {
    value: applyBind
});
else module.exports.apply = applyBind;

},{"function-bind":"13Udp","get-intrinsic":"4hk6k"}],"kT8Ou":[function(require,module,exports) {
'use strict';
var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = require('has-tostringtag/shams')();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function() {
    if (!hasToStringTag) return false;
    try {
        return Function('return function*() {}')();
    } catch (e) {
    }
};
var GeneratorFunction;
module.exports = function isGeneratorFunction(fn) {
    if (typeof fn !== 'function') return false;
    if (isFnRegex.test(fnToStr.call(fn))) return true;
    if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === '[object GeneratorFunction]';
    }
    if (!getProto) return false;
    if (typeof GeneratorFunction === 'undefined') {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
    }
    return getProto(fn) === GeneratorFunction;
};

},{"has-tostringtag/shams":"7aneK"}],"iDM4O":[function(require,module,exports) {
var global = arguments[3];
'use strict';
var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');
var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();
var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();
var $slice = callBound('String.prototype.slice');
var toStrTags = {
};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) forEach(typedArrays, function(typedArray) {
    if (typeof g[typedArray] === 'function') {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
                var superProto = getPrototypeOf(proto);
                descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
        }
    }
});
var tryTypedArrays = function tryAllTypedArrays(value) {
    var foundName = false;
    forEach(toStrTags, function(getter, typedArray) {
        if (!foundName) try {
            var name = getter.call(value);
            if (name === typedArray) foundName = name;
        } catch (e) {
        }
    });
    return foundName;
};
var isTypedArray = require('is-typed-array');
module.exports = function whichTypedArray(value) {
    if (!isTypedArray(value)) return false;
    if (!hasToStringTag || !(Symbol.toStringTag in value)) return $slice($toString(value), 8, -1);
    return tryTypedArrays(value);
};

},{"foreach":"h6wOr","available-typed-arrays":"9Wjza","call-bind/callBound":"f0fyo","has-tostringtag/shams":"7aneK","es-abstract/helpers/getOwnPropertyDescriptor":"gx5Wc","is-typed-array":"6c7tM"}],"h6wOr":[function(require,module,exports) {
var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;
module.exports = function forEach(obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') throw new TypeError('iterator must be a function');
    var l = obj.length;
    if (l === +l) for(var i = 0; i < l; i++)fn.call(ctx, obj[i], i, obj);
    else {
        for(var k in obj)if (hasOwn.call(obj, k)) fn.call(ctx, obj[k], k, obj);
    }
};

},{}],"9Wjza":[function(require,module,exports) {
var global = arguments[3];
'use strict';
var possibleNames = [
    'BigInt64Array',
    'BigUint64Array',
    'Float32Array',
    'Float64Array',
    'Int16Array',
    'Int32Array',
    'Int8Array',
    'Uint16Array',
    'Uint32Array',
    'Uint8Array',
    'Uint8ClampedArray'
];
var g = typeof globalThis === 'undefined' ? global : globalThis;
module.exports = function availableTypedArrays() {
    var out = [];
    for(var i = 0; i < possibleNames.length; i++)if (typeof g[possibleNames[i]] === 'function') out[out.length] = possibleNames[i];
    return out;
};

},{}],"gx5Wc":[function(require,module,exports) {
'use strict';
var GetIntrinsic = require('get-intrinsic');
var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
if ($gOPD) try {
    $gOPD([], 'length');
} catch (e) {
    // IE 8 has a broken gOPD
    $gOPD = null;
}
module.exports = $gOPD;

},{"get-intrinsic":"4hk6k"}],"6c7tM":[function(require,module,exports) {
var global = arguments[3];
'use strict';
var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');
var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();
var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();
var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
    for(var i = 0; i < array.length; i += 1){
        if (array[i] === value) return i;
    }
    return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {
};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) forEach(typedArrays, function(typedArray) {
    var arr = new g[typedArray]();
    if (Symbol.toStringTag in arr) {
        var proto = getPrototypeOf(arr);
        var descriptor = gOPD(proto, Symbol.toStringTag);
        if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
        }
        toStrTags[typedArray] = descriptor.get;
    }
});
var tryTypedArrays = function tryAllTypedArrays(value) {
    var anyTrue = false;
    forEach(toStrTags, function(getter, typedArray) {
        if (!anyTrue) try {
            anyTrue = getter.call(value) === typedArray;
        } catch (e) {
        }
    });
    return anyTrue;
};
module.exports = function isTypedArray(value) {
    if (!value || typeof value !== 'object') return false;
    if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        var tag = $slice($toString(value), 8, -1);
        return $indexOf(typedArrays, tag) > -1;
    }
    if (!gOPD) return false;
    return tryTypedArrays(value);
};

},{"foreach":"h6wOr","available-typed-arrays":"9Wjza","call-bind/callBound":"f0fyo","has-tostringtag/shams":"7aneK","es-abstract/helpers/getOwnPropertyDescriptor":"gx5Wc"}],"k1wGR":[function(require,module,exports) {
module.exports = function isBuffer(arg) {
    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

},{}],"d3hL2":[function(require,module,exports) {
if (typeof Object.create === 'function') // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
};

},{}],"1yuNT":[function(require,module,exports) {
var process = require("process");
// Currently in sync with Node.js lib/internal/assert/assertion_error.js
// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c
'use strict';
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {
        };
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _wrapNativeSuper(Class1) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;
        if (typeof Class !== "function") throw new TypeError("Super expression must either be null or a function");
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _setPrototypeOf(Wrapper, Class);
    };
    return _wrapNativeSuper(Class1);
}
function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
    } catch (e) {
        return false;
    }
}
function _construct(Parent1, args1, Class2) {
    if (isNativeReflectConstruct()) _construct = Reflect.construct;
    else _construct = function _construct(Parent, args, Class) {
        var a = [
            null
        ];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
    };
    return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _setPrototypeOf(o1, p1) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o1, p1);
}
function _getPrototypeOf(o2) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o2);
}
function _typeof(obj1) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj1);
}
var _require = require('util/'), inspect = _require.inspect;
var _require2 = require('../errors'), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) this_len = str.length;
    return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
function repeat(str, count) {
    count = Math.floor(count);
    if (str.length == 0 || count == 0) return '';
    var maxCount = str.length * count;
    count = Math.floor(Math.log(count) / Math.log(2));
    while(count){
        str += str;
        count--;
    }
    str += str.substring(0, maxCount - str.length);
    return str;
}
var blue = '';
var green = '';
var red = '';
var white = '';
var kReadableOperator = {
    deepStrictEqual: 'Expected values to be strictly deep-equal:',
    strictEqual: 'Expected values to be strictly equal:',
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: 'Expected values to be loosely deep-equal:',
    equal: 'Expected values to be loosely equal:',
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: 'Values identical but not reference-equal:'
}; // Comparing short primitives should just show === / !== instead of using the
// diff.
var kMaxShortLength = 10;
function copyError(source) {
    var keys = Object.keys(source);
    var target = Object.create(Object.getPrototypeOf(source));
    keys.forEach(function(key) {
        target[key] = source[key];
    });
    Object.defineProperty(target, 'message', {
        value: source.message
    });
    return target;
}
function inspectValue(val) {
    // The util.inspect default values could be changed. This makes sure the
    // error messages contain the necessary information nevertheless.
    return inspect(val, {
        compact: false,
        customInspect: false,
        depth: 1000,
        maxArrayLength: Infinity,
        // Assert compares only enumerable properties (with a few exceptions).
        showHidden: false,
        // Having a long line as error is better than wrapping the line for
        // comparison for now.
        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
        // have meta information about the inspected properties (i.e., know where
        // in what line the property starts and ends).
        breakLength: Infinity,
        // Assert does not detect proxies currently.
        showProxy: false,
        sorted: true,
        // Inspect getters as we also check them when comparing entries.
        getters: true
    });
}
function createErrDiff(actual, expected, operator) {
    var other = '';
    var res = '';
    var lastPos = 0;
    var end = '';
    var skipped = false;
    var actualInspected = inspectValue(actual);
    var actualLines = actualInspected.split('\n');
    var expectedLines = inspectValue(expected).split('\n');
    var i = 0;
    var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
    // for the `strictEqual` operator.
    if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) operator = 'strictEqualObject';
     // If "actual" and "expected" fit on a single line and they are not strictly
    // equal, check further special handling.
    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
        var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
        // kMaxShortLength and if neither is an object and at least one of them is
        // not `zero`, use the strict equal comparison to visualize the output.
        if (inputLength <= kMaxShortLength) {
            if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) // -0 === +0
            return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
        } else if (operator !== 'strictEqualObject') {
            // If the stderr is a tty and the input length is lower than the current
            // columns per line, add a mismatch indicator below the output. If it is
            // not a tty, use a default value of 80 characters.
            var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
            if (inputLength < maxLength) {
                while(actualLines[0][i] === expectedLines[0][i])i++;
                 // Ignore the first characters.
                if (i > 2) {
                    // Add position indicator for the first mismatch in case it is a
                    // single line and the input length is less than the column length.
                    indicator = "\n  ".concat(repeat(' ', i), "^");
                    i = 0;
                }
            }
        }
    } // Remove all ending lines that match (this optimizes the output for
    // readability by reducing the number of total changed lines).
    var a = actualLines[actualLines.length - 1];
    var b = expectedLines[expectedLines.length - 1];
    while(a === b){
        if (i++ < 2) end = "\n  ".concat(a).concat(end);
        else other = a;
        actualLines.pop();
        expectedLines.pop();
        if (actualLines.length === 0 || expectedLines.length === 0) break;
        a = actualLines[actualLines.length - 1];
        b = expectedLines[expectedLines.length - 1];
    }
    var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
    // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
    if (maxLines === 0) {
        // We have to get the result again. The lines were all removed before.
        var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.
        if (_actualLines.length > 30) {
            _actualLines[26] = "".concat(blue, "...").concat(white);
            while(_actualLines.length > 27)_actualLines.pop();
        }
        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
    }
    if (i > 3) {
        end = "\n".concat(blue, "...").concat(white).concat(end);
        skipped = true;
    }
    if (other !== '') {
        end = "\n  ".concat(other).concat(end);
        other = '';
    }
    var printedLines = 0;
    var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
    for(i = 0; i < maxLines; i++){
        // Only extra expected lines exist
        var cur = i - lastPos;
        if (actualLines.length < i + 1) {
            // If the last diverging line is more than one line above and the
            // current line is at least line three, add some of the former lines and
            // also add dots to indicate skipped entries.
            if (cur > 1 && i > 2) {
                if (cur > 4) {
                    res += "\n".concat(blue, "...").concat(white);
                    skipped = true;
                } else if (cur > 3) {
                    res += "\n  ".concat(expectedLines[i - 2]);
                    printedLines++;
                }
                res += "\n  ".concat(expectedLines[i - 1]);
                printedLines++;
            } // Mark the current line as the last diverging one.
            lastPos = i; // Add the expected line to the cache.
            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
            printedLines++; // Only extra actual lines exist
        } else if (expectedLines.length < i + 1) {
            // If the last diverging line is more than one line above and the
            // current line is at least line three, add some of the former lines and
            // also add dots to indicate skipped entries.
            if (cur > 1 && i > 2) {
                if (cur > 4) {
                    res += "\n".concat(blue, "...").concat(white);
                    skipped = true;
                } else if (cur > 3) {
                    res += "\n  ".concat(actualLines[i - 2]);
                    printedLines++;
                }
                res += "\n  ".concat(actualLines[i - 1]);
                printedLines++;
            } // Mark the current line as the last diverging one.
            lastPos = i; // Add the actual line to the result.
            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
            printedLines++; // Lines diverge
        } else {
            var expectedLine = expectedLines[i];
            var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
            // a trailing comma. In that case it is actually identical and we should
            // mark it as such.
            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
            // add a comma at the end of the actual line. Otherwise the output could
            // look weird as in:
            //
            //   [
            //     1         // No comma at the end!
            // +   2
            //   ]
            //
            if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
                divergingLines = false;
                actualLine += ',';
            }
            if (divergingLines) {
                // If the last diverging line is more than one line above and the
                // current line is at least line three, add some of the former lines and
                // also add dots to indicate skipped entries.
                if (cur > 1 && i > 2) {
                    if (cur > 4) {
                        res += "\n".concat(blue, "...").concat(white);
                        skipped = true;
                    } else if (cur > 3) {
                        res += "\n  ".concat(actualLines[i - 2]);
                        printedLines++;
                    }
                    res += "\n  ".concat(actualLines[i - 1]);
                    printedLines++;
                } // Mark the current line as the last diverging one.
                lastPos = i; // Add the actual line to the result and cache the expected diverging
                // line so consecutive diverging lines show up as +++--- and not +-+-+-.
                res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
                other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
                printedLines += 2; // Lines are identical
            } else {
                // Add all cached information to the result before adding other things
                // and reset the cache.
                res += other;
                other = ''; // If the last diverging line is exactly one line above or if it is the
                // very first line, add the line to the result.
                if (cur === 1 || i === 0) {
                    res += "\n  ".concat(actualLine);
                    printedLines++;
                }
            }
        } // Inspected object to big (Show ~20 rows max)
        if (printedLines > 20 && i < maxLines - 2) return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
    return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
}
var AssertionError1 = /*#__PURE__*/ function(_Error) {
    _inherits(AssertionError, _Error);
    function AssertionError(options) {
        var _this;
        _classCallCheck(this, AssertionError);
        if (_typeof(options) !== 'object' || options === null) throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
        var actual = options.actual, expected = options.expected;
        var limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        if (message != null) _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
        else {
            if (process.stderr && process.stderr.isTTY) {
                // Reset on each call to make sure we handle dynamically set environment
                // variables correct.
                if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                    blue = "\x1B[34m";
                    green = "\x1B[32m";
                    white = "\x1B[39m";
                    red = "\x1B[31m";
                } else {
                    blue = '';
                    green = '';
                    white = '';
                    red = '';
                }
            } // Prevent the error stack from being visible by duplicating the error
            // in a very close way to the original in case both sides are actually
            // instances of Error.
            if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
                actual = copyError(actual);
                expected = copyError(expected);
            }
            if (operator === 'deepStrictEqual' || operator === 'strictEqual') _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
            else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
                // In case the objects are equal but the operator requires unequal, show
                // the first object and say A equals B
                var base = kReadableOperator[operator];
                var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.
                if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) base = kReadableOperator.notStrictEqualObject;
                 // Only remove lines in case it makes sense to collapse those.
                // TODO: Accept env to always show the full error.
                if (res.length > 30) {
                    res[26] = "".concat(blue, "...").concat(white);
                    while(res.length > 27)res.pop();
                } // Only print a single input.
                if (res.length === 1) _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
                else _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
            } else {
                var _res = inspectValue(actual);
                var other = '';
                var knownOperators = kReadableOperator[operator];
                if (operator === 'notDeepEqual' || operator === 'notEqual') {
                    _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                    if (_res.length > 1024) _res = "".concat(_res.slice(0, 1021), "...");
                } else {
                    other = "".concat(inspectValue(expected));
                    if (_res.length > 512) _res = "".concat(_res.slice(0, 509), "...");
                    if (other.length > 512) other = "".concat(other.slice(0, 509), "...");
                    if (operator === 'deepEqual' || operator === 'equal') _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                    else other = " ".concat(operator, " ").concat(other);
                }
                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
            }
        }
        Error.stackTraceLimit = limit;
        _this.generatedMessage = !message;
        Object.defineProperty(_assertThisInitialized(_this), 'name', {
            value: 'AssertionError [ERR_ASSERTION]',
            enumerable: false,
            writable: true,
            configurable: true
        });
        _this.code = 'ERR_ASSERTION';
        _this.actual = actual;
        _this.expected = expected;
        _this.operator = operator;
        if (Error.captureStackTrace) // eslint-disable-next-line no-restricted-syntax
        Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
         // Create error message including the error code in the name.
        _this.stack; // Reset the name.
        _this.name = 'AssertionError';
        return _possibleConstructorReturn(_this);
    }
    _createClass(AssertionError, [
        {
            key: "toString",
            value: function toString() {
                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
            }
        },
        {
            key: inspect.custom,
            value: function value(recurseTimes, ctx) {
                // This limits the `actual` and `expected` property default inspection to
                // the minimum depth. Otherwise those values would be too verbose compared
                // to the actual error message which contains a combined view of these two
                // input values.
                return inspect(this, _objectSpread({
                }, ctx, {
                    customInspect: false,
                    depth: 0
                }));
            }
        }
    ]);
    return AssertionError;
}(_wrapNativeSuper(Error));
module.exports = AssertionError1;

},{"process":"lDnB8","util/":"fZQoa","../errors":"LSymQ"}],"fc6lQ":[function(require,module,exports) {
/**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */ 'use strict';
function assign(target, firstSource) {
    if (target === undefined || target === null) throw new TypeError('Cannot convert first argument to object');
    var to = Object(target);
    for(var i = 1; i < arguments.length; i++){
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null) continue;
        var keysArray = Object.keys(Object(nextSource));
        for(var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++){
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
            if (desc !== undefined && desc.enumerable) to[nextKey] = nextSource[nextKey];
        }
    }
    return to;
}
function polyfill() {
    if (!Object.assign) Object.defineProperty(Object, 'assign', {
        enumerable: false,
        configurable: true,
        writable: true,
        value: assign
    });
}
module.exports = {
    assign: assign,
    polyfill: polyfill
};

},{}],"V34yE":[function(require,module,exports) {
'use strict';
var define = require('define-properties');
var callBind = require('call-bind');
var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');
var polyfill = callBind(getPolyfill(), Object);
define(polyfill, {
    getPolyfill: getPolyfill,
    implementation: implementation,
    shim: shim
});
module.exports = polyfill;

},{"define-properties":"arjVC","call-bind":"bPDkM","./implementation":"jrTsN","./polyfill":"lK2ec","./shim":"5RYmr"}],"arjVC":[function(require,module,exports) {
'use strict';
var keys = require('object-keys');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;
var isFunction = function(fn) {
    return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};
var arePropertyDescriptorsSupported = function() {
    var obj = {
    };
    try {
        origDefineProperty(obj, 'x', {
            enumerable: false,
            value: obj
        });
        // eslint-disable-next-line no-unused-vars, no-restricted-syntax
        for(var _ in obj)return false;
        return obj.x === obj;
    } catch (e) {
        return false;
    }
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();
var defineProperty = function(object, name, value, predicate) {
    if (name in object && (!isFunction(predicate) || !predicate())) return;
    if (supportsDescriptors) origDefineProperty(object, name, {
        configurable: true,
        enumerable: false,
        value: value,
        writable: true
    });
    else object[name] = value;
};
var defineProperties = function(object, map) {
    var predicates = arguments.length > 2 ? arguments[2] : {
    };
    var props = keys(map);
    if (hasSymbols) props = concat.call(props, Object.getOwnPropertySymbols(map));
    for(var i = 0; i < props.length; i += 1)defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
};
defineProperties.supportsDescriptors = !!supportsDescriptors;
module.exports = defineProperties;

},{"object-keys":"6eM0B"}],"6eM0B":[function(require,module,exports) {
'use strict';
var slice = Array.prototype.slice;
var isArgs = require('./isArguments');
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
    return origKeys(o);
} : require('./implementation');
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
    if (Object.keys) {
        var keysWorksWithArguments = function() {
            // Safari 5.0 bug
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) Object.keys = function keys(object) {
            if (isArgs(object)) return originalKeys(slice.call(object));
            return originalKeys(object);
        };
    } else Object.keys = keysShim;
    return Object.keys || keysShim;
};
module.exports = keysShim;

},{"./isArguments":"7W6XO","./implementation":"k0enN"}],"7W6XO":[function(require,module,exports) {
'use strict';
var toStr = Object.prototype.toString;
module.exports = function isArguments(value) {
    var str = toStr.call(value);
    var isArgs = str === '[object Arguments]';
    if (!isArgs) isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
    return isArgs;
};

},{}],"k0enN":[function(require,module,exports) {
'use strict';
var keysShim;
if (!Object.keys) {
    // modified from https://github.com/es-shims/es5-shim
    var has = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var isArgs = require('./isArguments'); // eslint-disable-line global-require
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({
        toString: null
    }, 'toString');
    var hasProtoEnumBug = isEnumerable.call(function() {
    }, 'prototype');
    var dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
    ];
    var equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
    };
    var hasAutomationEqualityBug = function() {
        /* global window */ if (typeof window === 'undefined') return false;
        for(var k in window)try {
            if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') try {
                equalsConstructorPrototype(window[k]);
            } catch (e) {
                return true;
            }
        } catch (e) {
            return true;
        }
        return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o) {
        /* global window */ if (typeof window === 'undefined' || !hasAutomationEqualityBug) return equalsConstructorPrototype(o);
        try {
            return equalsConstructorPrototype(o);
        } catch (e) {
            return false;
        }
    };
    keysShim = function keys(object) {
        var isObject = object !== null && typeof object === 'object';
        var isFunction = toStr.call(object) === '[object Function]';
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === '[object String]';
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) throw new TypeError('Object.keys called on a non-object');
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) for(var i = 0; i < object.length; ++i)theKeys.push(String(i));
        if (isArguments && object.length > 0) for(var j = 0; j < object.length; ++j)theKeys.push(String(j));
        else {
            for(var name in object)if (!(skipProto && name === 'prototype') && has.call(object, name)) theKeys.push(String(name));
        }
        if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
            for(var k = 0; k < dontEnums.length; ++k)if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) theKeys.push(dontEnums[k]);
        }
        return theKeys;
    };
}
module.exports = keysShim;

},{"./isArguments":"7W6XO"}],"jrTsN":[function(require,module,exports) {
'use strict';
var numberIsNaN = function(value) {
    return value !== value;
};
module.exports = function is(a, b) {
    if (a === 0 && b === 0) return 1 / a === 1 / b;
    if (a === b) return true;
    if (numberIsNaN(a) && numberIsNaN(b)) return true;
    return false;
};

},{}],"lK2ec":[function(require,module,exports) {
'use strict';
var implementation = require('./implementation');
module.exports = function getPolyfill() {
    return typeof Object.is === 'function' ? Object.is : implementation;
};

},{"./implementation":"jrTsN"}],"5RYmr":[function(require,module,exports) {
'use strict';
var getPolyfill = require('./polyfill');
var define = require('define-properties');
module.exports = function shimObjectIs() {
    var polyfill = getPolyfill();
    define(Object, {
        is: polyfill
    }, {
        is: function testObjectIs() {
            return Object.is !== polyfill;
        }
    });
    return polyfill;
};

},{"./polyfill":"lK2ec","define-properties":"arjVC"}],"56qKQ":[function(require,module,exports) {
// Currently in sync with Node.js lib/internal/util/comparisons.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
'use strict';
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;
    try {
        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function _typeof(obj1) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj1);
}
var regexFlagsSupported = /a/g.flags !== undefined;
var arrayFromSet = function arrayFromSet(set) {
    var array = [];
    set.forEach(function(value) {
        return array.push(value);
    });
    return array;
};
var arrayFromMap = function arrayFromMap(map) {
    var array = [];
    map.forEach(function(value, key) {
        return array.push([
            key,
            value
        ]);
    });
    return array;
};
var objectIs = Object.is ? Object.is : require('object-is');
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
};
var numberIsNaN = Number.isNaN ? Number.isNaN : require('is-nan');
function uncurryThis(f) {
    return f.call.bind(f);
}
var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);
var _require$types = require('util/').types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
function isNonIndex(key) {
    if (key.length === 0 || key.length > 10) return true;
    for(var i = 0; i < key.length; i++){
        var code = key.charCodeAt(i);
        if (code < 48 || code > 57) return true;
    } // The maximum size for an array is 2 ** 32 -1.
    return key.length === 10 && key >= Math.pow(2, 32);
}
function getOwnNonIndexProperties(value) {
    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
} // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */ function compare(a, b) {
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
}
var ONLY_ENUMERABLE = undefined;
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3; // Check if they have the same source and flags
function areSimilarRegExps(a, b) {
    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}
function areSimilarFloatArrays(a, b) {
    if (a.byteLength !== b.byteLength) return false;
    for(var offset = 0; offset < a.byteLength; offset++){
        if (a[offset] !== b[offset]) return false;
    }
    return true;
}
function areSimilarTypedArrays(a, b) {
    if (a.byteLength !== b.byteLength) return false;
    return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(val1, val2) {
    if (isNumberObject(val1)) return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
    if (isStringObject(val1)) return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
    if (isBooleanObject(val1)) return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
    if (isBigIntObject(val1)) return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
} // Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.
function innerDeepEqual(val1, val2, strict, memos) {
    // All identical values are equivalent, as determined by ===.
    if (val1 === val2) {
        if (val1 !== 0) return true;
        return strict ? objectIs(val1, val2) : true;
    } // Check more closely if val1 and val2 are equal.
    if (strict) {
        if (_typeof(val1) !== 'object') return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
        if (_typeof(val2) !== 'object' || val1 === null || val2 === null) return false;
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) return false;
    } else {
        if (val1 === null || _typeof(val1) !== 'object') {
            if (val2 === null || _typeof(val2) !== 'object') // eslint-disable-next-line eqeqeq
            return val1 == val2;
            return false;
        }
        if (val2 === null || _typeof(val2) !== 'object') return false;
    }
    var val1Tag = objectToString(val1);
    var val2Tag = objectToString(val2);
    if (val1Tag !== val2Tag) return false;
    if (Array.isArray(val1)) {
        // Check for sparse arrays and general fast path
        if (val1.length !== val2.length) return false;
        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (keys1.length !== keys2.length) return false;
        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
    } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
    // wan't to early return out of the rest of the checks. However we can check
    // if the second value is one of these values and the first isn't.
    if (val1Tag === '[object Object]') {
        // return keyCheck(val1, val2, strict, memos, kNoIterator);
        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) return false;
    }
    if (isDate(val1)) {
        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) return false;
    } else if (isRegExp(val1)) {
        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) return false;
    } else if (isNativeError(val1) || val1 instanceof Error) {
        // Do not compare the stack as it might differ even though the error itself
        // is otherwise identical.
        if (val1.message !== val2.message || val1.name !== val2.name) return false;
    } else if (isArrayBufferView(val1)) {
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) return false;
        } else if (!areSimilarTypedArrays(val1, val2)) return false;
         // Buffer.compare returns true, so val1.length === val2.length. If they both
        // only contain numeric keys, we don't need to exam further than checking
        // the symbols.
        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (_keys.length !== _keys2.length) return false;
        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
    } else if (isSet(val1)) {
        if (!isSet(val2) || val1.size !== val2.size) return false;
        return keyCheck(val1, val2, strict, memos, kIsSet);
    } else if (isMap(val1)) {
        if (!isMap(val2) || val1.size !== val2.size) return false;
        return keyCheck(val1, val2, strict, memos, kIsMap);
    } else if (isAnyArrayBuffer(val1)) {
        if (!areEqualArrayBuffers(val1, val2)) return false;
    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) return false;
    return keyCheck(val1, val2, strict, memos, kNoIterator);
}
function getEnumerables(val, keys) {
    return keys.filter(function(k) {
        return propertyIsEnumerable(val, k);
    });
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
    // For all remaining Object pairs, including Array, objects and Maps,
    // equivalence is determined by having:
    // a) The same number of owned enumerable properties
    // b) The same set of keys/indexes (although not necessarily the same order)
    // c) Equivalent values for every corresponding key/index
    // d) For Sets and Maps, equal contents
    // Note: this accounts for both named and indexed properties on Arrays.
    if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.
        if (aKeys.length !== bKeys.length) return false;
    } // Cheap key test
    var i = 0;
    for(; i < aKeys.length; i++){
        if (!hasOwnProperty(val2, aKeys[i])) return false;
    }
    if (strict && arguments.length === 5) {
        var symbolKeysA = objectGetOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
            var count = 0;
            for(i = 0; i < symbolKeysA.length; i++){
                var key = symbolKeysA[i];
                if (propertyIsEnumerable(val1, key)) {
                    if (!propertyIsEnumerable(val2, key)) return false;
                    aKeys.push(key);
                    count++;
                } else if (propertyIsEnumerable(val2, key)) return false;
            }
            var symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) return false;
        } else {
            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) return false;
        }
    }
    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) return true;
     // Use memos to handle cycles.
    if (memos === undefined) memos = {
        val1: new Map(),
        val2: new Map(),
        position: 0
    };
    else {
        // We prevent up to two map.has(x) calls by directly retrieving the value
        // and checking for undefined. The map can only contain numbers, so it is
        // safe to check for undefined only.
        var val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== undefined) {
            var val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== undefined) return val2MemoA === val2MemoB;
        }
        memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
}
function setHasEqualElement(set, val1, strict, memo) {
    // Go looking.
    var setValues = arrayFromSet(set);
    for(var i = 0; i < setValues.length; i++){
        var val2 = setValues[i];
        if (innerDeepEqual(val1, val2, strict, memo)) {
            // Remove the matching element to make sure we do not check that again.
            set.delete(val2);
            return true;
        }
    }
    return false;
} // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').
function findLooseMatchingPrimitives(prim) {
    switch(_typeof(prim)){
        case 'undefined':
            return null;
        case 'object':
            // Only pass in null as object!
            return undefined;
        case 'symbol':
            return false;
        case 'string':
            prim = +prim;
        // Loose equal entries exist only if the string is possible to convert to
        // a regular number and not NaN.
        // Fall through
        case 'number':
            if (numberIsNaN(prim)) return false;
    }
    return true;
}
function setMightHaveLoosePrim(a, b, prim) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null) return altValue;
    return b.has(altValue) && !a.has(altValue);
}
function mapMightHaveLoosePrim(a, b, prim, item, memo) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null) return altValue;
    var curB = b.get(altValue);
    if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) return false;
    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}
function setEquiv(a, b, strict, memo) {
    // This is a lazily initiated Set of entries which have to be compared
    // pairwise.
    var set = null;
    var aValues = arrayFromSet(a);
    for(var i = 0; i < aValues.length; i++){
        var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
        // heavy sets but it is a minor slow down for primitives. As they are fast
        // to check this improves the worst case scenario instead.
        if (_typeof(val) === 'object' && val !== null) {
            if (set === null) set = new Set();
             // If the specified value doesn't exist in the second set its an not null
            // object (or non strict only: a not matching primitive) we'll need to go
            // hunting for something thats deep-(strict-)equal to it. To make this
            // O(n log n) complexity we have to copy these values in a new set first.
            set.add(val);
        } else if (!b.has(val)) {
            if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.
            if (!setMightHaveLoosePrim(a, b, val)) return false;
            if (set === null) set = new Set();
            set.add(val);
        }
    }
    if (set !== null) {
        var bValues = arrayFromSet(b);
        for(var _i = 0; _i < bValues.length; _i++){
            var _val = bValues[_i]; // We have to check if a primitive value is already
            // matching and only if it's not, go hunting for it.
            if (_typeof(_val) === 'object' && _val !== null) {
                if (!setHasEqualElement(set, _val, strict, memo)) return false;
            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) return false;
        }
        return set.size === 0;
    }
    return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
    // To be able to handle cases like:
    //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
    // ... we need to consider *all* matching keys, not just the first we find.
    var setValues = arrayFromSet(set);
    for(var i = 0; i < setValues.length; i++){
        var key2 = setValues[i];
        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
            set.delete(key2);
            return true;
        }
    }
    return false;
}
function mapEquiv(a, b, strict, memo) {
    var set = null;
    var aEntries = arrayFromMap(a);
    for(var i = 0; i < aEntries.length; i++){
        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
        if (_typeof(key) === 'object' && key !== null) {
            if (set === null) set = new Set();
            set.add(key);
        } else {
            // By directly retrieving the value we prevent another b.has(key) check in
            // almost all possible cases.
            var item2 = b.get(key);
            if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
                if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
                // keys.
                if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
                if (set === null) set = new Set();
                set.add(key);
            }
        }
    }
    if (set !== null) {
        var bEntries = arrayFromMap(b);
        for(var _i2 = 0; _i2 < bEntries.length; _i2++){
            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
            if (_typeof(key) === 'object' && key !== null) {
                if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
            } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) return false;
        }
        return set.size === 0;
    }
    return true;
}
function objEquiv(a, b, strict, keys, memos, iterationType) {
    // Sets and maps don't have their entries accessible via normal object
    // properties.
    var i = 0;
    if (iterationType === kIsSet) {
        if (!setEquiv(a, b, strict, memos)) return false;
    } else if (iterationType === kIsMap) {
        if (!mapEquiv(a, b, strict, memos)) return false;
    } else if (iterationType === kIsArray) for(; i < a.length; i++){
        if (hasOwnProperty(a, i)) {
            if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) return false;
        } else if (hasOwnProperty(b, i)) return false;
        else {
            // Array is sparse.
            var keysA = Object.keys(a);
            for(; i < keysA.length; i++){
                var key = keysA[i];
                if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) return false;
            }
            if (keysA.length !== Object.keys(b).length) return false;
            return true;
        }
    }
     // The pair must have equivalent values for every corresponding key.
    // Possibly expensive deep test:
    for(i = 0; i < keys.length; i++){
        var _key = keys[i];
        if (!innerDeepEqual(a[_key], b[_key], strict, memos)) return false;
    }
    return true;
}
function isDeepEqual(val1, val2) {
    return innerDeepEqual(val1, val2, kLoose);
}
function isDeepStrictEqual(val1, val2) {
    return innerDeepEqual(val1, val2, kStrict);
}
module.exports = {
    isDeepEqual: isDeepEqual,
    isDeepStrictEqual: isDeepStrictEqual
};

},{"object-is":"V34yE","is-nan":"j4zD4","util/":"fZQoa"}],"j4zD4":[function(require,module,exports) {
'use strict';
var callBind = require('call-bind');
var define = require('define-properties');
var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');
var polyfill = callBind(getPolyfill(), Number);
/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ define(polyfill, {
    getPolyfill: getPolyfill,
    implementation: implementation,
    shim: shim
});
module.exports = polyfill;

},{"call-bind":"bPDkM","define-properties":"arjVC","./implementation":"i6FAo","./polyfill":"1cnxy","./shim":"jKLXz"}],"i6FAo":[function(require,module,exports) {
'use strict';
/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module.exports = function isNaN(value) {
    return value !== value;
};

},{}],"1cnxy":[function(require,module,exports) {
'use strict';
var implementation = require('./implementation');
module.exports = function getPolyfill() {
    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) return Number.isNaN;
    return implementation;
};

},{"./implementation":"i6FAo"}],"jKLXz":[function(require,module,exports) {
'use strict';
var define = require('define-properties');
var getPolyfill = require('./polyfill');
/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module.exports = function shimNumberIsNaN() {
    var polyfill = getPolyfill();
    define(Number, {
        isNaN: polyfill
    }, {
        isNaN: function testIsNaN() {
            return Number.isNaN !== polyfill;
        }
    });
    return polyfill;
};

},{"define-properties":"arjVC","./polyfill":"1cnxy"}],"bitOz":[function(require,module,exports) {
'use strict';
var acorn = require('acorn');
var objectAssign = require('object-assign');
module.exports = isExpression;
var DEFAULT_OPTIONS = {
    throw: false,
    strict: false,
    lineComment: false
};
function isExpression(src, options) {
    options = objectAssign({
    }, DEFAULT_OPTIONS, options);
    try {
        var parser = new acorn.Parser(options, src, 0);
        if (options.strict) parser.strict = true;
        if (!options.lineComment) parser.skipLineComment = function(startSkip) {
            this.raise(this.pos, 'Line comments not allowed in an expression');
        };
        parser.nextToken();
        parser.parseExpression();
        if (parser.type !== acorn.tokTypes.eof) parser.unexpected();
    } catch (ex) {
        if (!options.throw) return false;
        throw ex;
    }
    return true;
}

},{"acorn":"a2LDj","object-assign":"iUUFa"}],"a2LDj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Node", ()=>Node
);
parcelHelpers.export(exports, "Parser", ()=>Parser
);
parcelHelpers.export(exports, "Position", ()=>Position
);
parcelHelpers.export(exports, "SourceLocation", ()=>SourceLocation
);
parcelHelpers.export(exports, "TokContext", ()=>TokContext
);
parcelHelpers.export(exports, "Token", ()=>Token
);
parcelHelpers.export(exports, "TokenType", ()=>TokenType
);
parcelHelpers.export(exports, "defaultOptions", ()=>defaultOptions
);
parcelHelpers.export(exports, "getLineInfo", ()=>getLineInfo
);
parcelHelpers.export(exports, "isIdentifierChar", ()=>isIdentifierChar
);
parcelHelpers.export(exports, "isIdentifierStart", ()=>isIdentifierStart
);
parcelHelpers.export(exports, "isNewLine", ()=>isNewLine
);
parcelHelpers.export(exports, "keywordTypes", ()=>keywords$1
);
parcelHelpers.export(exports, "lineBreak", ()=>lineBreak
);
parcelHelpers.export(exports, "lineBreakG", ()=>lineBreakG
);
parcelHelpers.export(exports, "nonASCIIwhitespace", ()=>nonASCIIwhitespace
);
parcelHelpers.export(exports, "parse", ()=>parse
);
parcelHelpers.export(exports, "parseExpressionAt", ()=>parseExpressionAt
);
parcelHelpers.export(exports, "tokContexts", ()=>types$1
);
parcelHelpers.export(exports, "tokTypes", ()=>types
);
parcelHelpers.export(exports, "tokenizer", ()=>tokenizer
);
parcelHelpers.export(exports, "version", ()=>version
);
// Reserved word lists for various dialects of the language
var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
};
// And the keywords
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
// ## Character categories
// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js
// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    157,
    310,
    10,
    21,
    11,
    7,
    153,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    349,
    41,
    7,
    1,
    79,
    28,
    11,
    0,
    9,
    21,
    107,
    20,
    28,
    22,
    13,
    52,
    76,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    85,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    159,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    230,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    35,
    56,
    264,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    328,
    18,
    190,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2749,
    1070,
    4050,
    582,
    8634,
    568,
    8,
    30,
    114,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    689,
    63,
    129,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    29,
    6135,
    9,
    1237,
    43,
    8,
    8952,
    286,
    50,
    2,
    18,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    2357,
    44,
    11,
    6,
    17,
    0,
    370,
    43,
    1301,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42717,
    35,
    4148,
    12,
    221,
    3,
    5761,
    15,
    7472,
    3104,
    541,
    1507,
    4938
];
// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    370,
    1,
    154,
    10,
    176,
    2,
    54,
    14,
    32,
    9,
    16,
    3,
    46,
    10,
    54,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    161,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    193,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    84,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    406,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    330,
    3,
    19306,
    9,
    135,
    4,
    60,
    6,
    26,
    9,
    1014,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    5319,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    262,
    6,
    10,
    9,
    419,
    13,
    1495,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239
];
// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
    var pos = 65536;
    for(var i = 0; i < set.length; i += 2){
        pos += set[i];
        if (pos > code) return false;
        pos += set[i + 1];
        if (pos >= code) return true;
    }
}
// Test whether a given character code starts an identifier.
function isIdentifierStart(code, astral) {
    if (code < 65) return code === 36;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123) return true;
    if (code <= 65535) return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
    if (astral === false) return false;
    return isInAstralSet(code, astralIdentifierStartCodes);
}
// Test whether a given character is part of an identifier.
function isIdentifierChar(code, astral) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123) return true;
    if (code <= 65535) return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
    if (astral === false) return false;
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
// ## Token types
// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.
// All token type variables start with an underscore, to make them
// easy to recognize.
// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.
var TokenType = function TokenType(label, conf) {
    if (conf === void 0) conf = {
    };
    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
};
function binop(name, prec) {
    return new TokenType(name, {
        beforeExpr: true,
        binop: prec
    });
}
var beforeExpr = {
    beforeExpr: true
}, startsExpr = {
    startsExpr: true
};
// Map keyword names to token types.
var keywords$1 = {
};
// Succinct definitions of keyword token types
function kw(name, options) {
    if (options === void 0) options = {
    };
    options.keyword = name;
    return keywords$1[name] = new TokenType(name, options);
}
var types = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    eof: new TokenType("eof"),
    // Punctuation token types.
    bracketL: new TokenType("[", {
        beforeExpr: true,
        startsExpr: true
    }),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {
        beforeExpr: true,
        startsExpr: true
    }),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {
        beforeExpr: true,
        startsExpr: true
    }),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {
        beforeExpr: true,
        startsExpr: true
    }),
    // Operators. These carry several kinds of properties to help the
    // parser use them properly (the presence of these properties is
    // what categorizes them as operators).
    //
    // `binop`, when present, specifies that this operator is a binary
    // operator, and will refer to its precedence.
    //
    // `prefix` and `postfix` mark the operator as a prefix or postfix
    // unary operator.
    //
    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
    // binary operators with a very low precedence, that should result
    // in AssignmentExpression nodes.
    eq: new TokenType("=", {
        beforeExpr: true,
        isAssign: true
    }),
    assign: new TokenType("_=", {
        beforeExpr: true,
        isAssign: true
    }),
    incDec: new TokenType("++/--", {
        prefix: true,
        postfix: true,
        startsExpr: true
    }),
    prefix: new TokenType("!/~", {
        beforeExpr: true,
        prefix: true,
        startsExpr: true
    }),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {
        beforeExpr: true,
        binop: 9,
        prefix: true,
        startsExpr: true
    }),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {
        beforeExpr: true
    }),
    coalesce: binop("??", 1),
    // Keyword token types.
    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {
        isLoop: true,
        beforeExpr: true
    }),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {
        isLoop: true
    }),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {
        isLoop: true
    }),
    _with: kw("with"),
    _new: kw("new", {
        beforeExpr: true,
        startsExpr: true
    }),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {
        beforeExpr: true,
        binop: 7
    }),
    _instanceof: kw("instanceof", {
        beforeExpr: true,
        binop: 7
    }),
    _typeof: kw("typeof", {
        beforeExpr: true,
        prefix: true,
        startsExpr: true
    }),
    _void: kw("void", {
        beforeExpr: true,
        prefix: true,
        startsExpr: true
    }),
    _delete: kw("delete", {
        beforeExpr: true,
        prefix: true,
        startsExpr: true
    })
};
// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code, ecma2019String) {
    return code === 10 || code === 13 || !ecma2019String && (code === 8232 || code === 8233);
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref1 = Object.prototype;
var hasOwnProperty = ref1.hasOwnProperty;
var toString = ref1.toString;
// Checks if an object has a property.
function has(obj, propName) {
    return hasOwnProperty.call(obj, propName);
}
var isArray = Array.isArray || function(obj) {
    return toString.call(obj) === "[object Array]";
};
function wordsRegexp(words) {
    return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}
// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.
var Position = function Position(line, col) {
    this.line = line;
    this.column = col;
};
Position.prototype.offset = function offset(n) {
    return new Position(this.line, this.column + n);
};
var SourceLocation = function SourceLocation(p, start, end) {
    this.start = start;
    this.end = end;
    if (p.sourceFile !== null) this.source = p.sourceFile;
};
// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.
function getLineInfo(input, offset) {
    for(var line = 1, cur = 0;;){
        lineBreakG.lastIndex = cur;
        var match = lineBreakG.exec(input);
        if (match && match.index < offset) {
            ++line;
            cur = match.index + match[0].length;
        } else return new Position(line, offset - cur);
    }
}
// A second optional argument can be given to further configure
// the parser process. These options are recognized:
var defaultOptions = {
    // `ecmaVersion` indicates the ECMAScript version to parse. Must be
    // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
    // (2019). This influences support for strict mode, the set of
    // reserved words, and support for new syntax features. The default
    // is 10.
    ecmaVersion: 10,
    // `sourceType` indicates the mode the code should be parsed in.
    // Can be either `"script"` or `"module"`. This influences global
    // strict mode and parsing of `import` and `export` declarations.
    sourceType: "script",
    // `onInsertedSemicolon` can be a callback that will be called
    // when a semicolon is automatically inserted. It will be passed
    // the position of the comma as an offset, and if `locations` is
    // enabled, it is given the location as a `{line, column}` object
    // as second argument.
    onInsertedSemicolon: null,
    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
    // trailing commas.
    onTrailingComma: null,
    // By default, reserved words are only enforced if ecmaVersion >= 5.
    // Set `allowReserved` to a boolean value to explicitly turn this on
    // an off. When this option has the value "never", reserved words
    // and keywords can also not be used as property names.
    allowReserved: null,
    // When enabled, a return at the top level is not considered an
    // error.
    allowReturnOutsideFunction: false,
    // When enabled, import/export statements are not constrained to
    // appearing at the top of the program.
    allowImportExportEverywhere: false,
    // When enabled, await identifiers are allowed to appear at the top-level scope,
    // but they are still not allowed in non-async functions.
    allowAwaitOutsideFunction: false,
    // When enabled, hashbang directive in the beginning of file
    // is allowed and treated as a line comment.
    allowHashBang: false,
    // When `locations` is on, `loc` properties holding objects with
    // `start` and `end` properties in `{line, column}` form (with
    // line being 1-based and column 0-based) will be attached to the
    // nodes.
    locations: false,
    // A function can be passed as `onToken` option, which will
    // cause Acorn to call that function with object in the same
    // format as tokens returned from `tokenizer().getToken()`. Note
    // that you are not allowed to call the parser from the
    // callback—that will corrupt its internal state.
    onToken: null,
    // A function can be passed as `onComment` option, which will
    // cause Acorn to call that function with `(block, text, start,
    // end)` parameters whenever a comment is skipped. `block` is a
    // boolean indicating whether this is a block (`/* */`) comment,
    // `text` is the content of the comment, and `start` and `end` are
    // character offsets that denote the start and end of the comment.
    // When the `locations` option is on, two more parameters are
    // passed, the full `{line, column}` locations of the start and
    // end of the comments. Note that you are not allowed to call the
    // parser from the callback—that will corrupt its internal state.
    onComment: null,
    // Nodes have their start and end characters offsets recorded in
    // `start` and `end` properties (directly on the node, rather than
    // the `loc` object, which holds line/column data. To also add a
    // [semi-standardized][range] `range` property holding a `[start,
    // end]` array with the same numbers, set the `ranges` option to
    // `true`.
    //
    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
    ranges: false,
    // It is possible to parse multiple files into a single AST by
    // passing the tree produced by parsing the first file as
    // `program` option in subsequent parses. This will add the
    // toplevel forms of the parsed file to the `Program` (top) node
    // of an existing parse tree.
    program: null,
    // When `locations` is on, you can pass this to record the source
    // file in every node's `loc` object.
    sourceFile: null,
    // This value, if given, is stored in every node, whether
    // `locations` is on or off.
    directSourceFile: null,
    // When enabled, parenthesized expressions are represented by
    // (non-standard) ParenthesizedExpression nodes
    preserveParens: false
};
// Interpret and default an options object
function getOptions(opts) {
    var options = {
    };
    for(var opt in defaultOptions)options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
    if (options.ecmaVersion >= 2015) options.ecmaVersion -= 2009;
    if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;
    if (isArray(options.onToken)) {
        var tokens = options.onToken;
        options.onToken = function(token) {
            return tokens.push(token);
        };
    }
    if (isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);
    return options;
}
function pushComment(options, array) {
    return function(block, text, start, end, startLoc, endLoc) {
        var comment = {
            type: block ? "Block" : "Line",
            value: text,
            start: start,
            end: end
        };
        if (options.locations) comment.loc = new SourceLocation(this, startLoc, endLoc);
        if (options.ranges) comment.range = [
            start,
            end
        ];
        array.push(comment);
    };
}
// Each scope gets a bitset that may contain these flags
var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128;
function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
// Used in checkLVal and declareName to determine the type of a binding
var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5; // Special case for function names as bound inside the function
var Parser = function Parser(options, input, startPos) {
    this.options = options = getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
    var reserved = "";
    if (options.allowReserved !== true) {
        for(var v = options.ecmaVersion;; v--){
            if (reserved = reservedWords[v]) break;
        }
        if (options.sourceType === "module") reserved += " await";
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);
    // Used to signal to callers of `readWord1` whether the word
    // contained any escape sequences. This is needed because words with
    // escape sequences must not be interpreted as keywords.
    this.containsEsc = false;
    // Set up token state
    // The current position of the tokenizer in the input.
    if (startPos) {
        this.pos = startPos;
        this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
        this.pos = this.lineStart = 0;
        this.curLine = 1;
    }
    // Properties of the current token:
    // Its type
    this.type = types.eof;
    // For tokens that include more information than their type, the value
    this.value = null;
    // Its start and end offset
    this.start = this.end = this.pos;
    // And, if locations are used, the {line, column} object
    // corresponding to those offsets
    this.startLoc = this.endLoc = this.curPosition();
    // Position information for the previous token
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;
    // The context stack is used to superficially track syntactic
    // context to predict whether a regular expression is allowed in a
    // given position.
    this.context = this.initialContext();
    this.exprAllowed = true;
    // Figure out if it's a module code.
    this.inModule = options.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);
    // Used to signify the start of a potential arrow function
    this.potentialArrowAt = -1;
    // Positions to delayed-check that yield/await does not exist in default parameters.
    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    // Labels in scope.
    this.labels = [];
    // Thus-far undefined exports.
    this.undefinedExports = {
    };
    // If enabled, skip leading hashbang line.
    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
    // Scope tracking for duplicate variable names (see scope.js)
    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);
    // For RegExp validation
    this.regexpState = null;
};
var prototypeAccessors = {
    inFunction: {
        configurable: true
    },
    inGenerator: {
        configurable: true
    },
    inAsync: {
        configurable: true
    },
    allowSuper: {
        configurable: true
    },
    allowDirectSuper: {
        configurable: true
    },
    treatFunctionsAsVar: {
        configurable: true
    }
};
Parser.prototype.parse = function parse() {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
    return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
};
prototypeAccessors.inAsync.get = function() {
    return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
};
prototypeAccessors.allowSuper.get = function() {
    return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
};
prototypeAccessors.allowDirectSuper.get = function() {
    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
};
// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction() {
    return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
};
Parser.extend = function extend() {
    var plugins = [], len = arguments.length;
    while(len--)plugins[len] = arguments[len];
    var cls = this;
    for(var i = 0; i < plugins.length; i++)cls = plugins[i](cls);
    return cls;
};
Parser.parse = function parse(input, options) {
    return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
    var parser = new this(options, input, pos);
    parser.nextToken();
    return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options) {
    return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp = Parser.prototype;
// ## Parser utilities
var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp.strictDirective = function(start) {
    for(;;){
        // Try to find string literal.
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        var match = literal.exec(this.input.slice(start));
        if (!match) return false;
        if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
        }
        start += match[0].length;
        // Skip semicolon, if any.
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        if (this.input[start] === ";") start++;
    }
};
// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.
pp.eat = function(type) {
    if (this.type === type) {
        this.next();
        return true;
    } else return false;
};
// Tests whether parsed token is a contextual keyword.
pp.isContextual = function(name) {
    return this.type === types.name && this.value === name && !this.containsEsc;
};
// Consumes contextual keyword if possible.
pp.eatContextual = function(name) {
    if (!this.isContextual(name)) return false;
    this.next();
    return true;
};
// Asserts that following token is given contextual keyword.
pp.expectContextual = function(name) {
    if (!this.eatContextual(name)) this.unexpected();
};
// Test whether a semicolon can be inserted at the current position.
pp.canInsertSemicolon = function() {
    return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp.insertSemicolon = function() {
    if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
        return true;
    }
};
// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.
pp.semicolon = function() {
    if (!this.eat(types.semi) && !this.insertSemicolon()) this.unexpected();
};
pp.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) {
        if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
        if (!notNext) this.next();
        return true;
    }
};
// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.
pp.expect = function(type) {
    this.eat(type) || this.unexpected();
};
// Raise an unexpected token error.
pp.unexpected = function(pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
};
function DestructuringErrors() {
    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
}
pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors) return;
    if (refDestructuringErrors.trailingComma > -1) this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1) this.raiseRecoverable(parens, "Parenthesized pattern");
};
pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) return false;
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;
    if (shorthandAssign >= 0) this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
    if (doubleProto >= 0) this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
};
pp.checkYieldAwaitInDefaultParams = function() {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) this.raise(this.yieldPos, "Yield expression cannot be a default value");
    if (this.awaitPos) this.raise(this.awaitPos, "Await expression cannot be a default value");
};
pp.isSimpleAssignTarget = function(expr) {
    if (expr.type === "ParenthesizedExpression") return this.isSimpleAssignTarget(expr.expression);
    return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$1 = Parser.prototype;
// ### Statement parsing
// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.
pp$1.parseTopLevel = function(node) {
    var exports = {
    };
    if (!node.body) node.body = [];
    while(this.type !== types.eof){
        var stmt = this.parseStatement(null, true, exports);
        node.body.push(stmt);
    }
    if (this.inModule) for(var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1){
        var name = list[i];
        this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
    }
    this.adaptDirectivePrologue(node.body);
    this.next();
    node.sourceType = this.options.sourceType;
    return this.finishNode(node, "Program");
};
var loopLabel = {
    kind: "loop"
}, switchLabel = {
    kind: "switch"
};
pp$1.isLet = function(context) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return false;
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    // For ambiguous cases, determine if a LexicalDeclaration (or only a
    // Statement) is allowed here. If context is not empty then only a Statement
    // is allowed. However, `let [` is an explicit negative lookahead for
    // ExpressionStatement, so special-case it first.
    if (nextCh === 91) return true;
     // '['
    if (context) return false;
    if (nextCh === 123) return true;
     // '{'
    if (isIdentifierStart(nextCh, true)) {
        var pos = next + 1;
        while(isIdentifierChar(this.input.charCodeAt(pos), true))++pos;
        var ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) return true;
    }
    return false;
};
// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$1.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return false;
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length;
    return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)));
};
// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.
pp$1.parseStatement = function(context, topLevel, exports) {
    var starttype = this.type, node = this.startNode(), kind;
    if (this.isLet(context)) {
        starttype = types._var;
        kind = "let";
    }
    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.
    switch(starttype){
        case types._break:
        case types._continue:
            return this.parseBreakContinueStatement(node, starttype.keyword);
        case types._debugger:
            return this.parseDebuggerStatement(node);
        case types._do:
            return this.parseDoStatement(node);
        case types._for:
            return this.parseForStatement(node);
        case types._function:
            // Function as sole body of either an if statement or a labeled statement
            // works, but not when it is part of a labeled statement that is the sole
            // body of an if statement.
            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) this.unexpected();
            return this.parseFunctionStatement(node, false, !context);
        case types._class:
            if (context) this.unexpected();
            return this.parseClass(node, true);
        case types._if:
            return this.parseIfStatement(node);
        case types._return:
            return this.parseReturnStatement(node);
        case types._switch:
            return this.parseSwitchStatement(node);
        case types._throw:
            return this.parseThrowStatement(node);
        case types._try:
            return this.parseTryStatement(node);
        case types._const:
        case types._var:
            kind = kind || this.value;
            if (context && kind !== "var") this.unexpected();
            return this.parseVarStatement(node, kind);
        case types._while:
            return this.parseWhileStatement(node);
        case types._with:
            return this.parseWithStatement(node);
        case types.braceL:
            return this.parseBlock(true, node);
        case types.semi:
            return this.parseEmptyStatement(node);
        case types._export:
        case types._import:
            if (this.options.ecmaVersion > 10 && starttype === types._import) {
                skipWhiteSpace.lastIndex = this.pos;
                var skip = skipWhiteSpace.exec(this.input);
                var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
                if (nextCh === 40 || nextCh === 46) return this.parseExpressionStatement(node, this.parseExpression());
            }
            if (!this.options.allowImportExportEverywhere) {
                if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
                if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
            }
            return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports);
        // If the statement does not start with a statement keyword or a
        // brace, it's an ExpressionStatement or LabeledStatement. We
        // simply start parsing an expression, and afterwards, if the
        // next token is a colon and the expression was a simple
        // Identifier node, we switch to interpreting it as a label.
        default:
            if (this.isAsyncFunction()) {
                if (context) this.unexpected();
                this.next();
                return this.parseFunctionStatement(node, true, !context);
            }
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) return this.parseLabeledStatement(node, maybeName, expr, context);
            else return this.parseExpressionStatement(node, expr);
    }
};
pp$1.parseBreakContinueStatement = function(node, keyword) {
    var isBreak = keyword === "break";
    this.next();
    if (this.eat(types.semi) || this.insertSemicolon()) node.label = null;
    else if (this.type !== types.name) this.unexpected();
    else {
        node.label = this.parseIdent();
        this.semicolon();
    }
    // Verify that there is an actual destination to break or
    // continue to.
    var i = 0;
    for(; i < this.labels.length; ++i){
        var lab = this.labels[i];
        if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
            if (node.label && isBreak) break;
        }
    }
    if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$1.parseDebuggerStatement = function(node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement");
};
pp$1.parseDoStatement = function(node) {
    this.next();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types._while);
    node.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6) this.eat(types.semi);
    else this.semicolon();
    return this.finishNode(node, "DoWhileStatement");
};
// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.
pp$1.parseForStatement = function(node) {
    this.next();
    var awaitAt = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types.parenL);
    if (this.type === types.semi) {
        if (awaitAt > -1) this.unexpected(awaitAt);
        return this.parseFor(node, null);
    }
    var isLet = this.isLet();
    if (this.type === types._var || this.type === types._const || isLet) {
        var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
        this.next();
        this.parseVar(init$1, true, kind);
        this.finishNode(init$1, "VariableDeclaration");
        if ((this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
            if (this.options.ecmaVersion >= 9) {
                if (this.type === types._in) {
                    if (awaitAt > -1) this.unexpected(awaitAt);
                } else node.await = awaitAt > -1;
            }
            return this.parseForIn(node, init$1);
        }
        if (awaitAt > -1) this.unexpected(awaitAt);
        return this.parseFor(node, init$1);
    }
    var refDestructuringErrors = new DestructuringErrors;
    var init = this.parseExpression(true, refDestructuringErrors);
    if (this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
        if (this.options.ecmaVersion >= 9) {
            if (this.type === types._in) {
                if (awaitAt > -1) this.unexpected(awaitAt);
            } else node.await = awaitAt > -1;
        }
        this.toAssignable(init, false, refDestructuringErrors);
        this.checkLVal(init);
        return this.parseForIn(node, init);
    } else this.checkExpressionErrors(refDestructuringErrors, true);
    if (awaitAt > -1) this.unexpected(awaitAt);
    return this.parseFor(node, init);
};
pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$1.parseIfStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    // allow function declarations in branches, but only in non-strict mode
    node.consequent = this.parseStatement("if");
    node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
    return this.finishNode(node, "IfStatement");
};
pp$1.parseReturnStatement = function(node) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
    this.next();
    // In `return` (and `break`/`continue`), the keywords with
    // optional arguments, we eagerly look for a semicolon or the
    // possibility to insert one.
    if (this.eat(types.semi) || this.insertSemicolon()) node.argument = null;
    else {
        node.argument = this.parseExpression();
        this.semicolon();
    }
    return this.finishNode(node, "ReturnStatement");
};
pp$1.parseSwitchStatement = function(node) {
    this.next();
    node.discriminant = this.parseParenExpression();
    node.cases = [];
    this.expect(types.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);
    // Statements under must be grouped (by label) in SwitchCase
    // nodes. `cur` is used to keep the node that we are currently
    // adding statements to.
    var cur;
    for(var sawDefault = false; this.type !== types.braceR;)if (this.type === types._case || this.type === types._default) {
        var isCase = this.type === types._case;
        if (cur) this.finishNode(cur, "SwitchCase");
        node.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) cur.test = this.parseExpression();
        else {
            if (sawDefault) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
            sawDefault = true;
            cur.test = null;
        }
        this.expect(types.colon);
    } else {
        if (!cur) this.unexpected();
        cur.consequent.push(this.parseStatement(null));
    }
    this.exitScope();
    if (cur) this.finishNode(cur, "SwitchCase");
    this.next(); // Closing brace
    this.labels.pop();
    return this.finishNode(node, "SwitchStatement");
};
pp$1.parseThrowStatement = function(node) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement");
};
// Reused empty array added for node fields that are always empty.
var empty = [];
pp$1.parseTryStatement = function(node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;
    if (this.type === types._catch) {
        var clause = this.startNode();
        this.next();
        if (this.eat(types.parenL)) {
            clause.param = this.parseBindingAtom();
            var simple = clause.param.type === "Identifier";
            this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
            this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
            this.expect(types.parenR);
        } else {
            if (this.options.ecmaVersion < 10) this.unexpected();
            clause.param = null;
            this.enterScope(0);
        }
        clause.body = this.parseBlock(false);
        this.exitScope();
        node.handler = this.finishNode(clause, "CatchClause");
    }
    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
    if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
    return this.finishNode(node, "TryStatement");
};
pp$1.parseVarStatement = function(node, kind) {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration");
};
pp$1.parseWhileStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node, "WhileStatement");
};
pp$1.parseWithStatement = function(node) {
    if (this.strict) this.raise(this.start, "'with' in strict mode");
    this.next();
    node.object = this.parseParenExpression();
    node.body = this.parseStatement("with");
    return this.finishNode(node, "WithStatement");
};
pp$1.parseEmptyStatement = function(node) {
    this.next();
    return this.finishNode(node, "EmptyStatement");
};
pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
    for(var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1){
        var label = list[i$1];
        if (label.name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
    var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
    for(var i = this.labels.length - 1; i >= 0; i--){
        var label$1 = this.labels[i];
        if (label$1.statementStart === node.start) {
            // Update information about previous labels on this node
            label$1.statementStart = this.start;
            label$1.kind = kind;
        } else break;
    }
    this.labels.push({
        name: maybeName,
        kind: kind,
        statementStart: this.start
    });
    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement");
};
pp$1.parseExpressionStatement = function(node, expr) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement");
};
// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).
pp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {
    if (createNewLexicalScope === void 0) createNewLexicalScope = true;
    if (node === void 0) node = this.startNode();
    node.body = [];
    this.expect(types.braceL);
    if (createNewLexicalScope) this.enterScope(0);
    while(this.type !== types.braceR){
        var stmt = this.parseStatement(null);
        node.body.push(stmt);
    }
    if (exitStrict) this.strict = false;
    this.next();
    if (createNewLexicalScope) this.exitScope();
    return this.finishNode(node, "BlockStatement");
};
// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.
pp$1.parseFor = function(node, init) {
    node.init = init;
    this.expect(types.semi);
    node.test = this.type === types.semi ? null : this.parseExpression();
    this.expect(types.semi);
    node.update = this.type === types.parenR ? null : this.parseExpression();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, "ForStatement");
};
// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.
pp$1.parseForIn = function(node, init) {
    var isForIn = this.type === types._in;
    this.next();
    if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
    else if (init.type === "AssignmentPattern") this.raise(init.start, "Invalid left-hand side in for-loop");
    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
// Parse a list of variable declarations.
pp$1.parseVar = function(node, isFor, kind) {
    node.declarations = [];
    node.kind = kind;
    for(;;){
        var decl = this.startNode();
        this.parseVarId(decl, kind);
        if (this.eat(types.eq)) decl.init = this.parseMaybeAssign(isFor);
        else if (kind === "const" && !(this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) this.unexpected();
        else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        else decl.init = null;
        node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types.comma)) break;
    }
    return node;
};
pp$1.parseVarId = function(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
// Parse a function declaration or literal (depending on the
// `statement & FUNC_STATEMENT`).
// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
    this.initFunction(node);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
        if (this.type === types.star && statement & FUNC_HANGING_STATEMENT) this.unexpected();
        node.generator = this.eat(types.star);
    }
    if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
    if (statement & FUNC_STATEMENT) {
        node.id = statement & FUNC_NULLABLE_ID && this.type !== types.name ? null : this.parseIdent();
        if (node.id && !(statement & FUNC_HANGING_STATEMENT)) this.checkLVal(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node.async, node.generator));
    if (!(statement & FUNC_STATEMENT)) node.id = this.type === types.name ? this.parseIdent() : null;
    this.parseFunctionParams(node);
    this.parseFunctionBody(node, allowExpressionBody, false);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$1.parseFunctionParams = function(node) {
    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
};
// Parse a class declaration or literal (depending on the
// `isStatement` parameter).
pp$1.parseClass = function(node, isStatement) {
    this.next();
    // ecma-262 14.6 Class Definitions
    // A class definition is always strict mode code.
    var oldStrict = this.strict;
    this.strict = true;
    this.parseClassId(node, isStatement);
    this.parseClassSuper(node);
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types.braceL);
    while(this.type !== types.braceR){
        var element = this.parseClassElement(node.superClass !== null);
        if (element) {
            classBody.body.push(element);
            if (element.type === "MethodDefinition" && element.kind === "constructor") {
                if (hadConstructor) this.raise(element.start, "Duplicate constructor in the same class");
                hadConstructor = true;
            }
        }
    }
    this.strict = oldStrict;
    this.next();
    node.body = this.finishNode(classBody, "ClassBody");
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$1.parseClassElement = function(constructorAllowsSuper) {
    var this$1 = this;
    if (this.eat(types.semi)) return null;
    var method = this.startNode();
    var tryContextual = function(k, noLineBreak) {
        if (noLineBreak === void 0) noLineBreak = false;
        var start = this$1.start, startLoc = this$1.startLoc;
        if (!this$1.eatContextual(k)) return false;
        if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) return true;
        if (method.key) this$1.unexpected();
        method.computed = false;
        method.key = this$1.startNodeAt(start, startLoc);
        method.key.name = k;
        this$1.finishNode(method.key, "Identifier");
        return false;
    };
    method.kind = "method";
    method.static = tryContextual("static");
    var isGenerator = this.eat(types.star);
    var isAsync = false;
    if (!isGenerator) {
        if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
            isAsync = true;
            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
        } else if (tryContextual("get")) method.kind = "get";
        else if (tryContextual("set")) method.kind = "set";
    }
    if (!method.key) this.parsePropertyName(method);
    var key = method.key;
    var allowsDirectSuper = false;
    if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
        if (method.kind !== "method") this.raise(key.start, "Constructor can't have get/set modifier");
        if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
        if (isAsync) this.raise(key.start, "Constructor can't be an async method");
        method.kind = "constructor";
        allowsDirectSuper = constructorAllowsSuper;
    } else if (method.static && key.type === "Identifier" && key.name === "prototype") this.raise(key.start, "Classes may not have a static property named prototype");
    this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
    if (method.kind === "get" && method.value.params.length !== 0) this.raiseRecoverable(method.value.start, "getter should have no params");
    if (method.kind === "set" && method.value.params.length !== 1) this.raiseRecoverable(method.value.start, "setter should have exactly one param");
    if (method.kind === "set" && method.value.params[0].type === "RestElement") this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params");
    return method;
};
pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
    return this.finishNode(method, "MethodDefinition");
};
pp$1.parseClassId = function(node, isStatement) {
    if (this.type === types.name) {
        node.id = this.parseIdent();
        if (isStatement) this.checkLVal(node.id, BIND_LEXICAL, false);
    } else {
        if (isStatement === true) this.unexpected();
        node.id = null;
    }
};
pp$1.parseClassSuper = function(node) {
    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};
// Parses module export declaration.
pp$1.parseExport = function(node, exports) {
    this.next();
    // export * from '...'
    if (this.eat(types.star)) {
        if (this.options.ecmaVersion >= 11) {
            if (this.eatContextual("as")) {
                node.exported = this.parseIdent(true);
                this.checkExport(exports, node.exported.name, this.lastTokStart);
            } else node.exported = null;
        }
        this.expectContextual("from");
        if (this.type !== types.string) this.unexpected();
        node.source = this.parseExprAtom();
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
    }
    if (this.eat(types._default)) {
        this.checkExport(exports, "default", this.lastTokStart);
        var isAsync;
        if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
            var fNode = this.startNode();
            this.next();
            if (isAsync) this.next();
            node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types._class) {
            var cNode = this.startNode();
            node.declaration = this.parseClass(cNode, "nullableID");
        } else {
            node.declaration = this.parseMaybeAssign();
            this.semicolon();
        }
        return this.finishNode(node, "ExportDefaultDeclaration");
    }
    // export var|const|let|function|class ...
    if (this.shouldParseExportStatement()) {
        node.declaration = this.parseStatement(null);
        if (node.declaration.type === "VariableDeclaration") this.checkVariableExport(exports, node.declaration.declarations);
        else this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);
        node.specifiers = [];
        node.source = null;
    } else {
        node.declaration = null;
        node.specifiers = this.parseExportSpecifiers(exports);
        if (this.eatContextual("from")) {
            if (this.type !== types.string) this.unexpected();
            node.source = this.parseExprAtom();
        } else {
            for(var i = 0, list = node.specifiers; i < list.length; i += 1){
                // check for keywords used as local names
                var spec = list[i];
                this.checkUnreserved(spec.local);
                // check if export is defined
                this.checkLocalExport(spec.local);
            }
            node.source = null;
        }
        this.semicolon();
    }
    return this.finishNode(node, "ExportNamedDeclaration");
};
pp$1.checkExport = function(exports, name, pos) {
    if (!exports) return;
    if (has(exports, name)) this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
    exports[name] = true;
};
pp$1.checkPatternExport = function(exports, pat) {
    var type = pat.type;
    if (type === "Identifier") this.checkExport(exports, pat.name, pat.start);
    else if (type === "ObjectPattern") for(var i = 0, list = pat.properties; i < list.length; i += 1){
        var prop = list[i];
        this.checkPatternExport(exports, prop);
    }
    else if (type === "ArrayPattern") for(var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1){
        var elt = list$1[i$1];
        if (elt) this.checkPatternExport(exports, elt);
    }
    else if (type === "Property") this.checkPatternExport(exports, pat.value);
    else if (type === "AssignmentPattern") this.checkPatternExport(exports, pat.left);
    else if (type === "RestElement") this.checkPatternExport(exports, pat.argument);
    else if (type === "ParenthesizedExpression") this.checkPatternExport(exports, pat.expression);
};
pp$1.checkVariableExport = function(exports, decls) {
    if (!exports) return;
    for(var i = 0, list = decls; i < list.length; i += 1){
        var decl = list[i];
        this.checkPatternExport(exports, decl.id);
    }
};
pp$1.shouldParseExportStatement = function() {
    return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
// Parses a comma-separated list of module exports.
pp$1.parseExportSpecifiers = function(exports) {
    var nodes = [], first = true;
    // export { x, y as z } [from '...']
    this.expect(types.braceL);
    while(!this.eat(types.braceR)){
        if (!first) {
            this.expect(types.comma);
            if (this.afterTrailingComma(types.braceR)) break;
        } else first = false;
        var node = this.startNode();
        node.local = this.parseIdent(true);
        node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
        this.checkExport(exports, node.exported.name, node.exported.start);
        nodes.push(this.finishNode(node, "ExportSpecifier"));
    }
    return nodes;
};
// Parses import declaration.
pp$1.parseImport = function(node) {
    this.next();
    // import '...'
    if (this.type === types.string) {
        node.specifiers = empty;
        node.source = this.parseExprAtom();
    } else {
        node.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
    }
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration");
};
// Parses a comma-separated list of module imports.
pp$1.parseImportSpecifiers = function() {
    var nodes = [], first = true;
    if (this.type === types.name) {
        // import defaultObj, { x, y as z } from '...'
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLVal(node.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
        if (!this.eat(types.comma)) return nodes;
    }
    if (this.type === types.star) {
        var node$1 = this.startNode();
        this.next();
        this.expectContextual("as");
        node$1.local = this.parseIdent();
        this.checkLVal(node$1.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
        return nodes;
    }
    this.expect(types.braceL);
    while(!this.eat(types.braceR)){
        if (!first) {
            this.expect(types.comma);
            if (this.afterTrailingComma(types.braceR)) break;
        } else first = false;
        var node$2 = this.startNode();
        node$2.imported = this.parseIdent(true);
        if (this.eatContextual("as")) node$2.local = this.parseIdent();
        else {
            this.checkUnreserved(node$2.imported);
            node$2.local = node$2.imported;
        }
        this.checkLVal(node$2.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$2, "ImportSpecifier"));
    }
    return nodes;
};
// Set `ExpressionStatement#directive` property for directive prologues.
pp$1.adaptDirectivePrologue = function(statements) {
    for(var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i)statements[i].directive = statements[i].expression.raw.slice(1, -1);
};
pp$1.isDirectiveCandidate = function(statement) {
    return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === "\"" || this.input[statement.start] === "'");
};
var pp$2 = Parser.prototype;
// Convert existing expression atom to assignable pattern
// if possible.
pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node) switch(node.type){
        case "Identifier":
            if (this.inAsync && node.name === "await") this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
            break;
        case "ObjectPattern":
        case "ArrayPattern":
        case "RestElement":
            break;
        case "ObjectExpression":
            node.type = "ObjectPattern";
            if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
            for(var i = 0, list = node.properties; i < list.length; i += 1){
                var prop = list[i];
                this.toAssignable(prop, isBinding);
                // Early error:
                //   AssignmentRestProperty[Yield, Await] :
                //     `...` DestructuringAssignmentTarget[Yield, Await]
                //
                //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
                if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) this.raise(prop.argument.start, "Unexpected token");
            }
            break;
        case "Property":
            // AssignmentProperty has type === "Property"
            if (node.kind !== "init") this.raise(node.key.start, "Object pattern can't contain getter or setter");
            this.toAssignable(node.value, isBinding);
            break;
        case "ArrayExpression":
            node.type = "ArrayPattern";
            if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
            this.toAssignableList(node.elements, isBinding);
            break;
        case "SpreadElement":
            node.type = "RestElement";
            this.toAssignable(node.argument, isBinding);
            if (node.argument.type === "AssignmentPattern") this.raise(node.argument.start, "Rest elements cannot have a default value");
            break;
        case "AssignmentExpression":
            if (node.operator !== "=") this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isBinding);
        // falls through to AssignmentPattern
        case "AssignmentPattern":
            break;
        case "ParenthesizedExpression":
            this.toAssignable(node.expression, isBinding, refDestructuringErrors);
            break;
        case "ChainExpression":
            this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
            break;
        case "MemberExpression":
            if (!isBinding) break;
        default:
            this.raise(node.start, "Assigning to rvalue");
    }
    else if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
    return node;
};
// Convert list of expression atoms to binding list.
pp$2.toAssignableList = function(exprList, isBinding) {
    var end = exprList.length;
    for(var i = 0; i < end; i++){
        var elt = exprList[i];
        if (elt) this.toAssignable(elt, isBinding);
    }
    if (end) {
        var last = exprList[end - 1];
        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
    }
    return exprList;
};
// Parses spread element.
pp$2.parseSpread = function(refDestructuringErrors) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node, "SpreadElement");
};
pp$2.parseRestBinding = function() {
    var node = this.startNode();
    this.next();
    // RestElement inside of a function parameter must be an identifier
    if (this.options.ecmaVersion === 6 && this.type !== types.name) this.unexpected();
    node.argument = this.parseBindingAtom();
    return this.finishNode(node, "RestElement");
};
// Parses lvalue (assignable) atom.
pp$2.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6) switch(this.type){
        case types.bracketL:
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types.bracketR, true, true);
            return this.finishNode(node, "ArrayPattern");
        case types.braceL:
            return this.parseObj(true);
    }
    return this.parseIdent();
};
pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
    var elts = [], first = true;
    while(!this.eat(close)){
        if (first) first = false;
        else this.expect(types.comma);
        if (allowEmpty && this.type === types.comma) elts.push(null);
        else if (allowTrailingComma && this.afterTrailingComma(close)) break;
        else if (this.type === types.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types.comma) this.raise(this.start, "Comma is not permitted after the rest element");
            this.expect(close);
            break;
        } else {
            var elem = this.parseMaybeDefault(this.start, this.startLoc);
            this.parseBindingListItem(elem);
            elts.push(elem);
        }
    }
    return elts;
};
pp$2.parseBindingListItem = function(param) {
    return param;
};
// Parses assignment pattern around given atom if possible.
pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) return left;
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern");
};
// Verify that a node is an lval — something that can be assigned
// to.
// bindingType can be either:
// 'var' indicating that the lval creates a 'var' binding
// 'let' indicating that the lval creates a lexical ('let' or 'const') binding
// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references
pp$2.checkLVal = function(expr, bindingType, checkClashes) {
    if (bindingType === void 0) bindingType = BIND_NONE;
    switch(expr.type){
        case "Identifier":
            if (bindingType === BIND_LEXICAL && expr.name === "let") this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            if (checkClashes) {
                if (has(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
                checkClashes[expr.name] = true;
            }
            if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) this.declareName(expr.name, bindingType, expr.start);
            break;
        case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
        case "MemberExpression":
            if (bindingType) this.raiseRecoverable(expr.start, "Binding member expression");
            break;
        case "ObjectPattern":
            for(var i = 0, list = expr.properties; i < list.length; i += 1){
                var prop = list[i];
                this.checkLVal(prop, bindingType, checkClashes);
            }
            break;
        case "Property":
            // AssignmentProperty has type === "Property"
            this.checkLVal(expr.value, bindingType, checkClashes);
            break;
        case "ArrayPattern":
            for(var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1){
                var elem = list$1[i$1];
                if (elem) this.checkLVal(elem, bindingType, checkClashes);
            }
            break;
        case "AssignmentPattern":
            this.checkLVal(expr.left, bindingType, checkClashes);
            break;
        case "RestElement":
            this.checkLVal(expr.argument, bindingType, checkClashes);
            break;
        case "ParenthesizedExpression":
            this.checkLVal(expr.expression, bindingType, checkClashes);
            break;
        default:
            this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
    }
};
// A recursive descent parser operates by defining functions for all
var pp$3 = Parser.prototype;
// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.
pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") return;
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
    var key = prop.key;
    var name;
    switch(key.type){
        case "Identifier":
            name = key.name;
            break;
        case "Literal":
            name = String(key.value);
            break;
        default:
            return;
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
        if (name === "__proto__" && kind === "init") {
            if (propHash.proto) {
                if (refDestructuringErrors) {
                    if (refDestructuringErrors.doubleProto < 0) refDestructuringErrors.doubleProto = key.start;
                } else this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
            }
            propHash.proto = true;
        }
        return;
    }
    name = "$" + name;
    var other = propHash[name];
    if (other) {
        var redefinition;
        if (kind === "init") redefinition = this.strict && other.init || other.get || other.set;
        else redefinition = other.init || other[kind];
        if (redefinition) this.raiseRecoverable(key.start, "Redefinition of property");
    } else other = propHash[name] = {
        init: false,
        get: false,
        set: false
    };
    other[kind] = true;
};
// ### Expression parsing
// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.
// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).
pp$3.parseExpression = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
    if (this.type === types.comma) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [
            expr
        ];
        while(this.eat(types.comma))node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
        return this.finishNode(node, "SequenceExpression");
    }
    return expr;
};
// Parse an assignment expression. This includes applications of
// operators like `+=`.
pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
        if (this.inGenerator) return this.parseYield(noIn);
        else this.exprAllowed = false;
    }
    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
    if (refDestructuringErrors) {
        oldParenAssign = refDestructuringErrors.parenthesizedAssign;
        oldTrailingComma = refDestructuringErrors.trailingComma;
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
    } else {
        refDestructuringErrors = new DestructuringErrors;
        ownDestructuringErrors = true;
    }
    var startPos = this.start, startLoc = this.startLoc;
    if (this.type === types.parenL || this.type === types.name) this.potentialArrowAt = this.start;
    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
    if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
    if (this.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        node.operator = this.value;
        node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
        if (!ownDestructuringErrors) refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
        if (refDestructuringErrors.shorthandAssign >= node.left.start) refDestructuringErrors.shorthandAssign = -1;
         // reset because shorthand default was used correctly
        this.checkLVal(left);
        this.next();
        node.right = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "AssignmentExpression");
    } else if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
    if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;
    if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;
    return left;
};
// Parse a ternary conditional (`?:`) operator.
pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprOps(noIn, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
    if (this.eat(types.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        this.expect(types.colon);
        node.alternate = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "ConditionalExpression");
    }
    return expr;
};
// Start the precedence parser.
pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false);
    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);
};
// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.
pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
    var prec = this.type.binop;
    if (prec != null && (!noIn || this.type !== types._in)) {
        if (prec > minPrec) {
            var logical = this.type === types.logicalOR || this.type === types.logicalAND;
            var coalesce = this.type === types.coalesce;
            if (coalesce) // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
            // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
            prec = types.logicalAND.binop;
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types.coalesce || coalesce && (this.type === types.logicalOR || this.type === types.logicalAND)) this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
        }
    }
    return left;
};
pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.operator = op;
    node.right = right;
    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
// Parse unary operators, both prefix and postfix.
pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
    var startPos = this.start, startLoc = this.startLoc, expr;
    if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {
        expr = this.parseAwait();
        sawUnary = true;
    } else if (this.type.prefix) {
        var node = this.startNode(), update = this.type === types.incDec;
        node.operator = this.value;
        node.prefix = true;
        this.next();
        node.argument = this.parseMaybeUnary(null, true);
        this.checkExpressionErrors(refDestructuringErrors, true);
        if (update) this.checkLVal(node.argument);
        else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
        else sawUnary = true;
        expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    } else {
        expr = this.parseExprSubscripts(refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
        while(this.type.postfix && !this.canInsertSemicolon()){
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLVal(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
        }
    }
    if (!sawUnary && this.eat(types.starstar)) return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);
    else return expr;
};
// Parse call, dot, and `[]`-subscript expressions.
pp$3.parseExprSubscripts = function(refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors);
    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return expr;
    var result = this.parseSubscripts(expr, startPos, startLoc);
    if (refDestructuringErrors && result.type === "MemberExpression") {
        if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1;
        if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1;
    }
    return result;
};
pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
    var optionalChained = false;
    while(true){
        var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);
        if (element.optional) optionalChained = true;
        if (element === base || element.type === "ArrowFunctionExpression") {
            if (optionalChained) {
                var chainNode = this.startNodeAt(startPos, startLoc);
                chainNode.expression = element;
                element = this.finishNode(chainNode, "ChainExpression");
            }
            return element;
        }
        base = element;
    }
};
pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
    var optionalSupported = this.options.ecmaVersion >= 11;
    var optional = optionalSupported && this.eat(types.questionDot);
    if (noCalls && optional) this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
    var computed = this.eat(types.bracketL);
    if (computed || optional && this.type !== types.parenL && this.type !== types.backQuote || this.eat(types.dot)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.object = base;
        node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
        node.computed = !!computed;
        if (computed) this.expect(types.bracketR);
        if (optionalSupported) node.optional = optional;
        base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(types.parenL)) {
        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
        if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.callee = base;
        node$1.arguments = exprList;
        if (optionalSupported) node$1.optional = optional;
        base = this.finishNode(node$1, "CallExpression");
    } else if (this.type === types.backQuote) {
        if (optional || optionalChained) this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
        var node$2 = this.startNodeAt(startPos, startLoc);
        node$2.tag = base;
        node$2.quasi = this.parseTemplate({
            isTagged: true
        });
        base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base;
};
// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.
pp$3.parseExprAtom = function(refDestructuringErrors) {
    // If a division operator appears in an expression position, the
    // tokenizer got confused, and we force it to read a regexp instead.
    if (this.type === types.slash) this.readRegexp();
    var node, canBeArrow = this.potentialArrowAt === this.start;
    switch(this.type){
        case types._super:
            if (!this.allowSuper) this.raise(this.start, "'super' keyword outside a method");
            node = this.startNode();
            this.next();
            if (this.type === types.parenL && !this.allowDirectSuper) this.raise(node.start, "super() call outside constructor of a subclass");
            // The `super` keyword can appear at below:
            // SuperProperty:
            //     super [ Expression ]
            //     super . IdentifierName
            // SuperCall:
            //     super ( Arguments )
            if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL) this.unexpected();
            return this.finishNode(node, "Super");
        case types._this:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
        case types.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function)) return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true);
            if (canBeArrow && !this.canInsertSemicolon()) {
                if (this.eat(types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [
                    id
                ], false);
                if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
                    id = this.parseIdent(false);
                    if (this.canInsertSemicolon() || !this.eat(types.arrow)) this.unexpected();
                    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [
                        id
                    ], true);
                }
            }
            return id;
        case types.regexp:
            var value = this.value;
            node = this.parseLiteral(value.value);
            node.regex = {
                pattern: value.pattern,
                flags: value.flags
            };
            return node;
        case types.num:
        case types.string:
            return this.parseLiteral(this.value);
        case types._null:
        case types._true:
        case types._false:
            node = this.startNode();
            node.value = this.type === types._null ? null : this.type === types._true;
            node.raw = this.type.keyword;
            this.next();
            return this.finishNode(node, "Literal");
        case types.parenL:
            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
            if (refDestructuringErrors) {
                if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) refDestructuringErrors.parenthesizedAssign = start;
                if (refDestructuringErrors.parenthesizedBind < 0) refDestructuringErrors.parenthesizedBind = start;
            }
            return expr;
        case types.bracketL:
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node, "ArrayExpression");
        case types.braceL:
            return this.parseObj(false, refDestructuringErrors);
        case types._function:
            node = this.startNode();
            this.next();
            return this.parseFunction(node, 0);
        case types._class:
            return this.parseClass(this.startNode(), false);
        case types._new:
            return this.parseNew();
        case types.backQuote:
            return this.parseTemplate();
        case types._import:
            if (this.options.ecmaVersion >= 11) return this.parseExprImport();
            else return this.unexpected();
        default:
            this.unexpected();
    }
};
pp$3.parseExprImport = function() {
    var node = this.startNode();
    // Consume `import` as an identifier for `import.meta`.
    // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
    if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword import");
    var meta = this.parseIdent(true);
    switch(this.type){
        case types.parenL:
            return this.parseDynamicImport(node);
        case types.dot:
            node.meta = meta;
            return this.parseImportMeta(node);
        default:
            this.unexpected();
    }
};
pp$3.parseDynamicImport = function(node) {
    this.next(); // skip `(`
    // Parse node.source.
    node.source = this.parseMaybeAssign();
    // Verify ending.
    if (!this.eat(types.parenR)) {
        var errorPos = this.start;
        if (this.eat(types.comma) && this.eat(types.parenR)) this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
        else this.unexpected(errorPos);
    }
    return this.finishNode(node, "ImportExpression");
};
pp$3.parseImportMeta = function(node) {
    this.next(); // skip `.`
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "meta") this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
    if (containsEsc) this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
    if (this.options.sourceType !== "module") this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
    return this.finishNode(node, "MetaProperty");
};
pp$3.parseLiteral = function(value) {
    var node = this.startNode();
    node.value = value;
    node.raw = this.input.slice(this.start, this.end);
    if (node.raw.charCodeAt(node.raw.length - 1) === 110) node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
    this.next();
    return this.finishNode(node, "Literal");
};
pp$3.parseParenExpression = function() {
    this.expect(types.parenL);
    var val = this.parseExpression();
    this.expect(types.parenR);
    return val;
};
pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
        this.next();
        var innerStartPos = this.start, innerStartLoc = this.startLoc;
        var exprList = [], first = true, lastIsComma = false;
        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
        this.yieldPos = 0;
        this.awaitPos = 0;
        // Do not save awaitIdentPos to allow checking awaits nested in parameters
        while(this.type !== types.parenR){
            first ? first = false : this.expect(types.comma);
            if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
                lastIsComma = true;
                break;
            } else if (this.type === types.ellipsis) {
                spreadStart = this.start;
                exprList.push(this.parseParenItem(this.parseRestBinding()));
                if (this.type === types.comma) this.raise(this.start, "Comma is not permitted after the rest element");
                break;
            } else exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
        }
        var innerEndPos = this.start, innerEndLoc = this.startLoc;
        this.expect(types.parenR);
        if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList);
        }
        if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);
        if (spreadStart) this.unexpected(spreadStart);
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else val = exprList[0];
    } else val = this.parseParenExpression();
    if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression");
    } else return val;
};
pp$3.parseParenItem = function(item) {
    return item;
};
pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
};
// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.
var empty$1 = [];
pp$3.parseNew = function() {
    if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword new");
    var node = this.startNode();
    var meta = this.parseIdent(true);
    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
        node.meta = meta;
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
        if (containsEsc) this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
        if (!this.inNonArrowFunction()) this.raiseRecoverable(node.start, "'new.target' can only be used in functions");
        return this.finishNode(node, "MetaProperty");
    }
    var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    if (isImport && node.callee.type === "ImportExpression") this.raise(startPos, "Cannot use new with import()");
    if (this.eat(types.parenL)) node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false);
    else node.arguments = empty$1;
    return this.finishNode(node, "NewExpression");
};
// Parse template expression.
pp$3.parseTemplateElement = function(ref) {
    var isTagged = ref.isTagged;
    var elem = this.startNode();
    if (this.type === types.invalidTemplate) {
        if (!isTagged) this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
        elem.value = {
            raw: this.value,
            cooked: null
        };
    } else elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
    };
    this.next();
    elem.tail = this.type === types.backQuote;
    return this.finishNode(elem, "TemplateElement");
};
pp$3.parseTemplate = function(ref) {
    if (ref === void 0) ref = {
    };
    var isTagged = ref.isTagged;
    if (isTagged === void 0) isTagged = false;
    var node = this.startNode();
    this.next();
    node.expressions = [];
    var curElt = this.parseTemplateElement({
        isTagged: isTagged
    });
    node.quasis = [
        curElt
    ];
    while(!curElt.tail){
        if (this.type === types.eof) this.raise(this.pos, "Unterminated template literal");
        this.expect(types.dollarBraceL);
        node.expressions.push(this.parseExpression());
        this.expect(types.braceR);
        node.quasis.push(curElt = this.parseTemplateElement({
            isTagged: isTagged
        }));
    }
    this.next();
    return this.finishNode(node, "TemplateLiteral");
};
pp$3.isAsyncProp = function(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
// Parse an object literal or binding pattern.
pp$3.parseObj = function(isPattern, refDestructuringErrors) {
    var node = this.startNode(), first = true, propHash = {
    };
    node.properties = [];
    this.next();
    while(!this.eat(types.braceR)){
        if (!first) {
            this.expect(types.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) break;
        } else first = false;
        var prop = this.parseProperty(isPattern, refDestructuringErrors);
        if (!isPattern) this.checkPropClash(prop, propHash, refDestructuringErrors);
        node.properties.push(prop);
    }
    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
        if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types.comma) this.raise(this.start, "Comma is not permitted after the rest element");
            return this.finishNode(prop, "RestElement");
        }
        // To disallow parenthesized identifier via `this.toAssignable()`.
        if (this.type === types.parenL && refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0) refDestructuringErrors.parenthesizedAssign = this.start;
            if (refDestructuringErrors.parenthesizedBind < 0) refDestructuringErrors.parenthesizedBind = this.start;
        }
        // Parse argument.
        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        // To disallow trailing comma via `this.toAssignable()`.
        if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
        // Finish
        return this.finishNode(prop, "SpreadElement");
    }
    if (this.options.ecmaVersion >= 6) {
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
        }
        if (!isPattern) isGenerator = this.eat(types.star);
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
        this.parsePropertyName(prop, refDestructuringErrors);
    } else isAsync = false;
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property");
};
pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types.colon) this.unexpected();
    if (this.eat(types.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
        prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
        if (isPattern) this.unexpected();
        prop.kind = "init";
        prop.method = true;
        prop.value = this.parseMethod(isGenerator, isAsync);
    } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq) {
        if (isGenerator || isAsync) this.unexpected();
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
            var start = prop.value.start;
            if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");
            else this.raiseRecoverable(start, "setter should have exactly one param");
        } else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        if (isGenerator || isAsync) this.unexpected();
        this.checkUnreserved(prop.key);
        if (prop.key.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = startPos;
        prop.kind = "init";
        if (isPattern) prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        else if (this.type === types.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) refDestructuringErrors.shorthandAssign = this.start;
            prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        } else prop.value = prop.key;
        prop.shorthand = true;
    } else this.unexpected();
};
pp$3.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
        if (this.eat(types.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types.bracketR);
            return prop.key;
        } else prop.computed = false;
    }
    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
// Initialize empty function node.
pp$3.initFunction = function(node) {
    node.id = null;
    if (this.options.ecmaVersion >= 6) node.generator = node.expression = false;
    if (this.options.ecmaVersion >= 8) node.async = false;
};
// Parse object or class method.
pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.initFunction(node);
    if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
    if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node, false, true);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "FunctionExpression");
};
// Parse arrow function expression with given parameters.
pp$3.parseArrowExpression = function(node, params, isAsync) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node);
    if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    node.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node, true, false);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "ArrowFunctionExpression");
};
// Parse function body and check parameters.
pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
    var isExpression = isArrowFunction && this.type !== types.braceL;
    var oldStrict = this.strict, useStrict = false;
    if (isExpression) {
        node.body = this.parseMaybeAssign();
        node.expression = true;
        this.checkParams(node, false);
    } else {
        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
        if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            // If this is a strict mode function, verify that argument names
            // are not repeated, and it does not try to bind the words `eval`
            // or `arguments`.
            if (useStrict && nonSimple) this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
        }
        // Start a new scope with regard to labels and the `inFunction`
        // flag (restore them to their old value afterwards).
        var oldLabels = this.labels;
        this.labels = [];
        if (useStrict) this.strict = true;
        // Add the params to varDeclaredNames to ensure that an error is thrown
        // if a let/const declaration in the function clashes with one of the params.
        this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
        // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
        if (this.strict && node.id) this.checkLVal(node.id, BIND_OUTSIDE);
        node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
        node.expression = false;
        this.adaptDirectivePrologue(node.body.body);
        this.labels = oldLabels;
    }
    this.exitScope();
};
pp$3.isSimpleParamList = function(params) {
    for(var i = 0, list = params; i < list.length; i += 1){
        var param = list[i];
        if (param.type !== "Identifier") return false;
    }
    return true;
};
// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.
pp$3.checkParams = function(node, allowDuplicates) {
    var nameHash = {
    };
    for(var i = 0, list = node.params; i < list.length; i += 1){
        var param = list[i];
        this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
};
// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).
pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [], first = true;
    while(!this.eat(close)){
        if (!first) {
            this.expect(types.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) break;
        } else first = false;
        var elt = void 0;
        if (allowEmpty && this.type === types.comma) elt = null;
        else if (this.type === types.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
        } else elt = this.parseMaybeAssign(false, refDestructuringErrors);
        elts.push(elt);
    }
    return elts;
};
pp$3.checkUnreserved = function(ref) {
    var start = ref.start;
    var end = ref.end;
    var name = ref.name;
    if (this.inGenerator && name === "yield") this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
    if (this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
    if (this.keywords.test(name)) this.raise(start, "Unexpected keyword '" + name + "'");
    if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) return;
    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re.test(name)) {
        if (!this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
        this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
    }
};
// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.
pp$3.parseIdent = function(liberal, isBinding) {
    var node = this.startNode();
    if (this.type === types.name) node.name = this.value;
    else if (this.type.keyword) {
        node.name = this.type.keyword;
        // To fix https://github.com/acornjs/acorn/issues/575
        // `class` and `function` keywords push new context into this.context.
        // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
        // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
        if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) this.context.pop();
    } else this.unexpected();
    this.next(!!liberal);
    this.finishNode(node, "Identifier");
    if (!liberal) {
        this.checkUnreserved(node);
        if (node.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = node.start;
    }
    return node;
};
// Parses yield expression inside generator.
pp$3.parseYield = function(noIn) {
    if (!this.yieldPos) this.yieldPos = this.start;
    var node = this.startNode();
    this.next();
    if (this.type === types.semi || this.canInsertSemicolon() || this.type !== types.star && !this.type.startsExpr) {
        node.delegate = false;
        node.argument = null;
    } else {
        node.delegate = this.eat(types.star);
        node.argument = this.parseMaybeAssign(noIn);
    }
    return this.finishNode(node, "YieldExpression");
};
pp$3.parseAwait = function() {
    if (!this.awaitPos) this.awaitPos = this.start;
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(null, false);
    return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.
pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos;
    err.loc = loc;
    err.raisedAt = this.pos;
    throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
    if (this.options.locations) return new Position(this.curLine, this.pos - this.lineStart);
};
var pp$5 = Parser.prototype;
var Scope = function Scope(flags) {
    this.flags = flags;
    // A list of var-declared names in the current lexical scope
    this.var = [];
    // A list of lexically-declared names in the current lexical scope
    this.lexical = [];
    // A list of lexically-declared FunctionDeclaration names in the current lexical scope
    this.functions = [];
};
// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.
pp$5.enterScope = function(flags) {
    this.scopeStack.push(new Scope(flags));
};
pp$5.exitScope = function() {
    this.scopeStack.pop();
};
// The spec says:
// > At the top level of a function, or script, function declarations are
// > treated like var declarations rather than like lexical declarations.
pp$5.treatFunctionsAsVarInScope = function(scope) {
    return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$5.declareName = function(name, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
        var scope = this.currentScope();
        redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
        scope.lexical.push(name);
        if (this.inModule && scope.flags & SCOPE_TOP) delete this.undefinedExports[name];
    } else if (bindingType === BIND_SIMPLE_CATCH) {
        var scope$1 = this.currentScope();
        scope$1.lexical.push(name);
    } else if (bindingType === BIND_FUNCTION) {
        var scope$2 = this.currentScope();
        if (this.treatFunctionsAsVar) redeclared = scope$2.lexical.indexOf(name) > -1;
        else redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
        scope$2.functions.push(name);
    } else for(var i = this.scopeStack.length - 1; i >= 0; --i){
        var scope$3 = this.scopeStack[i];
        if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
            redeclared = true;
            break;
        }
        scope$3.var.push(name);
        if (this.inModule && scope$3.flags & SCOPE_TOP) delete this.undefinedExports[name];
        if (scope$3.flags & SCOPE_VAR) break;
    }
    if (redeclared) this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
};
pp$5.checkLocalExport = function(id) {
    // scope.functions must be empty as Module code is always strict.
    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) this.undefinedExports[id.name] = id;
};
pp$5.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1];
};
pp$5.currentVarScope = function() {
    for(var i = this.scopeStack.length - 1;; i--){
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR) return scope;
    }
};
// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
pp$5.currentThisScope = function() {
    for(var i = this.scopeStack.length - 1;; i--){
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) return scope;
    }
};
var Node = function Node(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    if (parser.options.locations) this.loc = new SourceLocation(parser, loc);
    if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
    if (parser.options.ranges) this.range = [
        pos,
        0
    ];
};
// Start an AST node, attaching a start offset.
var pp$6 = Parser.prototype;
pp$6.startNode = function() {
    return new Node(this, this.start, this.startLoc);
};
pp$6.startNodeAt = function(pos, loc) {
    return new Node(this, pos, loc);
};
// Finish an AST node, adding `type` and `end` properties.
function finishNodeAt(node, type, pos, loc) {
    node.type = type;
    node.end = pos;
    if (this.options.locations) node.loc.end = loc;
    if (this.options.ranges) node.range[1] = pos;
    return node;
}
pp$6.finishNode = function(node, type) {
    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
// Finish node at given position
pp$6.finishNodeAt = function(node, type, pos, loc) {
    return finishNodeAt.call(this, node, type, pos, loc);
};
// The algorithm used to determine whether a regexp can appear at a
var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
};
var types$1 = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function(p) {
        return p.tryReadTemplateToken();
    }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
};
var pp$7 = Parser.prototype;
pp$7.initialContext = function() {
    return [
        types$1.b_stat
    ];
};
pp$7.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    if (parent === types$1.f_expr || parent === types$1.f_stat) return true;
    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) return !parent.isExpr;
    // The check for `tt.name && exprAllowed` detects whether we are
    // after a `yield` or `of` construct. See the `updateContext` for
    // `tt.name`.
    if (prevType === types._return || prevType === types.name && this.exprAllowed) return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) return true;
    if (prevType === types.braceL) return parent === types$1.b_stat;
    if (prevType === types._var || prevType === types._const || prevType === types.name) return false;
    return !this.exprAllowed;
};
pp$7.inGeneratorContext = function() {
    for(var i = this.context.length - 1; i >= 1; i--){
        var context = this.context[i];
        if (context.token === "function") return context.generator;
    }
    return false;
};
pp$7.updateContext = function(prevType) {
    var update, type = this.type;
    if (type.keyword && prevType === types.dot) this.exprAllowed = false;
    else if (update = type.updateContext) update.call(this, prevType);
    else this.exprAllowed = type.beforeExpr;
};
// Token-specific context update code
types.parenR.updateContext = types.braceR.updateContext = function() {
    if (this.context.length === 1) {
        this.exprAllowed = true;
        return;
    }
    var out = this.context.pop();
    if (out === types$1.b_stat && this.curContext().token === "function") out = this.context.pop();
    this.exprAllowed = !out.isExpr;
};
types.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
    this.exprAllowed = true;
};
types.dollarBraceL.updateContext = function() {
    this.context.push(types$1.b_tmpl);
    this.exprAllowed = true;
};
types.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
    this.exprAllowed = true;
};
types.incDec.updateContext = function() {
// tokExprAllowed stays unchanged
};
types._function.updateContext = types._class.updateContext = function(prevType) {
    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) this.context.push(types$1.f_expr);
    else this.context.push(types$1.f_stat);
    this.exprAllowed = false;
};
types.backQuote.updateContext = function() {
    if (this.curContext() === types$1.q_tmpl) this.context.pop();
    else this.context.push(types$1.q_tmpl);
    this.exprAllowed = false;
};
types.star.updateContext = function(prevType) {
    if (prevType === types._function) {
        var index = this.context.length - 1;
        if (this.context[index] === types$1.f_expr) this.context[index] = types$1.f_expr_gen;
        else this.context[index] = types$1.f_gen;
    }
    this.exprAllowed = true;
};
types.name.updateContext = function(prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
        if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) allowed = true;
    }
    this.exprAllowed = allowed;
};
// This file contains Unicode properties extracted from the ECMAScript
// specification. The lists are extracted like so:
// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)
// #table-binary-unicode-properties
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: ecma11BinaryProperties
};
// #table-unicode-general-category-values
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
// #table-unicode-script-values
var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: ecma11ScriptValues
};
var data = {
};
function buildUnicodeData(ecmaVersion) {
    var d = data[ecmaVersion] = {
        binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
        nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
        }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script;
    d.nonBinary.gc = d.nonBinary.General_Category;
    d.nonBinary.sc = d.nonBinary.Script;
    d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
buildUnicodeData(9);
buildUnicodeData(10);
buildUnicodeData(11);
var pp$8 = Parser.prototype;
var RegExpValidationState = function RegExpValidationState(parser) {
    this.parser = parser;
    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = false;
    this.switchN = false;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = false;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = [];
    this.backReferenceNames = [];
};
RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
    var unicode = flags.indexOf("u") !== -1;
    this.start = start | 0;
    this.source = pattern + "";
    this.flags = flags;
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};
RegExpValidationState.prototype.raise = function raise(message) {
    this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
RegExpValidationState.prototype.at = function at(i, forceU) {
    if (forceU === void 0) forceU = false;
    var s = this.source;
    var l = s.length;
    if (i >= l) return -1;
    var c = s.charCodeAt(i);
    if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) return c;
    var next = s.charCodeAt(i + 1);
    return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
    if (forceU === void 0) forceU = false;
    var s = this.source;
    var l = s.length;
    if (i >= l) return l;
    var c = s.charCodeAt(i), next;
    if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) return i + 1;
    return i + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
    if (forceU === void 0) forceU = false;
    return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
    if (forceU === void 0) forceU = false;
    return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
    if (forceU === void 0) forceU = false;
    this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
    if (forceU === void 0) forceU = false;
    if (this.current(forceU) === ch) {
        this.advance(forceU);
        return true;
    }
    return false;
};
function codePointToString(ch) {
    if (ch <= 65535) return String.fromCharCode(ch);
    ch -= 65536;
    return String.fromCharCode((ch >> 10) + 55296, (ch & 1023) + 56320);
}
/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */ pp$8.validateRegExpFlags = function(state) {
    var validFlags = state.validFlags;
    var flags = state.flags;
    for(var i = 0; i < flags.length; i++){
        var flag = flags.charAt(i);
        if (validFlags.indexOf(flag) === -1) this.raise(state.start, "Invalid regular expression flag");
        if (flags.indexOf(flag, i + 1) > -1) this.raise(state.start, "Duplicate regular expression flag");
    }
};
/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */ pp$8.validateRegExpPattern = function(state) {
    this.regexp_pattern(state);
    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
    // parsing contains a |GroupName|, reparse with the goal symbol
    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
    // exception if _P_ did not conform to the grammar, if any elements of _P_
    // were not matched by the parse, or if any Early Error conditions exist.
    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
        state.switchN = true;
        this.regexp_pattern(state);
    }
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
pp$8.regexp_pattern = function(state) {
    state.pos = 0;
    state.lastIntValue = 0;
    state.lastStringValue = "";
    state.lastAssertionIsQuantifiable = false;
    state.numCapturingParens = 0;
    state.maxBackReference = 0;
    state.groupNames.length = 0;
    state.backReferenceNames.length = 0;
    this.regexp_disjunction(state);
    if (state.pos !== state.source.length) {
        // Make the same messages as V8.
        if (state.eat(41 /* ) */ )) state.raise("Unmatched ')'");
        if (state.eat(93 /* ] */ ) || state.eat(125 /* } */ )) state.raise("Lone quantifier brackets");
    }
    if (state.maxBackReference > state.numCapturingParens) state.raise("Invalid escape");
    for(var i = 0, list = state.backReferenceNames; i < list.length; i += 1){
        var name = list[i];
        if (state.groupNames.indexOf(name) === -1) state.raise("Invalid named capture referenced");
    }
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
pp$8.regexp_disjunction = function(state) {
    this.regexp_alternative(state);
    while(state.eat(124 /* | */ ))this.regexp_alternative(state);
    // Make the same message as V8.
    if (this.regexp_eatQuantifier(state, true)) state.raise("Nothing to repeat");
    if (state.eat(123 /* { */ )) state.raise("Lone quantifier brackets");
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$8.regexp_alternative = function(state) {
    while(state.pos < state.source.length && this.regexp_eatTerm(state));
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$8.regexp_eatTerm = function(state) {
    if (this.regexp_eatAssertion(state)) {
        // Handle `QuantifiableAssertion Quantifier` alternative.
        // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
        // is a QuantifiableAssertion.
        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) // Make the same message as V8.
        {
            if (state.switchU) state.raise("Invalid quantifier");
        }
        return true;
    }
    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
        this.regexp_eatQuantifier(state);
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
pp$8.regexp_eatAssertion = function(state) {
    var start = state.pos;
    state.lastAssertionIsQuantifiable = false;
    // ^, $
    if (state.eat(94 /* ^ */ ) || state.eat(36 /* $ */ )) return true;
    // \b \B
    if (state.eat(92 /* \ */ )) {
        if (state.eat(66 /* B */ ) || state.eat(98 /* b */ )) return true;
        state.pos = start;
    }
    // Lookahead / Lookbehind
    if (state.eat(40 /* ( */ ) && state.eat(63 /* ? */ )) {
        var lookbehind = false;
        if (this.options.ecmaVersion >= 9) lookbehind = state.eat(60 /* < */ );
        if (state.eat(61 /* = */ ) || state.eat(33 /* ! */ )) {
            this.regexp_disjunction(state);
            if (!state.eat(41 /* ) */ )) state.raise("Unterminated group");
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
        }
    }
    state.pos = start;
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$8.regexp_eatQuantifier = function(state, noError) {
    if (noError === void 0) noError = false;
    if (this.regexp_eatQuantifierPrefix(state, noError)) {
        state.eat(63 /* ? */ );
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
    return state.eat(42 /* * */ ) || state.eat(43 /* + */ ) || state.eat(63 /* ? */ ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$8.regexp_eatBracedQuantifier = function(state, noError) {
    var start = state.pos;
    if (state.eat(123 /* { */ )) {
        var min = 0, max = -1;
        if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(44 /* , */ ) && this.regexp_eatDecimalDigits(state)) max = state.lastIntValue;
            if (state.eat(125 /* } */ )) {
                // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
                if (max !== -1 && max < min && !noError) state.raise("numbers out of order in {} quantifier");
                return true;
            }
        }
        if (state.switchU && !noError) state.raise("Incomplete quantifier");
        state.pos = start;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
    return this.regexp_eatPatternCharacters(state) || state.eat(46 /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
    var start = state.pos;
    if (state.eat(92 /* \ */ )) {
        if (this.regexp_eatAtomEscape(state)) return true;
        state.pos = start;
    }
    return false;
};
pp$8.regexp_eatUncapturingGroup = function(state) {
    var start = state.pos;
    if (state.eat(40 /* ( */ )) {
        if (state.eat(63 /* ? */ ) && state.eat(58 /* : */ )) {
            this.regexp_disjunction(state);
            if (state.eat(41 /* ) */ )) return true;
            state.raise("Unterminated group");
        }
        state.pos = start;
    }
    return false;
};
pp$8.regexp_eatCapturingGroup = function(state) {
    if (state.eat(40 /* ( */ )) {
        if (this.options.ecmaVersion >= 9) this.regexp_groupSpecifier(state);
        else if (state.current() === 63 /* ? */ ) state.raise("Invalid group");
        this.regexp_disjunction(state);
        if (state.eat(41 /* ) */ )) {
            state.numCapturingParens += 1;
            return true;
        }
        state.raise("Unterminated group");
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
pp$8.regexp_eatExtendedAtom = function(state) {
    return state.eat(46 /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
    if (this.regexp_eatBracedQuantifier(state, true)) state.raise("Nothing to repeat");
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
pp$8.regexp_eatSyntaxCharacter = function(state) {
    var ch = state.current();
    if (isSyntaxCharacter(ch)) {
        state.lastIntValue = ch;
        state.advance();
        return true;
    }
    return false;
};
function isSyntaxCharacter(ch) {
    return ch === 36 /* $ */  || ch >= 40 /* ( */  && ch <= 43 /* + */  || ch === 46 /* . */  || ch === 63 /* ? */  || ch >= 91 /* [ */  && ch <= 94 /* ^ */  || ch >= 123 /* { */  && ch <= 125 /* } */ ;
}
// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.
pp$8.regexp_eatPatternCharacters = function(state) {
    var start = state.pos;
    var ch = 0;
    while((ch = state.current()) !== -1 && !isSyntaxCharacter(ch))state.advance();
    return state.pos !== start;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
pp$8.regexp_eatExtendedPatternCharacter = function(state) {
    var ch = state.current();
    if (ch !== -1 && ch !== 36 /* $ */  && !(ch >= 40 /* ( */  && ch <= 43 /* + */ ) && ch !== 46 /* . */  && ch !== 63 /* ? */  && ch !== 91 /* [ */  && ch !== 94 /* ^ */  && ch !== 124 /* | */ ) {
        state.advance();
        return true;
    }
    return false;
};
// GroupSpecifier ::
//   [empty]
//   `?` GroupName
pp$8.regexp_groupSpecifier = function(state) {
    if (state.eat(63 /* ? */ )) {
        if (this.regexp_eatGroupName(state)) {
            if (state.groupNames.indexOf(state.lastStringValue) !== -1) state.raise("Duplicate capture group name");
            state.groupNames.push(state.lastStringValue);
            return;
        }
        state.raise("Invalid group");
    }
};
// GroupName ::
//   `<` RegExpIdentifierName `>`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatGroupName = function(state) {
    state.lastStringValue = "";
    if (state.eat(60 /* < */ )) {
        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62 /* > */ )) return true;
        state.raise("Invalid capture group name");
    }
    return false;
};
// RegExpIdentifierName ::
//   RegExpIdentifierStart
//   RegExpIdentifierName RegExpIdentifierPart
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatRegExpIdentifierName = function(state) {
    state.lastStringValue = "";
    if (this.regexp_eatRegExpIdentifierStart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
        while(this.regexp_eatRegExpIdentifierPart(state))state.lastStringValue += codePointToString(state.lastIntValue);
        return true;
    }
    return false;
};
// RegExpIdentifierStart ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[+U]
pp$8.regexp_eatRegExpIdentifierStart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);
    if (ch === 92 /* \ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
    if (isRegExpIdentifierStart(ch)) {
        state.lastIntValue = ch;
        return true;
    }
    state.pos = start;
    return false;
};
function isRegExpIdentifierStart(ch) {
    return isIdentifierStart(ch, true) || ch === 36 /* $ */  || ch === 95 /* _ */ ;
}
// RegExpIdentifierPart ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[+U]
//   <ZWNJ>
//   <ZWJ>
pp$8.regexp_eatRegExpIdentifierPart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);
    if (ch === 92 /* \ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
    if (isRegExpIdentifierPart(ch)) {
        state.lastIntValue = ch;
        return true;
    }
    state.pos = start;
    return false;
};
function isRegExpIdentifierPart(ch) {
    return isIdentifierChar(ch, true) || ch === 36 /* $ */  || ch === 95 /* _ */  || ch === 8204 /* <ZWNJ> */  || ch === 8205 /* <ZWJ> */ ;
}
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
    if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) return true;
    if (state.switchU) {
        // Make the same message as V8.
        if (state.current() === 99 /* c */ ) state.raise("Invalid unicode escape");
        state.raise("Invalid escape");
    }
    return false;
};
pp$8.regexp_eatBackReference = function(state) {
    var start = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
        var n = state.lastIntValue;
        if (state.switchU) {
            // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
            if (n > state.maxBackReference) state.maxBackReference = n;
            return true;
        }
        if (n <= state.numCapturingParens) return true;
        state.pos = start;
    }
    return false;
};
pp$8.regexp_eatKGroupName = function(state) {
    if (state.eat(107 /* k */ )) {
        if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
        }
        state.raise("Invalid named reference");
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
    return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$8.regexp_eatCControlLetter = function(state) {
    var start = state.pos;
    if (state.eat(99 /* c */ )) {
        if (this.regexp_eatControlLetter(state)) return true;
        state.pos = start;
    }
    return false;
};
pp$8.regexp_eatZero = function(state) {
    if (state.current() === 48 /* 0 */  && !isDecimalDigit(state.lookahead())) {
        state.lastIntValue = 0;
        state.advance();
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
pp$8.regexp_eatControlEscape = function(state) {
    var ch = state.current();
    if (ch === 116 /* t */ ) {
        state.lastIntValue = 9; /* \t */ 
        state.advance();
        return true;
    }
    if (ch === 110 /* n */ ) {
        state.lastIntValue = 10; /* \n */ 
        state.advance();
        return true;
    }
    if (ch === 118 /* v */ ) {
        state.lastIntValue = 11; /* \v */ 
        state.advance();
        return true;
    }
    if (ch === 102 /* f */ ) {
        state.lastIntValue = 12; /* \f */ 
        state.advance();
        return true;
    }
    if (ch === 114 /* r */ ) {
        state.lastIntValue = 13; /* \r */ 
        state.advance();
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
pp$8.regexp_eatControlLetter = function(state) {
    var ch = state.current();
    if (isControlLetter(ch)) {
        state.lastIntValue = ch % 32;
        state.advance();
        return true;
    }
    return false;
};
function isControlLetter(ch) {
    return ch >= 65 /* A */  && ch <= 90 /* Z */  || ch >= 97 /* a */  && ch <= 122 /* z */ ;
}
// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
    if (forceU === void 0) forceU = false;
    var start = state.pos;
    var switchU = forceU || state.switchU;
    if (state.eat(117 /* u */ )) {
        if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
                var leadSurrogateEnd = state.pos;
                if (state.eat(92 /* \ */ ) && state.eat(117 /* u */ ) && this.regexp_eatFixedHexDigits(state, 4)) {
                    var trail = state.lastIntValue;
                    if (trail >= 56320 && trail <= 57343) {
                        state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                        return true;
                    }
                }
                state.pos = leadSurrogateEnd;
                state.lastIntValue = lead;
            }
            return true;
        }
        if (switchU && state.eat(123 /* { */ ) && this.regexp_eatHexDigits(state) && state.eat(125 /* } */ ) && isValidUnicode(state.lastIntValue)) return true;
        if (switchU) state.raise("Invalid unicode escape");
        state.pos = start;
    }
    return false;
};
function isValidUnicode(ch) {
    return ch >= 0 && ch <= 1114111;
}
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$8.regexp_eatIdentityEscape = function(state) {
    if (state.switchU) {
        if (this.regexp_eatSyntaxCharacter(state)) return true;
        if (state.eat(47 /* / */ )) {
            state.lastIntValue = 47; /* / */ 
            return true;
        }
        return false;
    }
    var ch = state.current();
    if (ch !== 99 /* c */  && (!state.switchN || ch !== 107 /* k */ )) {
        state.lastIntValue = ch;
        state.advance();
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
pp$8.regexp_eatDecimalEscape = function(state) {
    state.lastIntValue = 0;
    var ch = state.current();
    if (ch >= 49 /* 1 */  && ch <= 57 /* 9 */ ) {
        do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48 /* 0 */ );
            state.advance();
        }while ((ch = state.current()) >= 48 /* 0 */  && ch <= 57 /* 9 */ )
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
pp$8.regexp_eatCharacterClassEscape = function(state) {
    var ch = state.current();
    if (isCharacterClassEscape(ch)) {
        state.lastIntValue = -1;
        state.advance();
        return true;
    }
    if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 /* P */  || ch === 112 /* p */ )) {
        state.lastIntValue = -1;
        state.advance();
        if (state.eat(123 /* { */ ) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125 /* } */ )) return true;
        state.raise("Invalid property name");
    }
    return false;
};
function isCharacterClassEscape(ch) {
    return ch === 100 /* d */  || ch === 68 /* D */  || ch === 115 /* s */  || ch === 83 /* S */  || ch === 119 /* w */  || ch === 87 /* W */ ;
}
// UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue
pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
    var start = state.pos;
    // UnicodePropertyName `=` UnicodePropertyValue
    if (this.regexp_eatUnicodePropertyName(state) && state.eat(61 /* = */ )) {
        var name = state.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(state)) {
            var value = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
            return true;
        }
    }
    state.pos = start;
    // LoneUnicodePropertyNameOrValue
    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
        var nameOrValue = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        return true;
    }
    return false;
};
pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
    if (!has(state.unicodeProperties.nonBinary, name)) state.raise("Invalid property name");
    if (!state.unicodeProperties.nonBinary[name].test(value)) state.raise("Invalid property value");
};
pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
    if (!state.unicodeProperties.binary.test(nameOrValue)) state.raise("Invalid property name");
};
// UnicodePropertyName ::
//   UnicodePropertyNameCharacters
pp$8.regexp_eatUnicodePropertyName = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while(isUnicodePropertyNameCharacter(ch = state.current())){
        state.lastStringValue += codePointToString(ch);
        state.advance();
    }
    return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
    return isControlLetter(ch) || ch === 95 /* _ */ ;
}
// UnicodePropertyValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatUnicodePropertyValue = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while(isUnicodePropertyValueCharacter(ch = state.current())){
        state.lastStringValue += codePointToString(ch);
        state.advance();
    }
    return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
// LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
    return this.regexp_eatUnicodePropertyValue(state);
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$8.regexp_eatCharacterClass = function(state) {
    if (state.eat(91 /* [ */ )) {
        state.eat(94 /* ^ */ );
        this.regexp_classRanges(state);
        if (state.eat(93 /* ] */ )) return true;
        // Unreachable since it threw "unterminated regular expression" error before.
        state.raise("Unterminated character class");
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$8.regexp_classRanges = function(state) {
    while(this.regexp_eatClassAtom(state)){
        var left = state.lastIntValue;
        if (state.eat(45 /* - */ ) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) state.raise("Invalid character class");
            if (left !== -1 && right !== -1 && left > right) state.raise("Range out of order in character class");
        }
    }
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
pp$8.regexp_eatClassAtom = function(state) {
    var start = state.pos;
    if (state.eat(92 /* \ */ )) {
        if (this.regexp_eatClassEscape(state)) return true;
        if (state.switchU) {
            // Make the same message as V8.
            var ch$1 = state.current();
            if (ch$1 === 99 /* c */  || isOctalDigit(ch$1)) state.raise("Invalid class escape");
            state.raise("Invalid escape");
        }
        state.pos = start;
    }
    var ch = state.current();
    if (ch !== 93 /* ] */ ) {
        state.lastIntValue = ch;
        state.advance();
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
pp$8.regexp_eatClassEscape = function(state) {
    var start = state.pos;
    if (state.eat(98 /* b */ )) {
        state.lastIntValue = 8; /* <BS> */ 
        return true;
    }
    if (state.switchU && state.eat(45 /* - */ )) {
        state.lastIntValue = 45; /* - */ 
        return true;
    }
    if (!state.switchU && state.eat(99 /* c */ )) {
        if (this.regexp_eatClassControlLetter(state)) return true;
        state.pos = start;
    }
    return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
pp$8.regexp_eatClassControlLetter = function(state) {
    var ch = state.current();
    if (isDecimalDigit(ch) || ch === 95 /* _ */ ) {
        state.lastIntValue = ch % 32;
        state.advance();
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatHexEscapeSequence = function(state) {
    var start = state.pos;
    if (state.eat(120 /* x */ )) {
        if (this.regexp_eatFixedHexDigits(state, 2)) return true;
        if (state.switchU) state.raise("Invalid escape");
        state.pos = start;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
pp$8.regexp_eatDecimalDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while(isDecimalDigit(ch = state.current())){
        state.lastIntValue = 10 * state.lastIntValue + (ch - 48 /* 0 */ );
        state.advance();
    }
    return state.pos !== start;
};
function isDecimalDigit(ch) {
    return ch >= 48 /* 0 */  && ch <= 57 /* 9 */ ;
}
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
pp$8.regexp_eatHexDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while(isHexDigit(ch = state.current())){
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
    }
    return state.pos !== start;
};
function isHexDigit(ch) {
    return ch >= 48 /* 0 */  && ch <= 57 /* 9 */  || ch >= 65 /* A */  && ch <= 70 /* F */  || ch >= 97 /* a */  && ch <= 102 /* f */ ;
}
function hexToInt(ch) {
    if (ch >= 65 /* A */  && ch <= 70 /* F */ ) return 10 + (ch - 65 /* A */ );
    if (ch >= 97 /* a */  && ch <= 102 /* f */ ) return 10 + (ch - 97 /* a */ );
    return ch - 48 /* 0 */ ;
}
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
    if (this.regexp_eatOctalDigit(state)) {
        var n1 = state.lastIntValue;
        if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            else state.lastIntValue = n1 * 8 + n2;
        } else state.lastIntValue = n1;
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
pp$8.regexp_eatOctalDigit = function(state) {
    var ch = state.current();
    if (isOctalDigit(ch)) {
        state.lastIntValue = ch - 48; /* 0 */ 
        state.advance();
        return true;
    }
    state.lastIntValue = 0;
    return false;
};
function isOctalDigit(ch) {
    return ch >= 48 /* 0 */  && ch <= 55 /* 7 */ ;
}
// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatFixedHexDigits = function(state, length) {
    var start = state.pos;
    state.lastIntValue = 0;
    for(var i = 0; i < length; ++i){
        var ch = state.current();
        if (!isHexDigit(ch)) {
            state.pos = start;
            return false;
        }
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
    }
    return true;
};
// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.
var Token = function Token(p) {
    this.type = p.type;
    this.value = p.value;
    this.start = p.start;
    this.end = p.end;
    if (p.options.locations) this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
    if (p.options.ranges) this.range = [
        p.start,
        p.end
    ];
};
// ## Tokenizer
var pp$9 = Parser.prototype;
// Move to the next token
pp$9.next = function(ignoreEscapeSequenceInKeyword) {
    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
    if (this.options.onToken) this.options.onToken(new Token(this));
    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
};
pp$9.getToken = function() {
    this.next();
    return new Token(this);
};
// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined") pp$9[Symbol.iterator] = function() {
    var this$1 = this;
    return {
        next: function() {
            var token = this$1.getToken();
            return {
                done: token.type === types.eof,
                value: token
            };
        }
    };
};
// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).
pp$9.curContext = function() {
    return this.context[this.context.length - 1];
};
// Read a single token, updating the parser object's token-related
// properties.
pp$9.nextToken = function() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) this.skipSpace();
    this.start = this.pos;
    if (this.options.locations) this.startLoc = this.curPosition();
    if (this.pos >= this.input.length) return this.finishToken(types.eof);
    if (curContext.override) return curContext.override(this);
    else this.readToken(this.fullCharCodeAtPos());
};
pp$9.readToken = function(code) {
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */ ) return this.readWord();
    return this.getTokenFromCode(code);
};
pp$9.fullCharCodeAtPos = function() {
    var code = this.input.charCodeAt(this.pos);
    if (code <= 55295 || code >= 57344) return code;
    var next = this.input.charCodeAt(this.pos + 1);
    return (code << 10) + next - 56613888;
};
pp$9.skipBlockComment = function() {
    var startLoc = this.options.onComment && this.curPosition();
    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
    if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
    this.pos = end + 2;
    if (this.options.locations) {
        lineBreakG.lastIndex = start;
        var match;
        while((match = lineBreakG.exec(this.input)) && match.index < this.pos){
            ++this.curLine;
            this.lineStart = match.index + match[0].length;
        }
    }
    if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
};
pp$9.skipLineComment = function(startSkip) {
    var start = this.pos;
    var startLoc = this.options.onComment && this.curPosition();
    var ch = this.input.charCodeAt(this.pos += startSkip);
    while(this.pos < this.input.length && !isNewLine(ch))ch = this.input.charCodeAt(++this.pos);
    if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
};
// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.
pp$9.skipSpace = function() {
    loop: while(this.pos < this.input.length){
        var ch = this.input.charCodeAt(this.pos);
        switch(ch){
            case 32:
            case 160:
                ++this.pos;
                break;
            case 13:
                if (this.input.charCodeAt(this.pos + 1) === 10) ++this.pos;
            case 10:
            case 8232:
            case 8233:
                ++this.pos;
                if (this.options.locations) {
                    ++this.curLine;
                    this.lineStart = this.pos;
                }
                break;
            case 47:
                switch(this.input.charCodeAt(this.pos + 1)){
                    case 42:
                        this.skipBlockComment();
                        break;
                    case 47:
                        this.skipLineComment(2);
                        break;
                    default:
                        break loop;
                }
                break;
            default:
                if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) ++this.pos;
                else break loop;
        }
    }
};
// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.
pp$9.finishToken = function(type, val) {
    this.end = this.pos;
    if (this.options.locations) this.endLoc = this.curPosition();
    var prevType = this.type;
    this.type = type;
    this.value = val;
    this.updateContext(prevType);
};
// ### Token reading
// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$9.readToken_dot = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next >= 48 && next <= 57) return this.readNumber(true);
    var next2 = this.input.charCodeAt(this.pos + 2);
    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
        this.pos += 3;
        return this.finishToken(types.ellipsis);
    } else {
        ++this.pos;
        return this.finishToken(types.dot);
    }
};
pp$9.readToken_slash = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (this.exprAllowed) {
        ++this.pos;
        return this.readRegexp();
    }
    if (next === 61) return this.finishOp(types.assign, 2);
    return this.finishOp(types.slash, 1);
};
pp$9.readToken_mult_modulo_exp = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    var tokentype = code === 42 ? types.star : types.modulo;
    // exponentiation operator ** and **=
    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
        ++size;
        tokentype = types.starstar;
        next = this.input.charCodeAt(this.pos + 2);
    }
    if (next === 61) return this.finishOp(types.assign, size + 1);
    return this.finishOp(tokentype, size);
};
pp$9.readToken_pipe_amp = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
        if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) return this.finishOp(types.assign, 3);
        }
        return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
    }
    if (next === 61) return this.finishOp(types.assign, 2);
    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
};
pp$9.readToken_caret = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) return this.finishOp(types.assign, 2);
    return this.finishOp(types.bitwiseXOR, 1);
};
pp$9.readToken_plus_min = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            // A `-->` line comment
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
        }
        return this.finishOp(types.incDec, 2);
    }
    if (next === 61) return this.finishOp(types.assign, 2);
    return this.finishOp(types.plusMin, 1);
};
pp$9.readToken_lt_gt = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(types.assign, size + 1);
        return this.finishOp(types.bitShift, size);
    }
    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
        // `<!--`, an XML-style comment that should be interpreted as a line comment
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken();
    }
    if (next === 61) size = 2;
    return this.finishOp(types.relational, size);
};
pp$9.readToken_eq_excl = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
        this.pos += 2;
        return this.finishToken(types.arrow);
    }
    return this.finishOp(code === 61 ? types.eq : types.prefix, 1);
};
pp$9.readToken_question = function() {
    var ecmaVersion = this.options.ecmaVersion;
    if (ecmaVersion >= 11) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) return this.finishOp(types.questionDot, 2);
        }
        if (next === 63) {
            if (ecmaVersion >= 12) {
                var next2$1 = this.input.charCodeAt(this.pos + 2);
                if (next2$1 === 61) return this.finishOp(types.assign, 3);
            }
            return this.finishOp(types.coalesce, 2);
        }
    }
    return this.finishOp(types.question, 1);
};
pp$9.getTokenFromCode = function(code) {
    switch(code){
        // The interpretation of a dot depends on whether it is followed
        // by a digit or another two dots.
        case 46:
            return this.readToken_dot();
        // Punctuation tokens.
        case 40:
            ++this.pos;
            return this.finishToken(types.parenL);
        case 41:
            ++this.pos;
            return this.finishToken(types.parenR);
        case 59:
            ++this.pos;
            return this.finishToken(types.semi);
        case 44:
            ++this.pos;
            return this.finishToken(types.comma);
        case 91:
            ++this.pos;
            return this.finishToken(types.bracketL);
        case 93:
            ++this.pos;
            return this.finishToken(types.bracketR);
        case 123:
            ++this.pos;
            return this.finishToken(types.braceL);
        case 125:
            ++this.pos;
            return this.finishToken(types.braceR);
        case 58:
            ++this.pos;
            return this.finishToken(types.colon);
        case 96:
            if (this.options.ecmaVersion < 6) break;
            ++this.pos;
            return this.finishToken(types.backQuote);
        case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) return this.readRadixNumber(16);
             // '0x', '0X' - hex number
            if (this.options.ecmaVersion >= 6) {
                if (next === 111 || next === 79) return this.readRadixNumber(8);
                 // '0o', '0O' - octal number
                if (next === 98 || next === 66) return this.readRadixNumber(2);
                 // '0b', '0B' - binary number
            }
        // Anything else beginning with a digit is an integer, octal
        // number, or float.
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
            return this.readNumber(false);
        // Quotes produce strings.
        case 34:
        case 39:
            return this.readString(code);
        // Operators are parsed inline in tiny state machines. '=' (61) is
        // often referred to. `finishOp` simply skips the amount of
        // characters it is given as second argument, and returns a token
        // of the type given by its first argument.
        case 47:
            return this.readToken_slash();
        case 37:
        case 42:
            return this.readToken_mult_modulo_exp(code);
        case 124:
        case 38:
            return this.readToken_pipe_amp(code);
        case 94:
            return this.readToken_caret();
        case 43:
        case 45:
            return this.readToken_plus_min(code);
        case 60:
        case 62:
            return this.readToken_lt_gt(code);
        case 61:
        case 33:
            return this.readToken_eq_excl(code);
        case 63:
            return this.readToken_question();
        case 126:
            return this.finishOp(types.prefix, 1);
    }
    this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
};
pp$9.finishOp = function(type, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    this.pos += size;
    return this.finishToken(type, str);
};
pp$9.readRegexp = function() {
    var escaped, inClass, start = this.pos;
    for(;;){
        if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
        var ch = this.input.charAt(this.pos);
        if (lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
        if (!escaped) {
            if (ch === "[") inClass = true;
            else if (ch === "]" && inClass) inClass = false;
            else if (ch === "/" && !inClass) break;
            escaped = ch === "\\";
        } else escaped = false;
        ++this.pos;
    }
    var pattern = this.input.slice(start, this.pos);
    ++this.pos;
    var flagsStart = this.pos;
    var flags = this.readWord1();
    if (this.containsEsc) this.unexpected(flagsStart);
    // Validate pattern
    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start, pattern, flags);
    this.validateRegExpFlags(state);
    this.validateRegExpPattern(state);
    // Create Literal#value property value.
    var value = null;
    try {
        value = new RegExp(pattern, flags);
    } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
    }
    return this.finishToken(types.regexp, {
        pattern: pattern,
        flags: flags,
        value: value
    });
};
// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.
pp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
    // `len` is used for character escape sequences. In that case, disallow separators.
    var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;
    // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
    // and isn't fraction part nor exponent part. In that case, if the first digit
    // is zero then disallow separators.
    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
    var start = this.pos, total = 0, lastCode = 0;
    for(var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos){
        var code = this.input.charCodeAt(this.pos), val = void 0;
        if (allowSeparators && code === 95) {
            if (isLegacyOctalNumericLiteral) this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            if (lastCode === 95) this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            if (i === 0) this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            lastCode = code;
            continue;
        }
        if (code >= 97) val = code - 97 + 10;
        else if (code >= 65) val = code - 65 + 10;
        else if (code >= 48 && code <= 57) val = code - 48;
        else val = Infinity;
        if (val >= radix) break;
        lastCode = code;
        total = total * radix + val;
    }
    if (allowSeparators && lastCode === 95) this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
    if (this.pos === start || len != null && this.pos - start !== len) return null;
    return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
    if (isLegacyOctalNumericLiteral) return parseInt(str, 8);
    // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
    return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
    if (typeof BigInt !== "function") return null;
    // `BigInt(value)` throws syntax error if the string contains numeric separators.
    return BigInt(str.replace(/_/g, ""));
}
pp$9.readRadixNumber = function(radix) {
    var start = this.pos;
    this.pos += 2; // 0x
    var val = this.readInt(radix);
    if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
        val = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
    } else if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
    return this.finishToken(types.num, val);
};
// Read an integer, octal integer, or floating-point number.
pp$9.readNumber = function(startsWithDot) {
    var start = this.pos;
    if (!startsWithDot && this.readInt(10, undefined, true) === null) this.raise(start, "Invalid number");
    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    if (octal && this.strict) this.raise(start, "Invalid number");
    var next = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
        var val$1 = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
        if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
        return this.finishToken(types.num, val$1);
    }
    if (octal && /[89]/.test(this.input.slice(start, this.pos))) octal = false;
    if (next === 46 && !octal) {
        ++this.pos;
        this.readInt(10);
        next = this.input.charCodeAt(this.pos);
    }
    if ((next === 69 || next === 101) && !octal) {
        next = this.input.charCodeAt(++this.pos);
        if (next === 43 || next === 45) ++this.pos;
         // '+-'
        if (this.readInt(10) === null) this.raise(start, "Invalid number");
    }
    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
    var val = stringToNumber(this.input.slice(start, this.pos), octal);
    return this.finishToken(types.num, val);
};
// Read a string value, interpreting backslash-escapes.
pp$9.readCodePoint = function() {
    var ch = this.input.charCodeAt(this.pos), code;
    if (ch === 123) {
        if (this.options.ecmaVersion < 6) this.unexpected();
        var codePos = ++this.pos;
        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code > 1114111) this.invalidStringToken(codePos, "Code point out of bounds");
    } else code = this.readHexChar(4);
    return code;
};
function codePointToString$1(code) {
    // UTF-16 Decoding
    if (code <= 65535) return String.fromCharCode(code);
    code -= 65536;
    return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
pp$9.readString = function(quote) {
    var out = "", chunkStart = ++this.pos;
    for(;;){
        if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
        var ch = this.input.charCodeAt(this.pos);
        if (ch === quote) break;
        if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
        } else {
            if (isNewLine(ch, this.options.ecmaVersion >= 10)) this.raise(this.start, "Unterminated string constant");
            ++this.pos;
        }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(types.string, out);
};
// Reads template string tokens.
var INVALID_TEMPLATE_ESCAPE_ERROR = {
};
pp$9.tryReadTemplateToken = function() {
    this.inTemplateElement = true;
    try {
        this.readTmplToken();
    } catch (err) {
        if (err === INVALID_TEMPLATE_ESCAPE_ERROR) this.readInvalidTemplateToken();
        else throw err;
    }
    this.inTemplateElement = false;
};
pp$9.invalidStringToken = function(position, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw INVALID_TEMPLATE_ESCAPE_ERROR;
    else this.raise(position, message);
};
pp$9.readTmplToken = function() {
    var out = "", chunkStart = this.pos;
    for(;;){
        if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
        var ch = this.input.charCodeAt(this.pos);
        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
                if (ch === 36) {
                    this.pos += 2;
                    return this.finishToken(types.dollarBraceL);
                } else {
                    ++this.pos;
                    return this.finishToken(types.backQuote);
                }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types.template, out);
        }
        if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
        } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch(ch){
                case 13:
                    if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
                case 10:
                    out += "\n";
                    break;
                default:
                    out += String.fromCharCode(ch);
                    break;
            }
            if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
            }
            chunkStart = this.pos;
        } else ++this.pos;
    }
};
// Reads a template token to search for the end, without validating any escape sequences
pp$9.readInvalidTemplateToken = function() {
    for(; this.pos < this.input.length; this.pos++)switch(this.input[this.pos]){
        case "\\":
            ++this.pos;
            break;
        case "$":
            if (this.input[this.pos + 1] !== "{") break;
        // falls through
        case "`":
            return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos));
    }
    this.raise(this.start, "Unterminated template");
};
// Used to read escaped characters
pp$9.readEscapedChar = function(inTemplate) {
    var ch = this.input.charCodeAt(++this.pos);
    ++this.pos;
    switch(ch){
        case 110:
            return "\n" // 'n' -> '\n'
            ;
        case 114:
            return "\r" // 'r' -> '\r'
            ;
        case 120:
            return String.fromCharCode(this.readHexChar(2)) // 'x'
            ;
        case 117:
            return codePointToString$1(this.readCodePoint()) // 'u'
            ;
        case 116:
            return "\t" // 't' -> '\t'
            ;
        case 98:
            return "\b" // 'b' -> '\b'
            ;
        case 118:
            return "\u000b" // 'v' -> '\u000b'
            ;
        case 102:
            return "\f" // 'f' -> '\f'
            ;
        case 13:
            if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
             // '\r\n'
        case 10:
            if (this.options.locations) {
                this.lineStart = this.pos;
                ++this.curLine;
            }
            return "";
        case 56:
        case 57:
            if (inTemplate) {
                var codePos = this.pos - 1;
                this.invalidStringToken(codePos, "Invalid escape sequence in template string");
                return null;
            }
        default:
            if (ch >= 48 && ch <= 55) {
                var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
                var octal = parseInt(octalStr, 8);
                if (octal > 255) {
                    octalStr = octalStr.slice(0, -1);
                    octal = parseInt(octalStr, 8);
                }
                this.pos += octalStr.length - 1;
                ch = this.input.charCodeAt(this.pos);
                if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
                return String.fromCharCode(octal);
            }
            if (isNewLine(ch)) // Unicode new line characters after \ get removed from output in both
            // template literals and strings
            return "";
            return String.fromCharCode(ch);
    }
};
// Used to read character escape sequences ('\x', '\u', '\U').
pp$9.readHexChar = function(len) {
    var codePos = this.pos;
    var n = this.readInt(16, len);
    if (n === null) this.invalidStringToken(codePos, "Bad character escape sequence");
    return n;
};
// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.
pp$9.readWord1 = function() {
    this.containsEsc = false;
    var word = "", first = true, chunkStart = this.pos;
    var astral = this.options.ecmaVersion >= 6;
    while(this.pos < this.input.length){
        var ch = this.fullCharCodeAtPos();
        if (isIdentifierChar(ch, astral)) this.pos += ch <= 65535 ? 1 : 2;
        else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) this.invalidStringToken(escStart, "Invalid Unicode escape");
            word += codePointToString$1(esc);
            chunkStart = this.pos;
        } else break;
        first = false;
    }
    return word + this.input.slice(chunkStart, this.pos);
};
// Read an identifier or keyword token. Will check for reserved
// words when necessary.
pp$9.readWord = function() {
    var word = this.readWord1();
    var type = types.name;
    if (this.keywords.test(word)) type = keywords$1[word];
    return this.finishToken(type, word);
};
// Acorn is a tiny, fast JavaScript parser written in JavaScript.
var version = "7.4.1";
Parser.acorn = {
    Parser: Parser,
    version: version,
    defaultOptions: defaultOptions,
    Position: Position,
    SourceLocation: SourceLocation,
    getLineInfo: getLineInfo,
    Node: Node,
    TokenType: TokenType,
    tokTypes: types,
    keywordTypes: keywords$1,
    TokContext: TokContext,
    tokContexts: types$1,
    isIdentifierChar: isIdentifierChar,
    isIdentifierStart: isIdentifierStart,
    Token: Token,
    isNewLine: isNewLine,
    lineBreak: lineBreak,
    lineBreakG: lineBreakG,
    nonASCIIwhitespace: nonASCIIwhitespace
};
// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
function parse(input, options) {
    return Parser.parse(input, options);
}
// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.
function parseExpressionAt(input, pos, options) {
    return Parser.parseExpressionAt(input, pos, options);
}
// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.
function tokenizer(input, options) {
    return Parser.tokenizer(input, options);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ciiiV":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"iUUFa":[function(require,module,exports) {
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/ 'use strict';
/* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
    if (val === null || val === undefined) throw new TypeError('Object.assign cannot be called with null or undefined');
    return Object(val);
}
function shouldUseNative() {
    try {
        if (!Object.assign) return false;
        // Detect buggy property enumeration order in older V8 versions.
        // https://bugs.chromium.org/p/v8/issues/detail?id=4118
        var test1 = "abc"; // eslint-disable-line no-new-wrappers
        test1[5] = 'de';
        if (Object.getOwnPropertyNames(test1)[0] === '5') return false;
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test2 = {
        };
        for(var i = 0; i < 10; i++)test2['_' + String.fromCharCode(i)] = i;
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
        });
        if (order2.join('') !== '0123456789') return false;
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test3 = {
        };
        'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
            test3[letter] = letter;
        });
        if (Object.keys(Object.assign({
        }, test3)).join('') !== 'abcdefghijklmnopqrst') return false;
        return true;
    } catch (err) {
        // We don't expect any of the above to throw, but better to be safe.
        return false;
    }
}
module.exports = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for(var s = 1; s < arguments.length; s++){
        from = Object(arguments[s]);
        for(var key in from)if (hasOwnProperty.call(from, key)) to[key] = from[key];
        if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for(var i = 0; i < symbols.length; i++)if (propIsEnumerable.call(from, symbols[i])) to[symbols[i]] = from[symbols[i]];
        }
    }
    return to;
};

},{}],"g0oN1":[function(require,module,exports) {
'use strict';
var objIsRegex = require('is-regex');
exports = module.exports = parse;
var TOKEN_TYPES = exports.TOKEN_TYPES = {
    LINE_COMMENT: '//',
    BLOCK_COMMENT: '/**/',
    SINGLE_QUOTE: '\'',
    DOUBLE_QUOTE: '"',
    TEMPLATE_QUOTE: '`',
    REGEXP: '//g'
};
var BRACKETS = exports.BRACKETS = {
    '(': ')',
    '{': '}',
    '[': ']'
};
var BRACKETS_REVERSED = {
    ')': '(',
    '}': '{',
    ']': '['
};
exports.parse = parse;
function parse(src, state, options) {
    options = options || {
    };
    state = state || exports.defaultState();
    var start = options.start || 0;
    var end = options.end || src.length;
    var index = start;
    while(index < end){
        try {
            parseChar(src[index], state);
        } catch (ex) {
            ex.index = index;
            throw ex;
        }
        index++;
    }
    return state;
}
exports.parseUntil = parseUntil;
function parseUntil(src, delimiter, options) {
    options = options || {
    };
    var start = options.start || 0;
    var index = start;
    var state = exports.defaultState();
    while(index < src.length){
        if ((options.ignoreNesting || !state.isNesting(options)) && matches(src, delimiter, index)) {
            var end = index;
            return {
                start: start,
                end: end,
                src: src.substring(start, end)
            };
        }
        try {
            parseChar(src[index], state);
        } catch (ex) {
            ex.index = index;
            throw ex;
        }
        index++;
    }
    var err = new Error('The end of the string was reached with no closing bracket found.');
    err.code = 'CHARACTER_PARSER:END_OF_STRING_REACHED';
    err.index = index;
    throw err;
}
exports.parseChar = parseChar;
function parseChar(character, state) {
    if (character.length !== 1) {
        var err = new Error('Character must be a string of length 1');
        err.name = 'InvalidArgumentError';
        err.code = 'CHARACTER_PARSER:CHAR_LENGTH_NOT_ONE';
        throw err;
    }
    state = state || exports.defaultState();
    state.src += character;
    var wasComment = state.isComment();
    var lastChar = state.history ? state.history[0] : '';
    if (state.regexpStart) {
        if (character === '/' || character == '*') state.stack.pop();
        state.regexpStart = false;
    }
    switch(state.current()){
        case TOKEN_TYPES.LINE_COMMENT:
            if (character === '\n') state.stack.pop();
            break;
        case TOKEN_TYPES.BLOCK_COMMENT:
            if (state.lastChar === '*' && character === '/') state.stack.pop();
            break;
        case TOKEN_TYPES.SINGLE_QUOTE:
            if (character === '\'' && !state.escaped) state.stack.pop();
            else if (character === '\\' && !state.escaped) state.escaped = true;
            else state.escaped = false;
            break;
        case TOKEN_TYPES.DOUBLE_QUOTE:
            if (character === '"' && !state.escaped) state.stack.pop();
            else if (character === '\\' && !state.escaped) state.escaped = true;
            else state.escaped = false;
            break;
        case TOKEN_TYPES.TEMPLATE_QUOTE:
            if (character === '`' && !state.escaped) {
                state.stack.pop();
                state.hasDollar = false;
            } else if (character === '\\' && !state.escaped) {
                state.escaped = true;
                state.hasDollar = false;
            } else if (character === '$' && !state.escaped) state.hasDollar = true;
            else if (character === '{' && state.hasDollar) state.stack.push(BRACKETS[character]);
            else {
                state.escaped = false;
                state.hasDollar = false;
            }
            break;
        case TOKEN_TYPES.REGEXP:
            if (character === '/' && !state.escaped) state.stack.pop();
            else if (character === '\\' && !state.escaped) state.escaped = true;
            else state.escaped = false;
            break;
        default:
            if (character in BRACKETS) state.stack.push(BRACKETS[character]);
            else if (character in BRACKETS_REVERSED) {
                if (state.current() !== character) {
                    var err = new SyntaxError('Mismatched Bracket: ' + character);
                    err.code = 'CHARACTER_PARSER:MISMATCHED_BRACKET';
                    throw err;
                }
                state.stack.pop();
            } else if (lastChar === '/' && character === '/') {
                // Don't include comments in history
                state.history = state.history.substr(1);
                state.stack.push(TOKEN_TYPES.LINE_COMMENT);
            } else if (lastChar === '/' && character === '*') {
                // Don't include comment in history
                state.history = state.history.substr(1);
                state.stack.push(TOKEN_TYPES.BLOCK_COMMENT);
            } else if (character === '/' && isRegexp(state.history)) {
                state.stack.push(TOKEN_TYPES.REGEXP);
                // N.B. if the next character turns out to be a `*` or a `/`
                //      then this isn't actually a regexp
                state.regexpStart = true;
            } else if (character === '\'') state.stack.push(TOKEN_TYPES.SINGLE_QUOTE);
            else if (character === '"') state.stack.push(TOKEN_TYPES.DOUBLE_QUOTE);
            else if (character === '`') state.stack.push(TOKEN_TYPES.TEMPLATE_QUOTE);
            break;
    }
    if (!state.isComment() && !wasComment) state.history = character + state.history;
    state.lastChar = character; // store last character for ending block comments
    return state;
}
exports.defaultState = function() {
    return new State();
};
function State() {
    this.stack = [];
    this.regexpStart = false;
    this.escaped = false;
    this.hasDollar = false;
    this.src = '';
    this.history = '';
    this.lastChar = '';
}
State.prototype.current = function() {
    return this.stack[this.stack.length - 1];
};
State.prototype.isString = function() {
    return this.current() === TOKEN_TYPES.SINGLE_QUOTE || this.current() === TOKEN_TYPES.DOUBLE_QUOTE || this.current() === TOKEN_TYPES.TEMPLATE_QUOTE;
};
State.prototype.isComment = function() {
    return this.current() === TOKEN_TYPES.LINE_COMMENT || this.current() === TOKEN_TYPES.BLOCK_COMMENT;
};
State.prototype.isNesting = function(opts) {
    if (opts && opts.ignoreLineComment && this.stack.length === 1 && this.stack[0] === TOKEN_TYPES.LINE_COMMENT) // if we are only inside a line comment, and line comments are ignored
    // don't count it as nesting
    return false;
    return !!this.stack.length;
};
function matches(str, matcher, i) {
    if (objIsRegex(matcher)) return matcher.test(str.substr(i || 0));
    else return str.substr(i || 0, matcher.length) === matcher;
}
exports.isPunctuator = isPunctuator;
function isPunctuator(c) {
    if (!c) return true; // the start of a string is a punctuator
    var code = c.charCodeAt(0);
    switch(code){
        case 46:
        case 40:
        case 41:
        case 59:
        case 44:
        case 123:
        case 125:
        case 91:
        case 93:
        case 58:
        case 63:
        case 126:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 47:
        case 60:
        case 62:
        case 94:
        case 124:
        case 33:
        case 61:
            return true;
        default:
            return false;
    }
}
exports.isKeyword = isKeyword;
function isKeyword(id) {
    return id === 'if' || id === 'in' || id === 'do' || id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let' || id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum' || id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super' || id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import' || id === 'default' || id === 'finally' || id === 'extends' || id === 'function' || id === 'continue' || id === 'debugger' || id === 'package' || id === 'private' || id === 'interface' || id === 'instanceof' || id === 'implements' || id === 'protected' || id === 'public' || id === 'static';
}
function isRegexp(history) {
    //could be start of regexp or divide sign
    history = history.replace(/^\s*/, '');
    //unless its an `if`, `while`, `for` or `with` it's a divide, so we assume it's a divide
    if (history[0] === ')') return false;
    //unless it's a function expression, it's a regexp, so we assume it's a regexp
    if (history[0] === '}') return true;
    //any punctuation means it's a regexp
    if (isPunctuator(history[0])) return true;
    //if the last thing was a keyword then it must be a regexp (e.g. `typeof /foo/`)
    if (/^\w+\b/.test(history) && isKeyword(/^\w+\b/.exec(history)[0].split('').reverse().join(''))) return true;
    return false;
}

},{"is-regex":"84s4u"}],"84s4u":[function(require,module,exports) {
'use strict';
var callBound = require('call-bind/callBound');
var hasToStringTag = require('has-tostringtag/shams')();
var has;
var $exec;
var isRegexMarker;
var badStringifier;
if (hasToStringTag) {
    has = callBound('Object.prototype.hasOwnProperty');
    $exec = callBound('RegExp.prototype.exec');
    isRegexMarker = {
    };
    var throwRegexMarker = function() {
        throw isRegexMarker;
    };
    badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === 'symbol') badStringifier[Symbol.toPrimitive] = throwRegexMarker;
}
var $toString = callBound('Object.prototype.toString');
var gOPD = Object.getOwnPropertyDescriptor;
var regexClass = '[object RegExp]';
module.exports = hasToStringTag ? function isRegex(value) {
    if (!value || typeof value !== 'object') return false;
    var descriptor = gOPD(value, 'lastIndex');
    var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
    if (!hasLastIndexDataProperty) return false;
    try {
        $exec(value, badStringifier);
    } catch (e) {
        return e === isRegexMarker;
    }
} : function isRegex(value) {
    // In older browsers, typeof regex incorrectly returns 'function'
    if (!value || typeof value !== 'object' && typeof value !== 'function') return false;
    return $toString(value) === regexClass;
};

},{"call-bind/callBound":"f0fyo","has-tostringtag/shams":"7aneK"}],"lbNNk":[function(require,module,exports) {
'use strict';
module.exports = makeError;
function makeError(code, message, options) {
    var line = options.line;
    var column = options.column;
    var filename = options.filename;
    var src = options.src;
    var fullMessage;
    var location = line + (column ? ':' + column : '');
    if (src && line >= 1 && line <= src.split('\n').length) {
        var lines = src.split('\n');
        var start = Math.max(line - 3, 0);
        var end = Math.min(lines.length, line + 3);
        // Error context
        var context = lines.slice(start, end).map(function(text, i) {
            var curr = i + start + 1;
            var preamble = (curr == line ? '  > ' : '    ') + curr + '| ';
            var out = preamble + text;
            if (curr === line && column > 0) {
                out += '\n';
                out += Array(preamble.length + column).join('-') + '^';
            }
            return out;
        }).join('\n');
        fullMessage = (filename || 'Pug') + ':' + location + '\n' + context + '\n\n' + message;
    } else fullMessage = (filename || 'Pug') + ':' + location + '\n\n' + message;
    var err = new Error(fullMessage);
    err.code = 'PUG:' + code;
    err.msg = message;
    err.line = line;
    err.column = column;
    err.filename = filename;
    err.src = src;
    err.toJSON = function() {
        return {
            code: this.code,
            msg: this.msg,
            line: this.line,
            column: this.column,
            filename: this.filename
        };
    };
    return err;
}

},{}],"i1wRT":[function(require,module,exports) {
'use strict';
var error = require('pug-error');
module.exports = stripComments;
function unexpectedToken(type, occasion, filename, line) {
    var msg = '`' + type + '` encountered when ' + occasion;
    throw error('UNEXPECTED_TOKEN', msg, {
        filename: filename,
        line: line
    });
}
function stripComments(input, options) {
    options = options || {
    };
    // Default: strip unbuffered comments and leave buffered ones alone
    var stripUnbuffered = options.stripUnbuffered !== false;
    var stripBuffered = options.stripBuffered === true;
    var filename = options.filename;
    var out = [];
    // If we have encountered a comment token and are not sure if we have gotten
    // out of the comment or not
    var inComment = false;
    // If we are sure that we are in a block comment and all tokens except
    // `end-pipeless-text` should be ignored
    var inPipelessText = false;
    return input.filter(function(tok) {
        switch(tok.type){
            case 'comment':
                if (inComment) unexpectedToken('comment', 'already in a comment', filename, tok.line);
                else {
                    inComment = tok.buffer ? stripBuffered : stripUnbuffered;
                    return !inComment;
                }
            case 'start-pipeless-text':
                if (!inComment) return true;
                if (inPipelessText) unexpectedToken('start-pipeless-text', 'already in pipeless text mode', filename, tok.line);
                inPipelessText = true;
                return false;
            case 'end-pipeless-text':
                if (!inComment) return true;
                if (!inPipelessText) unexpectedToken('end-pipeless-text', 'not in pipeless text mode', filename, tok.line);
                inPipelessText = false;
                inComment = false;
                return false;
            // There might be a `text` right after `comment` but before
            // `start-pipeless-text`. Treat it accordingly.
            case 'text':
                return !inComment;
            default:
                if (inPipelessText) return false;
                inComment = false;
                return true;
        }
    });
}

},{"pug-error":"lbNNk"}],"vqQq1":[function(require,module,exports) {
'use strict';
var assert = require('assert');
var TokenStream = require('token-stream');
var error = require('pug-error');
var inlineTags = require('./lib/inline-tags');
module.exports = parse;
module.exports.Parser = Parser;
function parse(tokens, options) {
    var parser = new Parser(tokens, options);
    var ast = parser.parse();
    return JSON.parse(JSON.stringify(ast));
}
/**
 * Initialize `Parser` with the given input `str` and `filename`.
 *
 * @param {String} str
 * @param {String} filename
 * @param {Object} options
 * @api public
 */ function Parser(tokens, options) {
    options = options || {
    };
    if (!Array.isArray(tokens)) throw new Error('Expected tokens to be an Array but got "' + typeof tokens + '"');
    if (typeof options !== 'object') throw new Error('Expected "options" to be an object but got "' + typeof options + '"');
    this.tokens = new TokenStream(tokens);
    this.filename = options.filename;
    this.src = options.src;
    this.inMixin = 0;
    this.plugins = options.plugins || [];
}
/**
 * Parser prototype.
 */ Parser.prototype = {
    /**
   * Save original constructor
   */ constructor: Parser,
    error: function(code, message, token) {
        var err = error(code, message, {
            line: token.loc.start.line,
            column: token.loc.start.column,
            filename: this.filename,
            src: this.src
        });
        throw err;
    },
    /**
   * Return the next token object.
   *
   * @return {Object}
   * @api private
   */ advance: function() {
        return this.tokens.advance();
    },
    /**
   * Single token lookahead.
   *
   * @return {Object}
   * @api private
   */ peek: function() {
        return this.tokens.peek();
    },
    /**
   * `n` token lookahead.
   *
   * @param {Number} n
   * @return {Object}
   * @api private
   */ lookahead: function(n) {
        return this.tokens.lookahead(n);
    },
    /**
   * Parse input returning a string of js for evaluation.
   *
   * @return {String}
   * @api public
   */ parse: function() {
        var block = this.emptyBlock(0);
        while('eos' != this.peek().type){
            if ('newline' == this.peek().type) this.advance();
            else if ('text-html' == this.peek().type) block.nodes = block.nodes.concat(this.parseTextHtml());
            else {
                var expr = this.parseExpr();
                if (expr) {
                    if (expr.type === 'Block') block.nodes = block.nodes.concat(expr.nodes);
                    else block.nodes.push(expr);
                }
            }
        }
        return block;
    },
    /**
   * Expect the given type, or throw an exception.
   *
   * @param {String} type
   * @api private
   */ expect: function(type) {
        if (this.peek().type === type) return this.advance();
        else this.error('INVALID_TOKEN', 'expected "' + type + '", but got "' + this.peek().type + '"', this.peek());
    },
    /**
   * Accept the given `type`.
   *
   * @param {String} type
   * @api private
   */ accept: function(type) {
        if (this.peek().type === type) return this.advance();
    },
    initBlock: function(line, nodes) {
        /* istanbul ignore if */ if ((line | 0) !== line) throw new Error('`line` is not an integer');
        /* istanbul ignore if */ if (!Array.isArray(nodes)) throw new Error('`nodes` is not an array');
        return {
            type: 'Block',
            nodes: nodes,
            line: line,
            filename: this.filename
        };
    },
    emptyBlock: function(line) {
        return this.initBlock(line, []);
    },
    runPlugin: function(context, tok) {
        var rest = [
            this
        ];
        for(var i = 2; i < arguments.length; i++)rest.push(arguments[i]);
        var pluginContext;
        for(var i = 0; i < this.plugins.length; i++){
            var plugin = this.plugins[i];
            if (plugin[context] && plugin[context][tok.type]) {
                if (pluginContext) throw new Error('Multiple plugin handlers found for context ' + JSON.stringify(context) + ', token type ' + JSON.stringify(tok.type));
                pluginContext = plugin[context];
            }
        }
        if (pluginContext) return pluginContext[tok.type].apply(pluginContext, rest);
    },
    /**
   *   tag
   * | doctype
   * | mixin
   * | include
   * | filter
   * | comment
   * | text
   * | text-html
   * | dot
   * | each
   * | code
   * | yield
   * | id
   * | class
   * | interpolation
   */ parseExpr: function() {
        switch(this.peek().type){
            case 'tag':
                return this.parseTag();
            case 'mixin':
                return this.parseMixin();
            case 'block':
                return this.parseBlock();
            case 'mixin-block':
                return this.parseMixinBlock();
            case 'case':
                return this.parseCase();
            case 'extends':
                return this.parseExtends();
            case 'include':
                return this.parseInclude();
            case 'doctype':
                return this.parseDoctype();
            case 'filter':
                return this.parseFilter();
            case 'comment':
                return this.parseComment();
            case 'text':
            case 'interpolated-code':
            case 'start-pug-interpolation':
                return this.parseText({
                    block: true
                });
            case 'text-html':
                return this.initBlock(this.peek().loc.start.line, this.parseTextHtml());
            case 'dot':
                return this.parseDot();
            case 'each':
                return this.parseEach();
            case 'eachOf':
                return this.parseEachOf();
            case 'code':
                return this.parseCode();
            case 'blockcode':
                return this.parseBlockCode();
            case 'if':
                return this.parseConditional();
            case 'while':
                return this.parseWhile();
            case 'call':
                return this.parseCall();
            case 'interpolation':
                return this.parseInterpolation();
            case 'yield':
                return this.parseYield();
            case 'id':
            case 'class':
                if (!this.peek().loc.start) debugger;
                this.tokens.defer({
                    type: 'tag',
                    val: 'div',
                    loc: this.peek().loc,
                    filename: this.filename
                });
                return this.parseExpr();
            default:
                var pluginResult = this.runPlugin('expressionTokens', this.peek());
                if (pluginResult) return pluginResult;
                this.error('INVALID_TOKEN', 'unexpected token "' + this.peek().type + '"', this.peek());
        }
    },
    parseDot: function() {
        this.advance();
        return this.parseTextBlock();
    },
    /**
   * Text
   */ parseText: function(options) {
        var tags = [];
        var lineno = this.peek().loc.start.line;
        var nextTok = this.peek();
        loop: while(true){
            switch(nextTok.type){
                case 'text':
                    var tok = this.advance();
                    tags.push({
                        type: 'Text',
                        val: tok.val,
                        line: tok.loc.start.line,
                        column: tok.loc.start.column,
                        filename: this.filename
                    });
                    break;
                case 'interpolated-code':
                    var tok = this.advance();
                    tags.push({
                        type: 'Code',
                        val: tok.val,
                        buffer: tok.buffer,
                        mustEscape: tok.mustEscape !== false,
                        isInline: true,
                        line: tok.loc.start.line,
                        column: tok.loc.start.column,
                        filename: this.filename
                    });
                    break;
                case 'newline':
                    if (!options || !options.block) break loop;
                    var tok = this.advance();
                    var nextType = this.peek().type;
                    if (nextType === 'text' || nextType === 'interpolated-code') tags.push({
                        type: 'Text',
                        val: '\n',
                        line: tok.loc.start.line,
                        column: tok.loc.start.column,
                        filename: this.filename
                    });
                    break;
                case 'start-pug-interpolation':
                    this.advance();
                    tags.push(this.parseExpr());
                    this.expect('end-pug-interpolation');
                    break;
                default:
                    var pluginResult = this.runPlugin('textTokens', nextTok, tags);
                    if (pluginResult) break;
                    break loop;
            }
            nextTok = this.peek();
        }
        if (tags.length === 1) return tags[0];
        else return this.initBlock(lineno, tags);
    },
    parseTextHtml: function() {
        var nodes = [];
        var currentNode = null;
        loop: while(true)switch(this.peek().type){
            case 'text-html':
                var text = this.advance();
                if (!currentNode) {
                    currentNode = {
                        type: 'Text',
                        val: text.val,
                        filename: this.filename,
                        line: text.loc.start.line,
                        column: text.loc.start.column,
                        isHtml: true
                    };
                    nodes.push(currentNode);
                } else currentNode.val += '\n' + text.val;
                break;
            case 'indent':
                var block = this.block();
                block.nodes.forEach(function(node) {
                    if (node.isHtml) {
                        if (!currentNode) {
                            currentNode = node;
                            nodes.push(currentNode);
                        } else currentNode.val += '\n' + node.val;
                    } else {
                        currentNode = null;
                        nodes.push(node);
                    }
                });
                break;
            case 'code':
                currentNode = null;
                nodes.push(this.parseCode(true));
                break;
            case 'newline':
                this.advance();
                break;
            default:
                break loop;
        }
        return nodes;
    },
    /**
   *   ':' expr
   * | block
   */ parseBlockExpansion: function() {
        var tok = this.accept(':');
        if (tok) {
            var expr = this.parseExpr();
            return expr.type === 'Block' ? expr : this.initBlock(tok.loc.start.line, [
                expr
            ]);
        } else return this.block();
    },
    /**
   * case
   */ parseCase: function() {
        var tok = this.expect('case');
        var node = {
            type: 'Case',
            expr: tok.val,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        var block = this.emptyBlock(tok.loc.start.line + 1);
        this.expect('indent');
        while('outdent' != this.peek().type)switch(this.peek().type){
            case 'comment':
            case 'newline':
                this.advance();
                break;
            case 'when':
                block.nodes.push(this.parseWhen());
                break;
            case 'default':
                block.nodes.push(this.parseDefault());
                break;
            default:
                var pluginResult = this.runPlugin('caseTokens', this.peek(), block);
                if (pluginResult) break;
                this.error('INVALID_TOKEN', 'Unexpected token "' + this.peek().type + '", expected "when", "default" or "newline"', this.peek());
        }
        this.expect('outdent');
        node.block = block;
        return node;
    },
    /**
   * when
   */ parseWhen: function() {
        var tok = this.expect('when');
        if (this.peek().type !== 'newline') return {
            type: 'When',
            expr: tok.val,
            block: this.parseBlockExpansion(),
            debug: false,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        else return {
            type: 'When',
            expr: tok.val,
            debug: false,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    /**
   * default
   */ parseDefault: function() {
        var tok = this.expect('default');
        return {
            type: 'When',
            expr: 'default',
            block: this.parseBlockExpansion(),
            debug: false,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    /**
   * code
   */ parseCode: function(noBlock) {
        var tok = this.expect('code');
        assert(typeof tok.mustEscape === 'boolean', 'Please update to the newest version of pug-lexer.');
        var node = {
            type: 'Code',
            val: tok.val,
            buffer: tok.buffer,
            mustEscape: tok.mustEscape !== false,
            isInline: !!noBlock,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        // todo: why is this here?  It seems like a hacky workaround
        if (node.val.match(/^ *else/)) node.debug = false;
        if (noBlock) return node;
        var block;
        // handle block
        block = 'indent' == this.peek().type;
        if (block) {
            if (tok.buffer) this.error('BLOCK_IN_BUFFERED_CODE', 'Buffered code cannot have a block attached to it', this.peek());
            node.block = this.block();
        }
        return node;
    },
    parseConditional: function() {
        var tok = this.expect('if');
        var node = {
            type: 'Conditional',
            test: tok.val,
            consequent: this.emptyBlock(tok.loc.start.line),
            alternate: null,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        // handle block
        if ('indent' == this.peek().type) node.consequent = this.block();
        var currentNode = node;
        while(true){
            if (this.peek().type === 'newline') this.expect('newline');
            else if (this.peek().type === 'else-if') {
                tok = this.expect('else-if');
                currentNode = currentNode.alternate = {
                    type: 'Conditional',
                    test: tok.val,
                    consequent: this.emptyBlock(tok.loc.start.line),
                    alternate: null,
                    line: tok.loc.start.line,
                    column: tok.loc.start.column,
                    filename: this.filename
                };
                if ('indent' == this.peek().type) currentNode.consequent = this.block();
            } else if (this.peek().type === 'else') {
                this.expect('else');
                if (this.peek().type === 'indent') currentNode.alternate = this.block();
                break;
            } else break;
        }
        return node;
    },
    parseWhile: function() {
        var tok = this.expect('while');
        var node = {
            type: 'While',
            test: tok.val,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        // handle block
        if ('indent' == this.peek().type) node.block = this.block();
        else node.block = this.emptyBlock(tok.loc.start.line);
        return node;
    },
    /**
   * block code
   */ parseBlockCode: function() {
        var tok = this.expect('blockcode');
        var line = tok.loc.start.line;
        var column = tok.loc.start.column;
        var body = this.peek();
        var text = '';
        if (body.type === 'start-pipeless-text') {
            this.advance();
            while(this.peek().type !== 'end-pipeless-text'){
                tok = this.advance();
                switch(tok.type){
                    case 'text':
                        text += tok.val;
                        break;
                    case 'newline':
                        text += '\n';
                        break;
                    default:
                        var pluginResult = this.runPlugin('blockCodeTokens', tok, tok);
                        if (pluginResult) {
                            text += pluginResult;
                            break;
                        }
                        this.error('INVALID_TOKEN', 'Unexpected token type: ' + tok.type, tok);
                }
            }
            this.advance();
        }
        return {
            type: 'Code',
            val: text,
            buffer: false,
            mustEscape: false,
            isInline: false,
            line: line,
            column: column,
            filename: this.filename
        };
    },
    /**
   * comment
   */ parseComment: function() {
        var tok = this.expect('comment');
        var block;
        if (block = this.parseTextBlock()) return {
            type: 'BlockComment',
            val: tok.val,
            block: block,
            buffer: tok.buffer,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        else return {
            type: 'Comment',
            val: tok.val,
            buffer: tok.buffer,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    /**
   * doctype
   */ parseDoctype: function() {
        var tok = this.expect('doctype');
        return {
            type: 'Doctype',
            val: tok.val,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    parseIncludeFilter: function() {
        var tok = this.expect('filter');
        var attrs = [];
        if (this.peek().type === 'start-attributes') attrs = this.attrs();
        return {
            type: 'IncludeFilter',
            name: tok.val,
            attrs: attrs,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    /**
   * filter attrs? text-block
   */ parseFilter: function() {
        var tok = this.expect('filter');
        var block, attrs = [];
        if (this.peek().type === 'start-attributes') attrs = this.attrs();
        if (this.peek().type === 'text') {
            var textToken = this.advance();
            block = this.initBlock(textToken.loc.start.line, [
                {
                    type: 'Text',
                    val: textToken.val,
                    line: textToken.loc.start.line,
                    column: textToken.loc.start.column,
                    filename: this.filename
                }, 
            ]);
        } else if (this.peek().type === 'filter') block = this.initBlock(tok.loc.start.line, [
            this.parseFilter()
        ]);
        else block = this.parseTextBlock() || this.emptyBlock(tok.loc.start.line);
        return {
            type: 'Filter',
            name: tok.val,
            block: block,
            attrs: attrs,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    /**
   * each block
   */ parseEach: function() {
        var tok = this.expect('each');
        var node = {
            type: 'Each',
            obj: tok.code,
            val: tok.val,
            key: tok.key,
            block: this.block(),
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        if (this.peek().type == 'else') {
            this.advance();
            node.alternate = this.block();
        }
        return node;
    },
    parseEachOf: function() {
        var tok = this.expect('eachOf');
        var node = {
            type: 'EachOf',
            obj: tok.code,
            val: tok.val,
            block: this.block(),
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        return node;
    },
    /**
   * 'extends' name
   */ parseExtends: function() {
        var tok = this.expect('extends');
        var path = this.expect('path');
        return {
            type: 'Extends',
            file: {
                type: 'FileReference',
                path: path.val.trim(),
                line: path.loc.start.line,
                column: path.loc.start.column,
                filename: this.filename
            },
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    /**
   * 'block' name block
   */ parseBlock: function() {
        var tok = this.expect('block');
        var node = 'indent' == this.peek().type ? this.block() : this.emptyBlock(tok.loc.start.line);
        node.type = 'NamedBlock';
        node.name = tok.val.trim();
        node.mode = tok.mode;
        node.line = tok.loc.start.line;
        node.column = tok.loc.start.column;
        return node;
    },
    parseMixinBlock: function() {
        var tok = this.expect('mixin-block');
        if (!this.inMixin) this.error('BLOCK_OUTISDE_MIXIN', 'Anonymous blocks are not allowed unless they are part of a mixin.', tok);
        return {
            type: 'MixinBlock',
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    parseYield: function() {
        var tok = this.expect('yield');
        return {
            type: 'YieldBlock',
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    /**
   * include block?
   */ parseInclude: function() {
        var tok = this.expect('include');
        var node = {
            type: 'Include',
            file: {
                type: 'FileReference',
                filename: this.filename
            },
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        var filters = [];
        while(this.peek().type === 'filter')filters.push(this.parseIncludeFilter());
        var path = this.expect('path');
        node.file.path = path.val.trim();
        node.file.line = path.loc.start.line;
        node.file.column = path.loc.start.column;
        if ((/\.jade$/.test(node.file.path) || /\.pug$/.test(node.file.path)) && !filters.length) {
            node.block = 'indent' == this.peek().type ? this.block() : this.emptyBlock(tok.loc.start.line);
            if (/\.jade$/.test(node.file.path)) console.warn(this.filename + ', line ' + tok.loc.start.line + ':\nThe .jade extension is deprecated, use .pug for "' + node.file.path + '".');
        } else {
            node.type = 'RawInclude';
            node.filters = filters;
            if (this.peek().type === 'indent') this.error('RAW_INCLUDE_BLOCK', 'Raw inclusion cannot contain a block', this.peek());
        }
        return node;
    },
    /**
   * call ident block
   */ parseCall: function() {
        var tok = this.expect('call');
        var name = tok.val;
        var args = tok.args;
        var mixin = {
            type: 'Mixin',
            name: name,
            args: args,
            block: this.emptyBlock(tok.loc.start.line),
            call: true,
            attrs: [],
            attributeBlocks: [],
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        this.tag(mixin);
        if (mixin.code) {
            mixin.block.nodes.push(mixin.code);
            delete mixin.code;
        }
        if (mixin.block.nodes.length === 0) mixin.block = null;
        return mixin;
    },
    /**
   * mixin block
   */ parseMixin: function() {
        var tok = this.expect('mixin');
        var name = tok.val;
        var args = tok.args;
        if ('indent' == this.peek().type) {
            this.inMixin++;
            var mixin = {
                type: 'Mixin',
                name: name,
                args: args,
                block: this.block(),
                call: false,
                line: tok.loc.start.line,
                column: tok.loc.start.column,
                filename: this.filename
            };
            this.inMixin--;
            return mixin;
        } else this.error('MIXIN_WITHOUT_BODY', 'Mixin ' + name + ' declared without body', tok);
    },
    /**
   * indent (text | newline)* outdent
   */ parseTextBlock: function() {
        var tok = this.accept('start-pipeless-text');
        if (!tok) return;
        var block = this.emptyBlock(tok.loc.start.line);
        while(this.peek().type !== 'end-pipeless-text'){
            var tok = this.advance();
            switch(tok.type){
                case 'text':
                    block.nodes.push({
                        type: 'Text',
                        val: tok.val,
                        line: tok.loc.start.line,
                        column: tok.loc.start.column,
                        filename: this.filename
                    });
                    break;
                case 'newline':
                    block.nodes.push({
                        type: 'Text',
                        val: '\n',
                        line: tok.loc.start.line,
                        column: tok.loc.start.column,
                        filename: this.filename
                    });
                    break;
                case 'start-pug-interpolation':
                    block.nodes.push(this.parseExpr());
                    this.expect('end-pug-interpolation');
                    break;
                case 'interpolated-code':
                    block.nodes.push({
                        type: 'Code',
                        val: tok.val,
                        buffer: tok.buffer,
                        mustEscape: tok.mustEscape !== false,
                        isInline: true,
                        line: tok.loc.start.line,
                        column: tok.loc.start.column,
                        filename: this.filename
                    });
                    break;
                default:
                    var pluginResult = this.runPlugin('textBlockTokens', tok, block, tok);
                    if (pluginResult) break;
                    this.error('INVALID_TOKEN', 'Unexpected token type: ' + tok.type, tok);
            }
        }
        this.advance();
        return block;
    },
    /**
   * indent expr* outdent
   */ block: function() {
        var tok = this.expect('indent');
        var block = this.emptyBlock(tok.loc.start.line);
        while('outdent' != this.peek().type){
            if ('newline' == this.peek().type) this.advance();
            else if ('text-html' == this.peek().type) block.nodes = block.nodes.concat(this.parseTextHtml());
            else {
                var expr = this.parseExpr();
                if (expr.type === 'Block') block.nodes = block.nodes.concat(expr.nodes);
                else block.nodes.push(expr);
            }
        }
        this.expect('outdent');
        return block;
    },
    /**
   * interpolation (attrs | class | id)* (text | code | ':')? newline* block?
   */ parseInterpolation: function() {
        var tok = this.advance();
        var tag = {
            type: 'InterpolatedTag',
            expr: tok.val,
            selfClosing: false,
            block: this.emptyBlock(tok.loc.start.line),
            attrs: [],
            attributeBlocks: [],
            isInline: false,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        return this.tag(tag, {
            selfClosingAllowed: true
        });
    },
    /**
   * tag (attrs | class | id)* (text | code | ':')? newline* block?
   */ parseTag: function() {
        var tok = this.advance();
        var tag = {
            type: 'Tag',
            name: tok.val,
            selfClosing: false,
            block: this.emptyBlock(tok.loc.start.line),
            attrs: [],
            attributeBlocks: [],
            isInline: inlineTags.indexOf(tok.val) !== -1,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        return this.tag(tag, {
            selfClosingAllowed: true
        });
    },
    /**
   * Parse tag.
   */ tag: function(tag, options) {
        var seenAttrs = false;
        var attributeNames = [];
        var selfClosingAllowed = options && options.selfClosingAllowed;
        // (attrs | class | id)*
        out: while(true)switch(this.peek().type){
            case 'id':
            case 'class':
                var tok = this.advance();
                if (tok.type === 'id') {
                    if (attributeNames.indexOf('id') !== -1) this.error('DUPLICATE_ID', 'Duplicate attribute "id" is not allowed.', tok);
                    attributeNames.push('id');
                }
                tag.attrs.push({
                    name: tok.type,
                    val: "'" + tok.val + "'",
                    line: tok.loc.start.line,
                    column: tok.loc.start.column,
                    filename: this.filename,
                    mustEscape: false
                });
                continue;
            case 'start-attributes':
                if (seenAttrs) console.warn(this.filename + ', line ' + this.peek().loc.start.line + ':\nYou should not have pug tags with multiple attributes.');
                seenAttrs = true;
                tag.attrs = tag.attrs.concat(this.attrs(attributeNames));
                continue;
            case '&attributes':
                var tok = this.advance();
                tag.attributeBlocks.push({
                    type: 'AttributeBlock',
                    val: tok.val,
                    line: tok.loc.start.line,
                    column: tok.loc.start.column,
                    filename: this.filename
                });
                break;
            default:
                var pluginResult = this.runPlugin('tagAttributeTokens', this.peek(), tag, attributeNames);
                if (pluginResult) break;
                break out;
        }
        // check immediate '.'
        if ('dot' == this.peek().type) {
            tag.textOnly = true;
            this.advance();
        }
        // (text | code | ':')?
        switch(this.peek().type){
            case 'text':
            case 'interpolated-code':
                var text = this.parseText();
                if (text.type === 'Block') tag.block.nodes.push.apply(tag.block.nodes, text.nodes);
                else tag.block.nodes.push(text);
                break;
            case 'code':
                tag.block.nodes.push(this.parseCode(true));
                break;
            case ':':
                this.advance();
                var expr = this.parseExpr();
                tag.block = expr.type === 'Block' ? expr : this.initBlock(tag.line, [
                    expr
                ]);
                break;
            case 'newline':
            case 'indent':
            case 'outdent':
            case 'eos':
            case 'start-pipeless-text':
            case 'end-pug-interpolation':
                break;
            case 'slash':
                if (selfClosingAllowed) {
                    this.advance();
                    tag.selfClosing = true;
                    break;
                }
            default:
                var pluginResult = this.runPlugin('tagTokens', this.peek(), tag, options);
                if (pluginResult) break;
                this.error('INVALID_TOKEN', 'Unexpected token `' + this.peek().type + '` expected `text`, `interpolated-code`, `code`, `:`' + (selfClosingAllowed ? ', `slash`' : '') + ', `newline` or `eos`', this.peek());
        }
        // newline*
        while('newline' == this.peek().type)this.advance();
        // block?
        if (tag.textOnly) tag.block = this.parseTextBlock() || this.emptyBlock(tag.line);
        else if ('indent' == this.peek().type) {
            var block = this.block();
            for(var i = 0, len = block.nodes.length; i < len; ++i)tag.block.nodes.push(block.nodes[i]);
        }
        return tag;
    },
    attrs: function(attributeNames) {
        this.expect('start-attributes');
        var attrs = [];
        var tok = this.advance();
        while(tok.type === 'attribute'){
            if (tok.name !== 'class' && attributeNames) {
                if (attributeNames.indexOf(tok.name) !== -1) this.error('DUPLICATE_ATTRIBUTE', 'Duplicate attribute "' + tok.name + '" is not allowed.', tok);
                attributeNames.push(tok.name);
            }
            attrs.push({
                name: tok.name,
                val: tok.val,
                line: tok.loc.start.line,
                column: tok.loc.start.column,
                filename: this.filename,
                mustEscape: tok.mustEscape !== false
            });
            tok = this.advance();
        }
        this.tokens.defer(tok);
        this.expect('end-attributes');
        return attrs;
    }
};

},{"assert":"bTbxk","token-stream":"47JTj","pug-error":"lbNNk","./lib/inline-tags":"l3Vnw"}],"47JTj":[function(require,module,exports) {
'use strict';
module.exports = TokenStream;
function TokenStream(tokens) {
    if (!Array.isArray(tokens)) throw new TypeError('tokens must be passed to TokenStream as an array.');
    this._tokens = tokens;
}
TokenStream.prototype.lookahead = function(index) {
    if (this._tokens.length <= index) throw new Error('Cannot read past the end of a stream');
    return this._tokens[index];
};
TokenStream.prototype.peek = function() {
    if (this._tokens.length === 0) throw new Error('Cannot read past the end of a stream');
    return this._tokens[0];
};
TokenStream.prototype.advance = function() {
    if (this._tokens.length === 0) throw new Error('Cannot read past the end of a stream');
    return this._tokens.shift();
};
TokenStream.prototype.defer = function(token) {
    this._tokens.unshift(token);
};

},{}],"l3Vnw":[function(require,module,exports) {
'use strict';
module.exports = [
    'a',
    'abbr',
    'acronym',
    'b',
    'br',
    'code',
    'em',
    'font',
    'i',
    'img',
    'ins',
    'kbd',
    'map',
    'samp',
    'small',
    'span',
    'strong',
    'sub',
    'sup', 
];

},{}],"a0t0I":[function(require,module,exports) {
'use strict';
var fs = require('fs');
var path1 = require('path');
var walk = require('pug-walk');
var assign = require('object-assign');
module.exports = load;
function load(ast, options) {
    options = getOptions(options);
    // clone the ast
    ast = JSON.parse(JSON.stringify(ast));
    return walk(ast, function(node) {
        if (node.str === undefined) {
            if (node.type === 'Include' || node.type === 'RawInclude' || node.type === 'Extends') {
                var file = node.file;
                if (file.type !== 'FileReference') throw new Error('Expected file.type to be "FileReference"');
                var path, str, raw;
                try {
                    path = options.resolve(file.path, file.filename, options);
                    file.fullPath = path;
                    raw = options.read(path, options);
                    str = raw.toString('utf8');
                } catch (ex) {
                    ex.message += '\n    at ' + node.filename + ' line ' + node.line;
                    throw ex;
                }
                file.str = str;
                file.raw = raw;
                if (node.type === 'Extends' || node.type === 'Include') file.ast = load.string(str, assign({
                }, options, {
                    filename: path
                }));
            }
        }
    });
}
load.string = function loadString(src, options) {
    options = assign(getOptions(options), {
        src: src
    });
    var tokens = options.lex(src, options);
    var ast = options.parse(tokens, options);
    return load(ast, options);
};
load.file = function loadFile(filename, options) {
    options = assign(getOptions(options), {
        filename: filename
    });
    var str = options.read(filename).toString('utf8');
    return load.string(str, options);
};
load.resolve = function resolve(filename, source, options) {
    filename = filename.trim();
    if (filename[0] !== '/' && !source) throw new Error('the "filename" option is required to use includes and extends with "relative" paths');
    if (filename[0] === '/' && !options.basedir) throw new Error('the "basedir" option is required to use includes and extends with "absolute" paths');
    filename = path1.join(filename[0] === '/' ? options.basedir : path1.dirname(source.trim()), filename);
    return filename;
};
load.read = function read(filename, options) {
    return fs.readFileSync(filename);
};
load.validateOptions = function validateOptions(options) {
    /* istanbul ignore if */ if (typeof options !== 'object') throw new TypeError('options must be an object');
    /* istanbul ignore if */ if (typeof options.lex !== 'function') throw new TypeError('options.lex must be a function');
    /* istanbul ignore if */ if (typeof options.parse !== 'function') throw new TypeError('options.parse must be a function');
    /* istanbul ignore if */ if (options.resolve && typeof options.resolve !== 'function') throw new TypeError('options.resolve must be a function');
    /* istanbul ignore if */ if (options.read && typeof options.read !== 'function') throw new TypeError('options.read must be a function');
};
function getOptions(options) {
    load.validateOptions(options);
    return assign({
        resolve: load.resolve,
        read: load.read
    }, options);
}

},{"fs":"joWnX","path":"dTeSu","pug-walk":"dSk0a","object-assign":"iUUFa"}],"dSk0a":[function(require,module,exports) {
'use strict';
module.exports = walkAST;
function walkAST(ast, before, after, options) {
    if (after && typeof after === 'object' && typeof options === 'undefined') {
        options = after;
        after = null;
    }
    options = options || {
        includeDependencies: false
    };
    var parents = options.parents = options.parents || [];
    var replace1 = function replace(replacement) {
        if (Array.isArray(replacement) && !replace.arrayAllowed) throw new Error('replace() can only be called with an array if the last parent is a Block or NamedBlock');
        ast = replacement;
    };
    replace1.arrayAllowed = parents[0] && (/^(Named)?Block$/.test(parents[0].type) || parents[0].type === 'RawInclude' && ast.type === 'IncludeFilter');
    if (before) {
        var result = before(ast, replace1);
        if (result === false) return ast;
        else if (Array.isArray(ast)) // return right here to skip after() call on array
        return walkAndMergeNodes(ast);
    }
    parents.unshift(ast);
    switch(ast.type){
        case 'NamedBlock':
        case 'Block':
            ast.nodes = walkAndMergeNodes(ast.nodes);
            break;
        case 'Case':
        case 'Filter':
        case 'Mixin':
        case 'Tag':
        case 'InterpolatedTag':
        case 'When':
        case 'Code':
        case 'While':
            if (ast.block) ast.block = walkAST(ast.block, before, after, options);
            break;
        case 'Each':
            if (ast.block) ast.block = walkAST(ast.block, before, after, options);
            if (ast.alternate) ast.alternate = walkAST(ast.alternate, before, after, options);
            break;
        case 'EachOf':
            if (ast.block) ast.block = walkAST(ast.block, before, after, options);
            break;
        case 'Conditional':
            if (ast.consequent) ast.consequent = walkAST(ast.consequent, before, after, options);
            if (ast.alternate) ast.alternate = walkAST(ast.alternate, before, after, options);
            break;
        case 'Include':
            walkAST(ast.block, before, after, options);
            walkAST(ast.file, before, after, options);
            break;
        case 'Extends':
            walkAST(ast.file, before, after, options);
            break;
        case 'RawInclude':
            ast.filters = walkAndMergeNodes(ast.filters);
            walkAST(ast.file, before, after, options);
            break;
        case 'Attrs':
        case 'BlockComment':
        case 'Comment':
        case 'Doctype':
        case 'IncludeFilter':
        case 'MixinBlock':
        case 'YieldBlock':
        case 'Text':
            break;
        case 'FileReference':
            if (options.includeDependencies && ast.ast) walkAST(ast.ast, before, after, options);
            break;
        default:
            throw new Error('Unexpected node type ' + ast.type);
    }
    parents.shift();
    after && after(ast, replace1);
    function walkAndMergeNodes(nodes1) {
        return nodes1.reduce(function(nodes, node) {
            var result = walkAST(node, before, after, options);
            if (Array.isArray(result)) {
                return nodes.concat(result);
            } else {
                return nodes.concat([
                    result
                ]);
            }
        }, []);
    }
    return ast;
}

},{}],"ejdey":[function(require,module,exports) {
'use strict';
exports.runFilter = require('./lib/run-filter');
exports.handleFilters = require('./lib/handle-filters');

},{"./lib/run-filter":"5MFpZ","./lib/handle-filters":"1tHC6"}],"5MFpZ":[function(require,module,exports) {
var process = require("process");
'use strict';
var jstransformer = require('jstransformer');
var resolve = require('resolve');
module.exports = filter;
function getMinifyTransformerName(outputFormat) {
    switch(outputFormat){
        case 'js':
            return 'uglify-js';
        case 'css':
            return 'clean-css';
    }
}
function filter(name, str, options, currentDirectory, funcName) {
    funcName = funcName || 'render';
    var trPath;
    try {
        try {
            trPath = resolve.sync('jstransformer-' + name, {
                basedir: currentDirectory || process.cwd()
            });
        } catch (ex) {
            trPath = undefined('jstransformer-' + name);
        }
    } catch (ex) {
        var err = new Error('unknown filter ":' + name + '"');
        err.code = 'UNKNOWN_FILTER';
        throw err;
    }
    var tr = jstransformer(require(trPath));
    // TODO: we may want to add a way for people to separately specify "locals"
    var result = tr[funcName](str, options, options).body;
    if (options && options.minify) {
        var minifyTranformer = getMinifyTransformerName(tr.outputFormat);
        if (minifyTranformer) try {
            result = filter(minifyTranformer, result, null, currentDirectory);
        } catch (ex) {
        // better to fail to minify than output nothing
        }
    }
    return result;
}

},{"process":"lDnB8","jstransformer":"2Qwsq","resolve":"3T1cg"}],"2Qwsq":[function(require,module,exports) {
'use strict';
var fs = require('fs');
var assert = require('assert');
var Promise = require('promise');
var isPromise = require('is-promise');
var tr1 = module.exports = function(transformer) {
    return new Transformer(transformer);
};
tr1.Transformer = Transformer;
tr1.normalizeFn = normalizeFn;
tr1.normalizeFnAsync = normalizeFnAsync;
tr1.normalize = normalize;
tr1.normalizeAsync = normalizeAsync;
if (fs.readFile) {
    tr1.readFile = Promise.denodeify(fs.readFile);
    tr1.readFileSync = fs.readFileSync;
} else {
    tr1.readFile = function() {
        throw new Error('fs.readFile unsupported');
    };
    tr1.readFileSync = function() {
        throw new Error('fs.readFileSync unsupported');
    };
}
function normalizeFn(result) {
    if (typeof result === 'function') return {
        fn: result,
        dependencies: []
    };
    else if (result && typeof result === 'object' && typeof result.fn === 'function') {
        if ('dependencies' in result) {
            if (!Array.isArray(result.dependencies)) throw new Error('Result should have a dependencies property that is an array');
        } else result.dependencies = [];
        return result;
    } else throw new Error('Invalid result object from transform.');
}
function normalizeFnAsync(result1, cb) {
    return Promise.resolve(result1).then(function(result) {
        if (result && isPromise(result.fn)) return result.fn.then(function(fn) {
            result.fn = fn;
            return result;
        });
        return result;
    }).then(tr1.normalizeFn).nodeify(cb);
}
function normalize(result) {
    if (typeof result === 'string') return {
        body: result,
        dependencies: []
    };
    else if (result && typeof result === 'object' && typeof result.body === 'string') {
        if ('dependencies' in result) {
            if (!Array.isArray(result.dependencies)) throw new Error('Result should have a dependencies property that is an array');
        } else result.dependencies = [];
        return result;
    } else throw new Error('Invalid result object from transform.');
}
function normalizeAsync(result2, cb) {
    return Promise.resolve(result2).then(function(result) {
        if (result && isPromise(result.body)) return result.body.then(function(body) {
            result.body = body;
            return result;
        });
        return result;
    }).then(tr1.normalize).nodeify(cb);
}
function Transformer(tr) {
    assert(tr, 'Transformer must be an object');
    assert(typeof tr.name === 'string', 'Transformer must have a name');
    assert(typeof tr.outputFormat === 'string', 'Transformer must have an output format');
    assert([
        'compile',
        'compileAsync',
        'compileFile',
        'compileFileAsync',
        'compileClient',
        'compileClientAsync',
        'compileFileClient',
        'compileFileClientAsync',
        'render',
        'renderAsync',
        'renderFile',
        'renderFileAsync'
    ].some(function(method) {
        return typeof tr[method] === 'function';
    }), 'Transformer must implement at least one of the potential methods.');
    this._tr = tr;
    this.name = this._tr.name;
    this.outputFormat = this._tr.outputFormat;
    this.inputFormats = this._tr.inputFormats || [
        this.name
    ];
}
var fallbacks = {
    compile: [
        'compile',
        'render'
    ],
    compileAsync: [
        'compileAsync',
        'compile',
        'render'
    ],
    compileFile: [
        'compileFile',
        'compile',
        'renderFile',
        'render'
    ],
    compileFileAsync: [
        'compileFileAsync',
        'compileFile',
        'compileAsync',
        'compile',
        'renderFile',
        'render'
    ],
    compileClient: [
        'compileClient'
    ],
    compileClientAsync: [
        'compileClientAsync',
        'compileClient'
    ],
    compileFileClient: [
        'compileFileClient',
        'compileClient'
    ],
    compileFileClientAsync: [
        'compileFileClientAsync',
        'compileFileClient',
        'compileClientAsync',
        'compileClient'
    ],
    render: [
        'render',
        'compile'
    ],
    renderAsync: [
        'renderAsync',
        'render',
        'compileAsync',
        'compile'
    ],
    renderFile: [
        'renderFile',
        'render',
        'compileFile',
        'compile'
    ],
    renderFileAsync: [
        'renderFileAsync',
        'renderFile',
        'renderAsync',
        'render',
        'compileFileAsync',
        'compileFile',
        'compileAsync',
        'compile'
    ]
};
Transformer.prototype._hasMethod = function(method) {
    return typeof this._tr[method] === 'function';
};
Transformer.prototype.can = function(method1) {
    return fallbacks[method1].some((function(method) {
        return this._hasMethod(method);
    }).bind(this));
};
/* COMPILE */ Transformer.prototype.compile = function(str, options) {
    if (!this._hasMethod('compile')) {
        if (this.can('render')) {
            var _this = this;
            return {
                fn: function(locals) {
                    return tr1.normalize(_this._tr.render(str, options, locals)).body;
                },
                dependencies: []
            };
        }
        if (this.can('compileAsync')) throw new Error('The Transform "' + this.name + '" does not support synchronous compilation');
        else if (this.can('compileFileAsync')) throw new Error('The Transform "' + this.name + '" does not support compiling plain strings');
        else throw new Error('The Transform "' + this.name + '" does not support compilation');
    }
    return tr1.normalizeFn(this._tr.compile(str, options));
};
Transformer.prototype.compileAsync = function(str, options, cb) {
    if (!this.can('compileAsync')) return Promise.reject(new Error('The Transform "' + this.name + '" does not support compiling plain strings')).nodeify(cb);
    if (this._hasMethod('compileAsync')) return tr1.normalizeFnAsync(this._tr.compileAsync(str, options), cb);
    else return tr1.normalizeFnAsync(this.compile(str, options), cb);
};
Transformer.prototype.compileFile = function(filename, options) {
    if (!this.can('compileFile')) throw new Error('The Transform "' + this.name + '" does not support synchronous compilation');
    if (this._hasMethod('compileFile')) return tr1.normalizeFn(this._tr.compileFile(filename, options));
    else if (this._hasMethod('renderFile')) return tr1.normalizeFn((function(locals) {
        return tr1.normalize(this._tr.renderFile(filename, options, locals)).body;
    }).bind(this));
    else {
        if (!options) options = {
        };
        if (options.filename === undefined) options.filename = filename;
        return this.compile(tr1.readFileSync(filename, 'utf8'), options);
    }
};
Transformer.prototype.compileFileAsync = function(filename, options, cb) {
    if (!this.can('compileFileAsync')) return Promise.reject(new Error('The Transform "' + this.name + '" does not support compilation'));
    if (this._hasMethod('compileFileAsync')) return tr1.normalizeFnAsync(this._tr.compileFileAsync(filename, options), cb);
    else if (this._hasMethod('compileFile') || this._hasMethod('renderFile')) return tr1.normalizeFnAsync(this.compileFile(filename, options), cb);
    else {
        if (!options) options = {
        };
        if (options.filename === undefined) options.filename = filename;
        return tr1.normalizeFnAsync(tr1.readFile(filename, 'utf8').then((function(str) {
            if (this._hasMethod('compileAsync')) return this._tr.compileAsync(str, options);
            else return this.compile(str, options);
        }).bind(this)), cb);
    }
};
/* COMPILE CLIENT */ Transformer.prototype.compileClient = function(str, options) {
    if (!this.can('compileClient')) {
        if (this.can('compileClientAsync')) throw new Error('The Transform "' + this.name + '" does not support compiling for the client synchronously.');
        else if (this.can('compileFileClientAsync')) throw new Error('The Transform "' + this.name + '" does not support compiling for the client from a string.');
        else throw new Error('The Transform "' + this.name + '" does not support compiling for the client');
    }
    return tr1.normalize(this._tr.compileClient(str, options));
};
Transformer.prototype.compileClientAsync = function(str, options, cb) {
    if (!this.can('compileClientAsync')) {
        if (this.can('compileFileClientAsync')) return Promise.reject(new Error('The Transform "' + this.name + '" does not support compiling for the client from a string.')).nodeify(cb);
        else return Promise.reject(new Error('The Transform "' + this.name + '" does not support compiling for the client')).nodeify(cb);
    }
    if (this._hasMethod('compileClientAsync')) return tr1.normalizeAsync(this._tr.compileClientAsync(str, options), cb);
    else return tr1.normalizeAsync(this._tr.compileClient(str, options), cb);
};
Transformer.prototype.compileFileClient = function(filename, options) {
    if (!this.can('compileFileClient')) {
        if (this.can('compileFileClientAsync')) throw new Error('The Transform "' + this.name + '" does not support compiling for the client synchronously.');
        else throw new Error('The Transform "' + this.name + '" does not support compiling for the client');
    }
    if (this._hasMethod('compileFileClient')) return tr1.normalize(this._tr.compileFileClient(filename, options));
    else {
        if (!options) options = {
        };
        if (options.filename === undefined) options.filename = filename;
        return tr1.normalize(this._tr.compileClient(tr1.readFileSync(filename, 'utf8'), options));
    }
};
Transformer.prototype.compileFileClientAsync = function(filename, options, cb) {
    if (!this.can('compileFileClientAsync')) return Promise.reject(new Error('The Transform "' + this.name + '" does not support compiling for the client')).nodeify(cb);
    if (this._hasMethod('compileFileClientAsync')) return tr1.normalizeAsync(this._tr.compileFileClientAsync(filename, options), cb);
    else if (this._hasMethod('compileFileClient')) return tr1.normalizeAsync(this._tr.compileFileClient(filename, options), cb);
    else {
        if (!options) options = {
        };
        if (options.filename === undefined) options.filename = filename;
        return tr1.normalizeAsync(tr1.readFile(filename, 'utf8').then((function(str) {
            if (this._hasMethod('compileClientAsync')) return this._tr.compileClientAsync(str, options);
            else return this._tr.compileClient(str, options);
        }).bind(this)), cb);
    }
};
/* RENDER */ Transformer.prototype.render = function(str, options, locals) {
    if (!this.can('render')) {
        if (this.can('renderAsync')) throw new Error('The Transform "' + this.name + '" does not support rendering synchronously.');
        else if (this.can('renderFileAsync')) throw new Error('The Transform "' + this.name + '" does not support rendering from a string.');
        else throw new Error('The Transform "' + this.name + '" does not support rendering');
    }
    if (this._hasMethod('render')) return tr1.normalize(this._tr.render(str, options, locals));
    else {
        var compiled = tr1.normalizeFn(this._tr.compile(str, options));
        var body = compiled.fn(locals || options);
        if (typeof body !== 'string') throw new Error('The Transform "' + this.name + '" does not support rendering synchronously.');
        return tr1.normalize({
            body: body,
            dependencies: compiled.dependencies
        });
    }
};
Transformer.prototype.renderAsync = function(str, options, locals, cb) {
    if (typeof locals === 'function') {
        cb = locals;
        locals = options;
    }
    if (!this.can('renderAsync')) {
        if (this.can('renderFileAsync')) return Promise.reject(new Error('The Transform "' + this.name + '" does not support rendering from a string.')).nodeify(cb);
        else return Promise.reject(new Error('The Transform "' + this.name + '" does not support rendering')).nodeify(cb);
    }
    if (this._hasMethod('renderAsync')) return tr1.normalizeAsync(this._tr.renderAsync(str, options, locals), cb);
    else if (this._hasMethod('render')) return tr1.normalizeAsync(this._tr.render(str, options, locals), cb);
    else return tr1.normalizeAsync(this.compileAsync(str, options).then(function(compiled) {
        return {
            body: compiled.fn(locals || options),
            dependencies: compiled.dependencies
        };
    }), cb);
};
Transformer.prototype.renderFile = function(filename, options, locals) {
    if (!this.can('renderFile')) throw new Error('The Transform "' + this.name + '" does not support rendering synchronously.');
    if (this._hasMethod('renderFile')) return tr1.normalize(this._tr.renderFile(filename, options, locals));
    else if (this._hasMethod('render')) {
        if (!options) options = {
        };
        if (options.filename === undefined) options.filename = filename;
        return tr1.normalize(this._tr.render(tr1.readFileSync(filename, 'utf8'), options, locals));
    } else {
        var compiled = this.compileFile(filename, options);
        return tr1.normalize({
            body: compiled.fn(locals || options),
            dependencies: compiled.dependencies
        });
    }
};
Transformer.prototype.renderFileAsync = function(filename, options, locals, cb) {
    if (!this.can('renderFileAsync')) throw new Error('The Transform "' + this.name + '" does not support rendering.');
    if (typeof locals === 'function') {
        cb = locals;
        locals = options;
    }
    if (this._hasMethod('renderFileAsync')) return tr1.normalizeAsync(this._tr.renderFileAsync(filename, options, locals), cb);
    else if (this._hasMethod('renderFile')) return tr1.normalizeAsync(this._tr.renderFile(filename, options, locals), cb);
    else if (this._hasMethod('compile') || this._hasMethod('compileAsync') || this._hasMethod('compileFile') || this._hasMethod('compileFileAsync')) return tr1.normalizeAsync(this.compileFileAsync(filename, options).then(function(compiled) {
        return {
            body: compiled.fn(locals || options),
            dependencies: compiled.dependencies
        };
    }), cb);
    else {
        if (!options) options = {
        };
        if (options.filename === undefined) options.filename = filename;
        return tr1.normalizeAsync(tr1.readFile(filename, 'utf8').then((function(str) {
            return this.renderAsync(str, options, locals);
        }).bind(this)), cb);
    }
};

},{"fs":"joWnX","assert":"bTbxk","promise":"lzlBh","is-promise":"iMPHG"}],"lzlBh":[function(require,module,exports) {
'use strict';
module.exports = require('./lib');

},{"./lib":"8UbeC"}],"8UbeC":[function(require,module,exports) {
'use strict';
module.exports = require('./core.js');
require('./done.js');
require('./finally.js');
require('./es6-extensions.js');
require('./node-extensions.js');
require('./synchronous.js');

},{"./core.js":"a1HMb","./done.js":"6eL24","./finally.js":"262xL","./es6-extensions.js":"3Go1e","./node-extensions.js":"f3K8i","./synchronous.js":"6eLcF"}],"a1HMb":[function(require,module,exports) {
'use strict';
var asap = require('asap/raw');
function noop() {
}
// States:
//
// 0 - pending
// 1 - fulfilled with _value
// 2 - rejected with _value
// 3 - adopted the state of another promise, _value
//
// once the state is no longer pending (0) it is immutable
// All `_` prefixed properties will be reduced to `_{random number}`
// at build time to obfuscate them and discourage their use.
// We don't use symbols or Object.defineProperty to fully hide them
// because the performance isn't good enough.
// to avoid using try/catch inside critical functions, we
// extract them to here.
var LAST_ERROR = null;
var IS_ERROR = {
};
function getThen(obj) {
    try {
        return obj.then;
    } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
    }
}
function tryCallOne(fn, a) {
    try {
        return fn(a);
    } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
    }
}
function tryCallTwo(fn, a, b) {
    try {
        fn(a, b);
    } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
    }
}
module.exports = Promise;
function Promise(fn) {
    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('Promise constructor\'s argument is not a function');
    this._40 = 0;
    this._65 = 0;
    this._55 = null;
    this._72 = null;
    if (fn === noop) return;
    doResolve(fn, this);
}
Promise._37 = null;
Promise._87 = null;
Promise._61 = noop;
Promise.prototype.then = function(onFulfilled, onRejected) {
    if (this.constructor !== Promise) return safeThen(this, onFulfilled, onRejected);
    var res = new Promise(noop);
    handle(this, new Handler(onFulfilled, onRejected, res));
    return res;
};
function safeThen(self, onFulfilled, onRejected) {
    return new self.constructor(function(resolve, reject) {
        var res = new Promise(noop);
        res.then(resolve, reject);
        handle(self, new Handler(onFulfilled, onRejected, res));
    });
}
function handle(self, deferred) {
    while(self._65 === 3)self = self._55;
    if (Promise._37) Promise._37(self);
    if (self._65 === 0) {
        if (self._40 === 0) {
            self._40 = 1;
            self._72 = deferred;
            return;
        }
        if (self._40 === 1) {
            self._40 = 2;
            self._72 = [
                self._72,
                deferred
            ];
            return;
        }
        self._72.push(deferred);
        return;
    }
    handleResolved(self, deferred);
}
function handleResolved(self, deferred) {
    asap(function() {
        var cb = self._65 === 1 ? deferred.onFulfilled : deferred.onRejected;
        if (cb === null) {
            if (self._65 === 1) resolve1(deferred.promise, self._55);
            else reject1(deferred.promise, self._55);
            return;
        }
        var ret = tryCallOne(cb, self._55);
        if (ret === IS_ERROR) reject1(deferred.promise, LAST_ERROR);
        else resolve1(deferred.promise, ret);
    });
}
function resolve1(self, newValue) {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self) return reject1(self, new TypeError('A promise cannot be resolved with itself.'));
    if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = getThen(newValue);
        if (then === IS_ERROR) return reject1(self, LAST_ERROR);
        if (then === self.then && newValue instanceof Promise) {
            self._65 = 3;
            self._55 = newValue;
            finale(self);
            return;
        } else if (typeof then === 'function') {
            doResolve(then.bind(newValue), self);
            return;
        }
    }
    self._65 = 1;
    self._55 = newValue;
    finale(self);
}
function reject1(self, newValue) {
    self._65 = 2;
    self._55 = newValue;
    if (Promise._87) Promise._87(self, newValue);
    finale(self);
}
function finale(self) {
    if (self._40 === 1) {
        handle(self, self._72);
        self._72 = null;
    }
    if (self._40 === 2) {
        for(var i = 0; i < self._72.length; i++)handle(self, self._72[i]);
        self._72 = null;
    }
}
function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
}
/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */ function doResolve(fn, promise) {
    var done = false;
    var res = tryCallTwo(fn, function(value) {
        if (done) return;
        done = true;
        resolve1(promise, value);
    }, function(reason) {
        if (done) return;
        done = true;
        reject1(promise, reason);
    });
    if (!done && res === IS_ERROR) {
        done = true;
        reject1(promise, LAST_ERROR);
    }
}

},{"asap/raw":"dVnzp"}],"dVnzp":[function(require,module,exports) {
var global = arguments[3];
"use strict";
// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including IO, animation, reflow, and redraw
// events in browsers.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Equivalent to push, but avoids a function call.
    queue[queue.length] = task;
}
var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// `requestFlush` is an implementation-specific method that attempts to kick
// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
// the event queue before yielding to the browser's own event loop.
var requestFlush;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory exhaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;
// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while(index < queue.length){
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for(var scan = 0, newLength = queue.length - index; scan < newLength; scan++)queue[scan] = queue[scan + index];
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}
// `requestFlush` is implemented using a strategy based on data collected from
// every available SauceLabs Selenium web driver worker at time of writing.
// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593
// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` or `self` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
/* globals self */ var scope = typeof global !== "undefined" ? global : self;
var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
// MutationObservers are desirable because they have high priority and work
// reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
if (typeof BrowserMutationObserver === "function") requestFlush = makeRequestCallFromMutationObserver(flush);
else requestFlush = makeRequestCallFromTimer(flush);
// `requestFlush` requests that the high priority event queue be flushed as
// soon as possible.
// This is useful to prevent an error thrown in a task from stalling the event
// queue if the exception handled by Node.js’s
// `process.on("uncaughtException")` or by a domain.
rawAsap.requestFlush = requestFlush;
// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    var toggle = 1;
    var observer = new BrowserMutationObserver(callback);
    var node = document.createTextNode("");
    observer.observe(node, {
        characterData: true
    });
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}
// The message channel technique was discovered by Malte Ubl and was the
// original foundation for this library.
// http://www.nonblocking.io/2011/06/windownexttick.html
// Safari 6.0.5 (at least) intermittently fails to create message ports on a
// page's first load. Thankfully, this version of Safari supports
// MutationObservers, so we don't need to fall back in that case.
// function makeRequestCallFromMessageChannel(callback) {
//     var channel = new MessageChannel();
//     channel.port1.onmessage = callback;
//     return function requestCall() {
//         channel.port2.postMessage(0);
//     };
// }
// For reasons explained above, we are also unable to use `setImmediate`
// under any circumstances.
// Even if we were, there is another bug in Internet Explorer 10.
// It is not sufficient to assign `setImmediate` to `requestFlush` because
// `setImmediate` must be called *by name* and therefore must be wrapped in a
// closure.
// Never forget.
// function makeRequestCallFromSetImmediate(callback) {
//     return function requestCall() {
//         setImmediate(callback);
//     };
// }
// Safari 6.0 has a problem where timers will get lost while the user is
// scrolling. This problem does not impact ASAP because Safari 6.0 supports
// mutation observers, so that implementation is used instead.
// However, if we ever elect to use timers in Safari, the prevalent work-around
// is to add a scroll event listener that calls for a flush.
// `setTimeout` does not call the passed callback if the delay is less than
// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
// even then.
function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        var timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        var intervalHandle = setInterval(handleTimer, 50);
        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}
// This is for `asap.js` only.
// Its name will be periodically randomized to break any code that depends on
// its existence.
rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer; // ASAP was originally a nextTick shim included in Q. This was factored out
 // into this ASAP package. It was later adapted to RSVP which made further
 // amendments. These decisions, particularly to marginalize MessageChannel and
 // to capture the MutationObserver implementation in a closure, were integrated
 // back into ASAP proper.
 // https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

},{}],"6eL24":[function(require,module,exports) {
'use strict';
var Promise = require('./core.js');
module.exports = Promise;
Promise.prototype.done = function(onFulfilled, onRejected) {
    var self = arguments.length ? this.then.apply(this, arguments) : this;
    self.then(null, function(err) {
        setTimeout(function() {
            throw err;
        }, 0);
    });
};

},{"./core.js":"a1HMb"}],"262xL":[function(require,module,exports) {
'use strict';
var Promise = require('./core.js');
module.exports = Promise;
Promise.prototype['finally'] = function(f) {
    return this.then(function(value) {
        return Promise.resolve(f()).then(function() {
            return value;
        });
    }, function(err) {
        return Promise.resolve(f()).then(function() {
            throw err;
        });
    });
};

},{"./core.js":"a1HMb"}],"3Go1e":[function(require,module,exports) {
'use strict';
//This file contains the ES6 extensions to the core Promises/A+ API
var Promise = require('./core.js');
module.exports = Promise;
/* Static Functions */ var TRUE = valuePromise(true);
var FALSE = valuePromise(false);
var NULL = valuePromise(null);
var UNDEFINED = valuePromise(undefined);
var ZERO = valuePromise(0);
var EMPTYSTRING = valuePromise('');
function valuePromise(value) {
    var p = new Promise(Promise._61);
    p._65 = 1;
    p._55 = value;
    return p;
}
Promise.resolve = function(value) {
    if (value instanceof Promise) return value;
    if (value === null) return NULL;
    if (value === undefined) return UNDEFINED;
    if (value === true) return TRUE;
    if (value === false) return FALSE;
    if (value === 0) return ZERO;
    if (value === '') return EMPTYSTRING;
    if (typeof value === 'object' || typeof value === 'function') try {
        var then = value.then;
        if (typeof then === 'function') return new Promise(then.bind(value));
    } catch (ex) {
        return new Promise(function(resolve, reject) {
            reject(ex);
        });
    }
    return valuePromise(value);
};
Promise.all = function(arr) {
    var args = Array.prototype.slice.call(arr);
    return new Promise(function(resolve, reject) {
        if (args.length === 0) return resolve([]);
        var remaining = args.length;
        function res(i, val1) {
            if (val1 && (typeof val1 === 'object' || typeof val1 === 'function')) {
                if (val1 instanceof Promise && val1.then === Promise.prototype.then) {
                    while(val1._65 === 3)val1 = val1._55;
                    if (val1._65 === 1) return res(i, val1._55);
                    if (val1._65 === 2) reject(val1._55);
                    val1.then(function(val) {
                        res(i, val);
                    }, reject);
                    return;
                } else {
                    var then = val1.then;
                    if (typeof then === 'function') {
                        var p = new Promise(then.bind(val1));
                        p.then(function(val) {
                            res(i, val);
                        }, reject);
                        return;
                    }
                }
            }
            args[i] = val1;
            if (--remaining === 0) resolve(args);
        }
        for(var i1 = 0; i1 < args.length; i1++)res(i1, args[i1]);
    });
};
Promise.reject = function(value) {
    return new Promise(function(resolve, reject) {
        reject(value);
    });
};
Promise.race = function(values) {
    return new Promise(function(resolve, reject) {
        values.forEach(function(value) {
            Promise.resolve(value).then(resolve, reject);
        });
    });
};
/* Prototype Methods */ Promise.prototype['catch'] = function(onRejected) {
    return this.then(null, onRejected);
};

},{"./core.js":"a1HMb"}],"f3K8i":[function(require,module,exports) {
'use strict';
// This file contains then/promise specific extensions that are only useful
// for node.js interop
var Promise = require('./core.js');
var asap = require('asap');
module.exports = Promise;
/* Static Functions */ Promise.denodeify = function(fn, argumentCount) {
    if (typeof argumentCount === 'number' && argumentCount !== Infinity) return denodeifyWithCount(fn, argumentCount);
    else return denodeifyWithoutCount(fn);
};
var callbackFn = "function (err, res) {if (err) { rj(err); } else { rs(res); }}";
function denodeifyWithCount(fn, argumentCount) {
    var args = [];
    for(var i = 0; i < argumentCount; i++)args.push('a' + i);
    var body = [
        'return function (' + args.join(',') + ') {',
        'var self = this;',
        'return new Promise(function (rs, rj) {',
        'var res = fn.call(',
        [
            'self'
        ].concat(args).concat([
            callbackFn
        ]).join(','),
        ');',
        'if (res &&',
        '(typeof res === "object" || typeof res === "function") &&',
        'typeof res.then === "function"',
        ') {rs(res);}',
        '});',
        '};'
    ].join('');
    return Function([
        'Promise',
        'fn'
    ], body)(Promise, fn);
}
function denodeifyWithoutCount(fn) {
    var fnLength = Math.max(fn.length - 1, 3);
    var args = [];
    for(var i = 0; i < fnLength; i++)args.push('a' + i);
    var body = [
        'return function (' + args.join(',') + ') {',
        'var self = this;',
        'var args;',
        'var argLength = arguments.length;',
        'if (arguments.length > ' + fnLength + ') {',
        'args = new Array(arguments.length + 1);',
        'for (var i = 0; i < arguments.length; i++) {',
        'args[i] = arguments[i];',
        '}',
        '}',
        'return new Promise(function (rs, rj) {',
        'var cb = ' + callbackFn + ';',
        'var res;',
        'switch (argLength) {',
        args.concat([
            'extra'
        ]).map(function(_, index) {
            return 'case ' + index + ':' + 'res = fn.call(' + [
                'self'
            ].concat(args.slice(0, index)).concat('cb').join(',') + ');' + 'break;';
        }).join(''),
        'default:',
        'args[argLength] = cb;',
        'res = fn.apply(self, args);',
        '}',
        'if (res &&',
        '(typeof res === "object" || typeof res === "function") &&',
        'typeof res.then === "function"',
        ') {rs(res);}',
        '});',
        '};'
    ].join('');
    return Function([
        'Promise',
        'fn'
    ], body)(Promise, fn);
}
Promise.nodeify = function(fn) {
    return function() {
        var args = Array.prototype.slice.call(arguments);
        var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null;
        var ctx = this;
        try {
            return fn.apply(this, arguments).nodeify(callback, ctx);
        } catch (ex) {
            if (callback === null || typeof callback == 'undefined') return new Promise(function(resolve, reject) {
                reject(ex);
            });
            else asap(function() {
                callback.call(ctx, ex);
            });
        }
    };
};
Promise.prototype.nodeify = function(callback, ctx) {
    if (typeof callback != 'function') return this;
    this.then(function(value) {
        asap(function() {
            callback.call(ctx, null, value);
        });
    }, function(err) {
        asap(function() {
            callback.call(ctx, err);
        });
    });
};

},{"./core.js":"a1HMb","asap":"aYUXa"}],"aYUXa":[function(require,module,exports) {
"use strict";
// rawAsap provides everything we need except exception management.
var rawAsap = require("./raw");
// RawTasks are recycled to reduce GC churn.
var freeTasks = [];
// We queue errors to ensure they are thrown in right order (FIFO).
// Array-as-queue is good enough here, since we are just dealing with exceptions.
var pendingErrors = [];
var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);
function throwFirstError() {
    if (pendingErrors.length) throw pendingErrors.shift();
}
/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */ module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) rawTask = freeTasks.pop();
    else rawTask = new RawTask();
    rawTask.task = task;
    rawAsap(rawTask);
}
// We wrap tasks with recyclable task objects.  A task object implements
// `call`, just like a function.
function RawTask() {
    this.task = null;
}
// The sole purpose of wrapping the task is to catch the exception and recycle
// the task object after its single use.
RawTask.prototype.call = function() {
    try {
        this.task.call();
    } catch (error) {
        if (asap.onerror) // This hook exists purely for testing purposes.
        // Its name will be periodically randomized to break any code that
        // depends on its existence.
        asap.onerror(error);
        else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
        }
    } finally{
        this.task = null;
        freeTasks[freeTasks.length] = this;
    }
};

},{"./raw":"dVnzp"}],"6eLcF":[function(require,module,exports) {
'use strict';
var Promise = require('./core.js');
module.exports = Promise;
Promise.enableSynchronous = function() {
    Promise.prototype.isPending = function() {
        return this.getState() == 0;
    };
    Promise.prototype.isFulfilled = function() {
        return this.getState() == 1;
    };
    Promise.prototype.isRejected = function() {
        return this.getState() == 2;
    };
    Promise.prototype.getValue = function() {
        if (this._65 === 3) return this._55.getValue();
        if (!this.isFulfilled()) throw new Error('Cannot get a value of an unfulfilled promise.');
        return this._55;
    };
    Promise.prototype.getReason = function() {
        if (this._65 === 3) return this._55.getReason();
        if (!this.isRejected()) throw new Error('Cannot get a rejection reason of a non-rejected promise.');
        return this._55;
    };
    Promise.prototype.getState = function() {
        if (this._65 === 3) return this._55.getState();
        if (this._65 === -1 || this._65 === -2) return 0;
        return this._65;
    };
};
Promise.disableSynchronous = function() {
    Promise.prototype.isPending = undefined;
    Promise.prototype.isFulfilled = undefined;
    Promise.prototype.isRejected = undefined;
    Promise.prototype.getValue = undefined;
    Promise.prototype.getReason = undefined;
    Promise.prototype.getState = undefined;
};

},{"./core.js":"a1HMb"}],"iMPHG":[function(require,module,exports) {
module.exports = isPromise;
module.exports.default = isPromise;
function isPromise(obj) {
    return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}

},{}],"3T1cg":[function(require,module,exports) {
var async = require('./lib/async');
async.core = require('./lib/core');
async.isCore = require('./lib/is-core');
async.sync = require('./lib/sync');
module.exports = async;

},{"./lib/async":"lFWMJ","./lib/core":"g84dh","./lib/is-core":"98qKi","./lib/sync":"6d4IG"}],"lFWMJ":[function(require,module,exports) {
var process = require("process");
var fs = require('fs');
var path = require('path');
var caller = require('./caller');
var nodeModulesPaths = require('./node-modules-paths');
var normalizeOptions = require('./normalize-options');
var isCore = require('is-core-module');
var realpathFS = fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;
var defaultIsFile = function isFile(file, cb) {
    fs.stat(file, function(err, stat) {
        if (!err) return cb(null, stat.isFile() || stat.isFIFO());
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};
var defaultIsDir = function isDirectory(dir, cb) {
    fs.stat(dir, function(err, stat) {
        if (!err) return cb(null, stat.isDirectory());
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};
var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr);
        else cb(null, realpathErr ? x : realPath);
    });
};
var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) realpath(x, cb);
    else cb(null, x);
};
var defaultReadPackage = function defaultReadPackage(readFile, pkgfile, cb) {
    readFile(pkgfile, function(readFileErr, body) {
        if (readFileErr) cb(readFileErr);
        else try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
        } catch (jsonErr) {
            cb(null);
        }
    });
};
var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for(var i = 0; i < dirs.length; i++)dirs[i] = path.join(dirs[i], x);
    return dirs;
};
module.exports = function resolve(x1, options, callback1) {
    var cb1 = callback1;
    var opts = options;
    if (typeof options === 'function') {
        cb1 = opts;
        opts = {
        };
    }
    if (typeof x1 !== 'string') {
        var err = new TypeError('Path must be a string.');
        return process.nextTick(function() {
            cb1(err);
        });
    }
    opts = normalizeOptions(x1, opts);
    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var readPackage = opts.readPackage || defaultReadPackage;
    if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError('`readFile` and `readPackage` are mutually exclusive.');
        return process.nextTick(function() {
            cb1(conflictErr);
        });
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [
        '.js'
    ];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir1 = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir1;
    opts.paths = opts.paths || [];
    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = path.resolve(basedir1);
    maybeRealpath(realpath, absoluteStart, opts, function(err, realStart) {
        if (err) cb1(err);
        else init(realStart);
    });
    var res;
    function init(basedir) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x1)) {
            res = path.resolve(basedir, x1);
            if (x1 === '.' || x1 === '..' || x1.slice(-1) === '/') res += '/';
            if (/\/$/.test(x1) && res === basedir) loadAsDirectory(res, opts.package, onfile1);
            else loadAsFile(res, opts.package, onfile1);
        } else if (includeCoreModules && isCore(x1)) return cb1(null, x1);
        else loadNodeModules(x1, basedir, function(err1, n, pkg) {
            if (err1) cb1(err1);
            else if (n) return maybeRealpath(realpath, n, opts, function(err, realN) {
                if (err) cb1(err);
                else cb1(null, realN, pkg);
            });
            else {
                var moduleError = new Error("Cannot find module '" + x1 + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb1(moduleError);
            }
        });
    }
    function onfile1(err2, m, pkg1) {
        if (err2) cb1(err2);
        else if (m) cb1(null, m, pkg1);
        else loadAsDirectory(res, function(err3, d, pkg) {
            if (err3) cb1(err3);
            else if (d) maybeRealpath(realpath, d, opts, function(err, realD) {
                if (err) cb1(err);
                else cb1(null, realD, pkg);
            });
            else {
                var moduleError = new Error("Cannot find module '" + x1 + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb1(moduleError);
            }
        });
    }
    function loadAsFile(x2, thePackage, callback) {
        var loadAsFilePackage = thePackage;
        var cb = callback;
        if (typeof loadAsFilePackage === 'function') {
            cb = loadAsFilePackage;
            loadAsFilePackage = undefined;
        }
        var exts1 = [
            ''
        ].concat(extensions);
        load(exts1, x2, loadAsFilePackage);
        function load(exts, x, loadPackage) {
            if (exts.length === 0) return cb(null, undefined, loadPackage);
            var file = x + exts[0];
            var pkg = loadPackage;
            if (pkg) onpkg(null, pkg);
            else loadpkg(path.dirname(file), onpkg);
            function onpkg(err, pkg_, dir) {
                pkg = pkg_;
                if (err) return cb(err);
                if (dir && pkg && opts.pathFilter) {
                    var rfile = path.relative(dir, file);
                    var rel = rfile.slice(0, rfile.length - exts[0].length);
                    var r = opts.pathFilter(pkg, x, rel);
                    if (r) return load([
                        ''
                    ].concat(extensions.slice()), path.resolve(dir, r), pkg);
                }
                isFile(file, onex);
            }
            function onex(err, ex) {
                if (err) return cb(err);
                if (ex) return cb(null, file, pkg);
                load(exts.slice(1), x, pkg);
            }
        }
    }
    function loadpkg(dir, cb) {
        if (dir === '' || dir === '/') return cb(null);
        if (process.platform === 'win32' && /^\w:[/\\]*$/.test(dir)) return cb(null);
        if (/[/\\]node_modules[/\\]*$/.test(dir)) return cb(null);
        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
            if (unwrapErr) return loadpkg(path.dirname(dir), cb);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function(err4, ex) {
                // on err, ex is false
                if (!ex) return loadpkg(path.dirname(dir), cb);
                readPackage(readFile, pkgfile, function(err, pkgParam) {
                    if (err) cb(err);
                    var pkg = pkgParam;
                    if (pkg && opts.packageFilter) pkg = opts.packageFilter(pkg, pkgfile);
                    cb(null, pkg, dir);
                });
            });
        });
    }
    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
        var cb = callback;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === 'function') {
            cb = fpkg;
            fpkg = opts.package;
        }
        maybeRealpath(realpath, x, opts, function(unwrapErr, pkgdir) {
            if (unwrapErr) return cb(unwrapErr);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function(err5, ex) {
                if (err5) return cb(err5);
                if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);
                readPackage(readFile, pkgfile, function(err6, pkgParam) {
                    if (err6) return cb(err6);
                    var pkg2 = pkgParam;
                    if (pkg2 && opts.packageFilter) pkg2 = opts.packageFilter(pkg2, pkgfile);
                    if (pkg2 && pkg2.main) {
                        if (typeof pkg2.main !== 'string') {
                            var mainError = new TypeError('package “' + pkg2.name + '” `main` must be a string');
                            mainError.code = 'INVALID_PACKAGE_MAIN';
                            return cb(mainError);
                        }
                        if (pkg2.main === '.' || pkg2.main === './') pkg2.main = 'index';
                        loadAsFile(path.resolve(x, pkg2.main), pkg2, function(err7, m, pkg3) {
                            if (err7) return cb(err7);
                            if (m) return cb(null, m, pkg3);
                            if (!pkg3) return loadAsFile(path.join(x, 'index'), pkg3, cb);
                            var dir = path.resolve(x, pkg3.main);
                            loadAsDirectory(dir, pkg3, function(err, n, pkg) {
                                if (err) return cb(err);
                                if (n) return cb(null, n, pkg);
                                loadAsFile(path.join(x, 'index'), pkg, cb);
                            });
                        });
                        return;
                    }
                    loadAsFile(path.join(x, '/index'), pkg2, cb);
                });
            });
        });
    }
    function processDirs(cb, dirs) {
        if (dirs.length === 0) return cb(null, undefined);
        var dir = dirs[0];
        isDirectory(path.dirname(dir), isdir1);
        function isdir1(err, isdir) {
            if (err) return cb(err);
            if (!isdir) return processDirs(cb, dirs.slice(1));
            loadAsFile(dir, opts.package, onfile);
        }
        function onfile(err, m, pkg) {
            if (err) return cb(err);
            if (m) return cb(null, m, pkg);
            loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err, n, pkg) {
            if (err) return cb(err);
            if (n) return cb(null, n, pkg);
            processDirs(cb, dirs.slice(1));
        }
    }
    function loadNodeModules(x, start, cb) {
        var thunk = function() {
            return getPackageCandidates(x, start, opts);
        };
        processDirs(cb, packageIterator ? packageIterator(x, start, thunk, opts) : thunk());
    }
};

},{"process":"lDnB8","fs":"joWnX","path":"dTeSu","./caller":"nNQAh","./node-modules-paths":"ctUIJ","./normalize-options":"3kFyi","is-core-module":"1Roii"}],"nNQAh":[function(require,module,exports) {
module.exports = function() {
    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function(_, stack) {
        return stack;
    };
    var stack1 = new Error().stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack1[2].getFileName();
};

},{}],"ctUIJ":[function(require,module,exports) {
var path = require('path');
var parse = path.parse || require('path-parse');
var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = '/';
    if (/^([A-Za-z]:)/.test(absoluteStart)) prefix = '';
    else if (/^\\\\/.test(absoluteStart)) prefix = '\\\\';
    var paths = [
        absoluteStart
    ];
    var parsed = parse(absoluteStart);
    while(parsed.dir !== paths[paths.length - 1]){
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
    }
    return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
            return path.resolve(prefix, aPath, moduleDir);
        }));
    }, []);
};
module.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : [
        'node_modules'
    ];
    if (opts && typeof opts.paths === 'function') return opts.paths(request, start, function() {
        return getNodeModulesDirs(start, modules);
    }, opts);
    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
};

},{"path":"dTeSu","path-parse":"gh2NN"}],"gh2NN":[function(require,module,exports) {
var process = require("process");
'use strict';
var isWindows = process.platform === 'win32';
// Regex to split a windows path into into [dir, root, basename, name, ext]
var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
var win32 = {
};
function win32SplitPath(filename) {
    return splitWindowsRe.exec(filename).slice(1);
}
win32.parse = function(pathString) {
    if (typeof pathString !== 'string') throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    var allParts = win32SplitPath(pathString);
    if (!allParts || allParts.length !== 5) throw new TypeError("Invalid path '" + pathString + "'");
    return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
    };
};
// Split a filename into [dir, root, basename, name, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
var posix = {
};
function posixSplitPath(filename) {
    return splitPathRe.exec(filename).slice(1);
}
posix.parse = function(pathString) {
    if (typeof pathString !== 'string') throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    var allParts = posixSplitPath(pathString);
    if (!allParts || allParts.length !== 5) throw new TypeError("Invalid path '" + pathString + "'");
    return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
    };
};
if (isWindows) module.exports = win32.parse;
else /* posix */ module.exports = posix.parse;
module.exports.posix = posix.parse;
module.exports.win32 = win32.parse;

},{"process":"lDnB8"}],"3kFyi":[function(require,module,exports) {
module.exports = function(x, opts) {
    /**
     * This file is purposefully a passthrough. It's expected that third-party
     * environments will override it at runtime in order to inject special logic
     * into `resolve` (by manipulating the options). One such example is the PnP
     * code path in Yarn.
     */ return opts || {
    };
};

},{}],"1Roii":[function(require,module,exports) {
var process = require("process");
'use strict';
var has = require('has');
function specifierIncluded(current, specifier) {
    var nodeParts = current.split('.');
    var parts = specifier.split(' ');
    var op = parts.length > 1 ? parts[0] : '=';
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');
    for(var i = 0; i < 3; ++i){
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) continue; // eslint-disable-line no-restricted-syntax, no-continue
        if (op === '<') return cur < ver;
        if (op === '>=') return cur >= ver;
        return false;
    }
    return op === '>=';
}
function matchesRange(current, range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) return false;
    for(var i = 0; i < specifiers.length; ++i){
        if (!specifierIncluded(current, specifiers[i])) return false;
    }
    return true;
}
function versionIncluded(nodeVersion, specifierValue) {
    if (typeof specifierValue === 'boolean') return specifierValue;
    var current = typeof nodeVersion === 'undefined' ? process.versions && process.versions.node : nodeVersion;
    if (typeof current !== 'string') throw new TypeError(typeof nodeVersion === 'undefined' ? 'Unable to determine current node version' : 'If provided, a valid node version is required');
    if (specifierValue && typeof specifierValue === 'object') {
        for(var i = 0; i < specifierValue.length; ++i){
            if (matchesRange(current, specifierValue[i])) return true;
        }
        return false;
    }
    return matchesRange(current, specifierValue);
}
var data = require('./core.json');
module.exports = function isCore(x, nodeVersion) {
    return has(data, x) && versionIncluded(nodeVersion, data[x]);
};

},{"process":"lDnB8","has":"6Inba","./core.json":"fTHOi"}],"fTHOi":[function(require,module,exports) {
module.exports = JSON.parse("{\"assert\":true,\"node:assert\":[\">= 14.18 && < 15\",\">= 16\"],\"assert/strict\":\">= 15\",\"node:assert/strict\":\">= 16\",\"async_hooks\":\">= 8\",\"node:async_hooks\":[\">= 14.18 && < 15\",\">= 16\"],\"buffer_ieee754\":\"< 0.9.7\",\"buffer\":true,\"node:buffer\":[\">= 14.18 && < 15\",\">= 16\"],\"child_process\":true,\"node:child_process\":[\">= 14.18 && < 15\",\">= 16\"],\"cluster\":true,\"node:cluster\":[\">= 14.18 && < 15\",\">= 16\"],\"console\":true,\"node:console\":[\">= 14.18 && < 15\",\">= 16\"],\"constants\":true,\"node:constants\":[\">= 14.18 && < 15\",\">= 16\"],\"crypto\":true,\"node:crypto\":[\">= 14.18 && < 15\",\">= 16\"],\"_debug_agent\":\">= 1 && < 8\",\"_debugger\":\"< 8\",\"dgram\":true,\"node:dgram\":[\">= 14.18 && < 15\",\">= 16\"],\"diagnostics_channel\":[\">= 14.17 && < 15\",\">= 15.1\"],\"node:diagnostics_channel\":[\">= 14.18 && < 15\",\">= 16\"],\"dns\":true,\"node:dns\":[\">= 14.18 && < 15\",\">= 16\"],\"dns/promises\":\">= 15\",\"node:dns/promises\":\">= 16\",\"domain\":\">= 0.7.12\",\"node:domain\":[\">= 14.18 && < 15\",\">= 16\"],\"events\":true,\"node:events\":[\">= 14.18 && < 15\",\">= 16\"],\"freelist\":\"< 6\",\"fs\":true,\"node:fs\":[\">= 14.18 && < 15\",\">= 16\"],\"fs/promises\":[\">= 10 && < 10.1\",\">= 14\"],\"node:fs/promises\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_agent\":\">= 0.11.1\",\"node:_http_agent\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_client\":\">= 0.11.1\",\"node:_http_client\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_common\":\">= 0.11.1\",\"node:_http_common\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_incoming\":\">= 0.11.1\",\"node:_http_incoming\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_outgoing\":\">= 0.11.1\",\"node:_http_outgoing\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_server\":\">= 0.11.1\",\"node:_http_server\":[\">= 14.18 && < 15\",\">= 16\"],\"http\":true,\"node:http\":[\">= 14.18 && < 15\",\">= 16\"],\"http2\":\">= 8.8\",\"node:http2\":[\">= 14.18 && < 15\",\">= 16\"],\"https\":true,\"node:https\":[\">= 14.18 && < 15\",\">= 16\"],\"inspector\":\">= 8\",\"node:inspector\":[\">= 14.18 && < 15\",\">= 16\"],\"_linklist\":\"< 8\",\"module\":true,\"node:module\":[\">= 14.18 && < 15\",\">= 16\"],\"net\":true,\"node:net\":[\">= 14.18 && < 15\",\">= 16\"],\"node-inspect/lib/_inspect\":\">= 7.6 && < 12\",\"node-inspect/lib/internal/inspect_client\":\">= 7.6 && < 12\",\"node-inspect/lib/internal/inspect_repl\":\">= 7.6 && < 12\",\"os\":true,\"node:os\":[\">= 14.18 && < 15\",\">= 16\"],\"path\":true,\"node:path\":[\">= 14.18 && < 15\",\">= 16\"],\"path/posix\":\">= 15.3\",\"node:path/posix\":\">= 16\",\"path/win32\":\">= 15.3\",\"node:path/win32\":\">= 16\",\"perf_hooks\":\">= 8.5\",\"node:perf_hooks\":[\">= 14.18 && < 15\",\">= 16\"],\"process\":\">= 1\",\"node:process\":[\">= 14.18 && < 15\",\">= 16\"],\"punycode\":true,\"node:punycode\":[\">= 14.18 && < 15\",\">= 16\"],\"querystring\":true,\"node:querystring\":[\">= 14.18 && < 15\",\">= 16\"],\"readline\":true,\"node:readline\":[\">= 14.18 && < 15\",\">= 16\"],\"readline/promises\":\">= 17\",\"node:readline/promises\":\">= 17\",\"repl\":true,\"node:repl\":[\">= 14.18 && < 15\",\">= 16\"],\"smalloc\":\">= 0.11.5 && < 3\",\"_stream_duplex\":\">= 0.9.4\",\"node:_stream_duplex\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_transform\":\">= 0.9.4\",\"node:_stream_transform\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_wrap\":\">= 1.4.1\",\"node:_stream_wrap\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_passthrough\":\">= 0.9.4\",\"node:_stream_passthrough\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_readable\":\">= 0.9.4\",\"node:_stream_readable\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_writable\":\">= 0.9.4\",\"node:_stream_writable\":[\">= 14.18 && < 15\",\">= 16\"],\"stream\":true,\"node:stream\":[\">= 14.18 && < 15\",\">= 16\"],\"stream/consumers\":\">= 16.7\",\"node:stream/consumers\":\">= 16.7\",\"stream/promises\":\">= 15\",\"node:stream/promises\":\">= 16\",\"stream/web\":\">= 16.5\",\"node:stream/web\":\">= 16.5\",\"string_decoder\":true,\"node:string_decoder\":[\">= 14.18 && < 15\",\">= 16\"],\"sys\":[\">= 0.6 && < 0.7\",\">= 0.8\"],\"node:sys\":[\">= 14.18 && < 15\",\">= 16\"],\"timers\":true,\"node:timers\":[\">= 14.18 && < 15\",\">= 16\"],\"timers/promises\":\">= 15\",\"node:timers/promises\":\">= 16\",\"_tls_common\":\">= 0.11.13\",\"node:_tls_common\":[\">= 14.18 && < 15\",\">= 16\"],\"_tls_legacy\":\">= 0.11.3 && < 10\",\"_tls_wrap\":\">= 0.11.3\",\"node:_tls_wrap\":[\">= 14.18 && < 15\",\">= 16\"],\"tls\":true,\"node:tls\":[\">= 14.18 && < 15\",\">= 16\"],\"trace_events\":\">= 10\",\"node:trace_events\":[\">= 14.18 && < 15\",\">= 16\"],\"tty\":true,\"node:tty\":[\">= 14.18 && < 15\",\">= 16\"],\"url\":true,\"node:url\":[\">= 14.18 && < 15\",\">= 16\"],\"util\":true,\"node:util\":[\">= 14.18 && < 15\",\">= 16\"],\"util/types\":\">= 15.3\",\"node:util/types\":\">= 16\",\"v8/tools/arguments\":\">= 10 && < 12\",\"v8/tools/codemap\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/consarray\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/csvparser\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/logreader\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/profile_view\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/splaytree\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8\":\">= 1\",\"node:v8\":[\">= 14.18 && < 15\",\">= 16\"],\"vm\":true,\"node:vm\":[\">= 14.18 && < 15\",\">= 16\"],\"wasi\":\">= 13.4 && < 13.5\",\"worker_threads\":\">= 11.7\",\"node:worker_threads\":[\">= 14.18 && < 15\",\">= 16\"],\"zlib\":true,\"node:zlib\":[\">= 14.18 && < 15\",\">= 16\"]}");

},{}],"g84dh":[function(require,module,exports) {
var process = require("process");
var current = process.versions && process.versions.node && process.versions.node.split('.') || [];
function specifierIncluded(specifier) {
    var parts = specifier.split(' ');
    var op = parts.length > 1 ? parts[0] : '=';
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');
    for(var i = 0; i < 3; ++i){
        var cur = parseInt(current[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) continue; // eslint-disable-line no-restricted-syntax, no-continue
        if (op === '<') return cur < ver;
        else if (op === '>=') return cur >= ver;
        else return false;
    }
    return op === '>=';
}
function matchesRange(range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) return false;
    for(var i = 0; i < specifiers.length; ++i){
        if (!specifierIncluded(specifiers[i])) return false;
    }
    return true;
}
function versionIncluded(specifierValue) {
    if (typeof specifierValue === 'boolean') return specifierValue;
    if (specifierValue && typeof specifierValue === 'object') {
        for(var i = 0; i < specifierValue.length; ++i){
            if (matchesRange(specifierValue[i])) return true;
        }
        return false;
    }
    return matchesRange(specifierValue);
}
var data = require('./core.json');
var core = {
};
for(var mod in data)if (Object.prototype.hasOwnProperty.call(data, mod)) core[mod] = versionIncluded(data[mod]);
module.exports = core;

},{"process":"lDnB8","./core.json":"768Jo"}],"768Jo":[function(require,module,exports) {
module.exports = JSON.parse("{\"assert\":true,\"assert/strict\":\">= 15\",\"async_hooks\":\">= 8\",\"buffer_ieee754\":\"< 0.9.7\",\"buffer\":true,\"child_process\":true,\"cluster\":true,\"console\":true,\"constants\":true,\"crypto\":true,\"_debug_agent\":\">= 1 && < 8\",\"_debugger\":\"< 8\",\"dgram\":true,\"diagnostics_channel\":\">= 15.1\",\"dns\":true,\"dns/promises\":\">= 15\",\"domain\":\">= 0.7.12\",\"events\":true,\"freelist\":\"< 6\",\"fs\":true,\"fs/promises\":[\">= 10 && < 10.1\",\">= 14\"],\"_http_agent\":\">= 0.11.1\",\"_http_client\":\">= 0.11.1\",\"_http_common\":\">= 0.11.1\",\"_http_incoming\":\">= 0.11.1\",\"_http_outgoing\":\">= 0.11.1\",\"_http_server\":\">= 0.11.1\",\"http\":true,\"http2\":\">= 8.8\",\"https\":true,\"inspector\":\">= 8.0.0\",\"_linklist\":\"< 8\",\"module\":true,\"net\":true,\"node-inspect/lib/_inspect\":\">= 7.6.0 && < 12\",\"node-inspect/lib/internal/inspect_client\":\">= 7.6.0 && < 12\",\"node-inspect/lib/internal/inspect_repl\":\">= 7.6.0 && < 12\",\"os\":true,\"path\":true,\"path/posix\":\">= 15.3\",\"path/win32\":\">= 15.3\",\"perf_hooks\":\">= 8.5\",\"process\":\">= 1\",\"punycode\":true,\"querystring\":true,\"readline\":true,\"repl\":true,\"smalloc\":\">= 0.11.5 && < 3\",\"_stream_duplex\":\">= 0.9.4\",\"_stream_transform\":\">= 0.9.4\",\"_stream_wrap\":\">= 1.4.1\",\"_stream_passthrough\":\">= 0.9.4\",\"_stream_readable\":\">= 0.9.4\",\"_stream_writable\":\">= 0.9.4\",\"stream\":true,\"stream/promises\":\">= 15\",\"string_decoder\":true,\"sys\":[\">= 0.6 && < 0.7\",\">= 0.8\"],\"timers\":true,\"timers/promises\":\">= 15\",\"_tls_common\":\">= 0.11.13\",\"_tls_legacy\":\">= 0.11.3 && < 10\",\"_tls_wrap\":\">= 0.11.3\",\"tls\":true,\"trace_events\":\">= 10\",\"tty\":true,\"url\":true,\"util\":true,\"util/types\":\">= 15.3\",\"v8/tools/arguments\":\">= 10 && < 12\",\"v8/tools/codemap\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/consarray\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/csvparser\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/logreader\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/profile_view\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/splaytree\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8\":\">= 1\",\"vm\":true,\"wasi\":\">= 13.4 && < 13.5\",\"worker_threads\":\">= 11.7\",\"zlib\":true}");

},{}],"98qKi":[function(require,module,exports) {
var isCoreModule = require('is-core-module');
module.exports = function isCore(x) {
    return isCoreModule(x);
};

},{"is-core-module":"1Roii"}],"6d4IG":[function(require,module,exports) {
var process = require("process");
var isCore = require('is-core-module');
var fs = require('fs');
var path = require('path');
var caller = require('./caller');
var nodeModulesPaths = require('./node-modules-paths');
var normalizeOptions = require('./normalize-options');
var realpathFS = fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;
var defaultIsFile = function isFile(file) {
    try {
        var stat = fs.statSync(file);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isFile() || stat.isFIFO();
};
var defaultIsDir = function isDirectory(dir) {
    try {
        var stat = fs.statSync(dir);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isDirectory();
};
var defaultRealpathSync = function realpathSync(x) {
    try {
        return realpathFS(x);
    } catch (realpathErr) {
        if (realpathErr.code !== 'ENOENT') throw realpathErr;
    }
    return x;
};
var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) return realpathSync(x);
    return x;
};
var defaultReadPackageSync = function defaultReadPackageSync(readFileSync, pkgfile) {
    var body = readFileSync(pkgfile);
    try {
        var pkg = JSON.parse(body);
        return pkg;
    } catch (jsonErr) {
    }
};
var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for(var i = 0; i < dirs.length; i++)dirs[i] = path.join(dirs[i], x);
    return dirs;
};
module.exports = function resolveSync(x1, options) {
    if (typeof x1 !== 'string') throw new TypeError('Path must be a string.');
    var opts = normalizeOptions(x1, options);
    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
    if (opts.readFileSync && opts.readPackageSync) throw new TypeError('`readFileSync` and `readPackageSync` are mutually exclusive.');
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [
        '.js'
    ];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || [];
    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x1)) {
        var res = path.resolve(absoluteStart, x1);
        if (x1 === '.' || x1 === '..' || x1.slice(-1) === '/') res += '/';
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
    } else if (includeCoreModules && isCore(x1)) return x1;
    else {
        var n = loadNodeModulesSync(x1, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
    }
    var err = new Error("Cannot find module '" + x1 + "' from '" + parent + "'");
    err.code = 'MODULE_NOT_FOUND';
    function loadAsFileSync(x) {
        var pkg = loadpkg(path.dirname(x));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
            var rfile = path.relative(pkg.dir, x);
            var r = opts.pathFilter(pkg.pkg, x, rfile);
            if (r) {
                x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
            }
        }
        if (isFile(x)) {
            return x;
        }
        for(var i = 0; i < extensions.length; i++){
            var file = x + extensions[i];
            if (isFile(file)) {
                return file;
            }
        }
    }
    function loadpkg(dir) {
        if (dir === '' || dir === '/') return;
        if (process.platform === 'win32' && /^\w:[/\\]*$/.test(dir)) {
            return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir)) return;
        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');
        if (!isFile(pkgfile)) {
            return loadpkg(path.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync, pkgfile);
        if (pkg && opts.packageFilter) {
            // v2 will pass pkgfile
            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment
        }
        return {
            pkg: pkg,
            dir: dir
        };
    }
    function loadAsDirectorySync(x) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');
        if (isFile(pkgfile)) {
            try {
                var pkg = readPackageSync(readFileSync, pkgfile);
            } catch (e) {
            }
            if (pkg && opts.packageFilter) {
                // v2 will pass pkgfile
                pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment
            }
            if (pkg && pkg.main) {
                if (typeof pkg.main !== 'string') {
                    var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');
                    mainError.code = 'INVALID_PACKAGE_MAIN';
                    throw mainError;
                }
                if (pkg.main === '.' || pkg.main === './') {
                    pkg.main = 'index';
                }
                try {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                    if (n) return n;
                } catch (e) {
                }
            }
        }
        return loadAsFileSync(path.join(x, '/index'));
    }
    function loadNodeModulesSync(x, start) {
        var thunk = function() {
            return getPackageCandidates(x, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();
        for(var i = 0; i < dirs.length; i++){
            var dir = dirs[i];
            if (isDirectory(path.dirname(dir))) {
                var m = loadAsFileSync(dir);
                if (m) return m;
                var n = loadAsDirectorySync(dir);
                if (n) return n;
            }
        }
    }
    throw err;
};

},{"process":"lDnB8","is-core-module":"1Roii","fs":"joWnX","path":"dTeSu","./caller":"nNQAh","./node-modules-paths":"ctUIJ","./normalize-options":"3kFyi"}],"1tHC6":[function(require,module,exports) {
'use strict';
var dirname = require('path').dirname;
var constantinople = require('constantinople');
var walk = require('pug-walk');
var error = require('pug-error');
var runFilter = require('./run-filter');
module.exports = handleFilters;
function handleFilters(ast, filters, options, filterAliases) {
    options = options || {
    };
    walk(ast, function(node) {
        var dir = node.filename ? dirname(node.filename) : null;
        if (node.type === 'Filter') {
            handleNestedFilters(node, filters, options, filterAliases);
            var text = getBodyAsText(node);
            var attrs1 = getAttributes(node, options);
            attrs1.filename = node.filename;
            node.type = 'Text';
            node.val = filterWithFallback(node, text, attrs1);
        } else if (node.type === 'RawInclude' && node.filters.length) {
            var firstFilter = node.filters.pop();
            var attrs1 = getAttributes(firstFilter, options);
            var filename = attrs1.filename = node.file.fullPath;
            node.type = 'Text';
            node.val = filterFileWithFallback(firstFilter, filename, node.file, attrs1);
            node.filters.slice().reverse().forEach(function(filter) {
                var attrs = getAttributes(filter, options);
                attrs.filename = filename;
                node.val = filterWithFallback(filter, node.val, attrs);
            });
            node.filters = undefined;
            node.file = undefined;
        }
        function filterWithFallback(filter, text, attrs, funcName) {
            try {
                var filterName = getFilterName(filter);
                if (filters && filters[filterName]) return filters[filterName](text, attrs);
                else return runFilter(filterName, text, attrs, dir, funcName);
            } catch (ex) {
                if (ex.code === 'UNKNOWN_FILTER') throw error(ex.code, ex.message, filter);
                throw ex;
            }
        }
        function filterFileWithFallback(filter, filename, file, attrs) {
            var filterName = getFilterName(filter);
            if (filters && filters[filterName]) {
                if (filters[filterName].renderBuffer) return filters[filterName].renderBuffer(file.raw, attrs);
                else return filters[filterName](file.str, attrs);
            } else return filterWithFallback(filter, filename, attrs, 'renderFile');
        }
    }, {
        includeDependencies: true
    });
    function getFilterName(filter) {
        var filterName = filter.name;
        if (filterAliases && filterAliases[filterName]) {
            filterName = filterAliases[filterName];
            if (filterAliases[filterName]) throw error('FILTER_ALISE_CHAIN', 'The filter "' + filter.name + '" is an alias for "' + filterName + '", which is an alias for "' + filterAliases[filterName] + '".  Pug does not support chains of filter aliases.', filter);
        }
        return filterName;
    }
    return ast;
}
function handleNestedFilters(node, filters, options, filterAliases) {
    if (node.block.nodes[0] && node.block.nodes[0].type === 'Filter') node.block.nodes[0] = handleFilters(node.block, filters, options, filterAliases).nodes[0];
}
function getBodyAsText(node1) {
    return node1.block.nodes.map(function(node) {
        return node.val;
    }).join('');
}
function getAttributes(node, options) {
    var attrs = {
    };
    node.attrs.forEach(function(attr) {
        try {
            attrs[attr.name] = attr.val === true ? true : constantinople.toConstant(attr.val);
        } catch (ex) {
            if (/not constant/.test(ex.message)) throw error('FILTER_OPTION_NOT_CONSTANT', ex.message + ' All filters are rendered compile-time so filter options must be constants.', node);
            throw ex;
        }
    });
    var opts = options[node.name] || {
    };
    Object.keys(opts).forEach(function(opt) {
        if (!attrs.hasOwnProperty(opt)) attrs[opt] = opts[opt];
    });
    return attrs;
}

},{"path":"dTeSu","constantinople":"hYgg9","pug-walk":"dSk0a","pug-error":"lbNNk","./run-filter":"5MFpZ"}],"hYgg9":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
var parser_1 = require("@babel/parser");
var b1 = require("@babel/types");
var binaryOperation_1 = require("./binaryOperation");
function expressionToConstant(expression1, options) {
    if (options === void 0) options = {
    };
    var constant = true;
    function toConstant(expression) {
        if (!constant) return;
        if (b1.isArrayExpression(expression)) {
            var result_1 = [];
            for(var i = 0; constant && i < expression.elements.length; i++){
                var element = expression.elements[i];
                if (b1.isSpreadElement(element)) {
                    var spread = toConstant(element.argument);
                    if (!(isSpreadable(spread) && constant)) constant = false;
                    else result_1.push.apply(result_1, spread);
                } else if (b1.isExpression(element)) result_1.push(toConstant(element));
                else constant = false;
            }
            return result_1;
        }
        if (b1.isBinaryExpression(expression)) {
            var left = toConstant(expression.left);
            var right = toConstant(expression.right);
            return constant && binaryOperation_1["default"](expression.operator, left, right);
        }
        if (b1.isBooleanLiteral(expression)) return expression.value;
        if (b1.isCallExpression(expression)) {
            var args = [];
            for(var i = 0; constant && i < expression.arguments.length; i++){
                var arg = expression.arguments[i];
                if (b1.isSpreadElement(arg)) {
                    var spread = toConstant(arg.argument);
                    if (!(isSpreadable(spread) && constant)) constant = false;
                    else args.push.apply(args, spread);
                } else if (b1.isExpression(arg)) args.push(toConstant(arg));
                else constant = false;
            }
            if (!constant) return;
            if (b1.isMemberExpression(expression.callee)) {
                var object = toConstant(expression.callee.object);
                if (!object || !constant) {
                    constant = false;
                    return;
                }
                var member = expression.callee.computed ? toConstant(expression.callee.property) : b1.isIdentifier(expression.callee.property) ? expression.callee.property.name : undefined;
                if (member === undefined && !expression.callee.computed) constant = false;
                if (!constant) return;
                if (canCallMethod(object, '' + member)) return object[member].apply(object, args);
            } else {
                if (!b1.isExpression(expression.callee)) {
                    constant = false;
                    return;
                }
                var callee = toConstant(expression.callee);
                if (!constant) return;
                return callee.apply(null, args);
            }
        }
        if (b1.isConditionalExpression(expression)) {
            var test = toConstant(expression.test);
            return test ? toConstant(expression.consequent) : toConstant(expression.alternate);
        }
        if (b1.isIdentifier(expression)) {
            if (options.constants && ({
            }).hasOwnProperty.call(options.constants, expression.name)) return options.constants[expression.name];
        }
        if (b1.isLogicalExpression(expression)) {
            var left = toConstant(expression.left);
            var right = toConstant(expression.right);
            if (constant && expression.operator === '&&') return left && right;
            if (constant && expression.operator === '||') return left || right;
        }
        if (b1.isMemberExpression(expression)) {
            var object = toConstant(expression.object);
            if (!object || !constant) {
                constant = false;
                return;
            }
            var member = expression.computed ? toConstant(expression.property) : b1.isIdentifier(expression.property) ? expression.property.name : undefined;
            if (member === undefined && !expression.computed) constant = false;
            if (!constant) return;
            if (({
            }).hasOwnProperty.call(object, '' + member) && member[0] !== '_') return object[member];
        }
        if (b1.isNullLiteral(expression)) return null;
        if (b1.isNumericLiteral(expression)) return expression.value;
        if (b1.isObjectExpression(expression)) {
            var result_2 = {
            };
            for(var i = 0; constant && i < expression.properties.length; i++){
                var property = expression.properties[i];
                if (b1.isObjectProperty(property)) {
                    if (property.shorthand) {
                        constant = false;
                        return;
                    }
                    var key = property.computed ? toConstant(property.key) : b1.isIdentifier(property.key) ? property.key.name : b1.isStringLiteral(property.key) ? property.key.value : undefined;
                    if (!key || key[0] === '_') constant = false;
                    if (!constant) return;
                    if (b1.isExpression(property.value)) {
                        var value = toConstant(property.value);
                        if (!constant) return;
                        result_2[key] = value;
                    } else constant = false;
                } else if (b1.isObjectMethod(property)) constant = false;
                else if (b1.isSpreadProperty(property)) {
                    var argument = toConstant(property.argument);
                    if (!argument) constant = false;
                    if (!constant) return;
                    Object.assign(result_2, argument);
                }
            }
            return result_2;
        }
        if (b1.isParenthesizedExpression(expression)) return toConstant(expression.expression);
        if (b1.isRegExpLiteral(expression)) return new RegExp(expression.pattern, expression.flags);
        if (b1.isSequenceExpression(expression)) {
            for(var i = 0; i < expression.expressions.length - 1 && constant; i++)toConstant(expression.expressions[i]);
            return toConstant(expression.expressions[expression.expressions.length - 1]);
        }
        if (b1.isStringLiteral(expression)) return expression.value;
        // TODO: TaggedTemplateExpression
        if (b1.isTemplateLiteral(expression)) {
            var result_3 = '';
            for(var i = 0; i < expression.quasis.length; i++){
                var quasi = expression.quasis[i];
                result_3 += quasi.value.cooked;
                if (i < expression.expressions.length) result_3 += '' + toConstant(expression.expressions[i]);
            }
            return result_3;
        }
        if (b1.isUnaryExpression(expression)) {
            var argument = toConstant(expression.argument);
            if (!constant) return;
            switch(expression.operator){
                case '-':
                    return -argument;
                case '+':
                    return +argument;
                case '!':
                    return !argument;
                case '~':
                    return ~argument;
                case 'typeof':
                    return typeof argument;
                case 'void':
                    return void 0;
            }
        }
        constant = false;
    }
    var result = toConstant(expression1);
    return constant ? {
        constant: true,
        result: result
    } : {
        constant: false
    };
}
exports.expressionToConstant = expressionToConstant;
function isSpreadable(value) {
    return typeof value === 'string' || Array.isArray(value) || typeof Set !== 'undefined' && value instanceof Set || typeof Map !== 'undefined' && value instanceof Map;
}
function shallowEqual(a, b) {
    if (a === b) return true;
    if (a && b && typeof a === 'object' && typeof b === 'object') {
        for(var key in a){
            if (a[key] !== b[key]) return false;
        }
        for(var key in b){
            if (a[key] !== b[key]) return false;
        }
        return true;
    }
    return false;
}
function canCallMethod(object, member) {
    switch(typeof object){
        case 'boolean':
            switch(member){
                case 'toString':
                    return true;
                default:
                    return false;
            }
        case 'number':
            switch(member){
                case 'toExponential':
                case 'toFixed':
                case 'toPrecision':
                case 'toString':
                    return true;
                default:
                    return false;
            }
        case 'string':
            switch(member){
                case 'charAt':
                case 'charCodeAt':
                case 'codePointAt':
                case 'concat':
                case 'endsWith':
                case 'includes':
                case 'indexOf':
                case 'lastIndexOf':
                case 'match':
                case 'normalize':
                case 'padEnd':
                case 'padStart':
                case 'repeat':
                case 'replace':
                case 'search':
                case 'slice':
                case 'split':
                case 'startsWith':
                case 'substr':
                case 'substring':
                case 'toLowerCase':
                case 'toUpperCase':
                case 'trim':
                    return true;
                default:
                    return false;
            }
        default:
            if (object instanceof RegExp) switch(member){
                case 'test':
                case 'exec':
                    return true;
                default:
                    return false;
            }
            return ({
            }).hasOwnProperty.call(object, member) && member[0] !== '_';
    }
}
var EMPTY_OBJECT = {
};
var lastSrc = '';
var lastConstants = EMPTY_OBJECT;
var lastOptions = EMPTY_OBJECT;
var lastResult = null;
var lastWasConstant = false;
function isConstant(src, constants, options) {
    if (constants === void 0) constants = EMPTY_OBJECT;
    if (options === void 0) options = EMPTY_OBJECT;
    if (lastSrc === src && shallowEqual(lastConstants, constants) && shallowEqual(lastOptions, options)) return lastWasConstant;
    lastSrc = src;
    lastConstants = constants;
    var ast;
    try {
        ast = parser_1.parseExpression(src, options);
    } catch (ex) {
        return lastWasConstant = false;
    }
    var _a = expressionToConstant(ast, {
        constants: constants
    }), result = _a.result, constant = _a.constant;
    lastResult = result;
    return lastWasConstant = constant;
}
exports.isConstant = isConstant;
function toConstant1(src, constants, options) {
    if (constants === void 0) constants = EMPTY_OBJECT;
    if (options === void 0) options = EMPTY_OBJECT;
    if (!isConstant(src, constants, options)) throw new Error(JSON.stringify(src) + ' is not constant.');
    return lastResult;
}
exports.toConstant = toConstant1;
exports["default"] = isConstant;
module.exports = isConstant;
module.exports["default"] = isConstant;
module.exports.expressionToConstant = expressionToConstant;
module.exports.isConstant = isConstant;
module.exports.toConstant = toConstant1;

},{"@babel/parser":"l6i8u","@babel/types":"3rtBJ","./binaryOperation":"7OInV"}],"l6i8u":[function(require,module,exports) {
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
const lineBreak = /\r\n?|[\n\u2028\u2029]/;
const lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
    switch(code){
        case 10:
        case 13:
        case 8232:
        case 8233:
            return true;
        default:
            return false;
    }
}
const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
const skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y;
const skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
function isWhitespace(code) {
    switch(code){
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
            return true;
        default:
            return false;
    }
}
class Position {
    constructor(line1, col){
        this.line = void 0;
        this.column = void 0;
        this.line = line1;
        this.column = col;
    }
}
class SourceLocation {
    constructor(start2, end2){
        this.start = void 0;
        this.end = void 0;
        this.filename = void 0;
        this.identifierName = void 0;
        this.start = start2;
        this.end = end2;
    }
}
function getLineInfo(input, offset) {
    let line = 1;
    let lineStart = 0;
    let match;
    lineBreakG.lastIndex = 0;
    while((match = lineBreakG.exec(input)) && match.index < offset){
        line++;
        lineStart = lineBreakG.lastIndex;
    }
    return new Position(line, offset - lineStart);
}
class BaseParser {
    constructor(){
        this.sawUnambiguousESM = false;
        this.ambiguousScriptDifferentAst = false;
    }
    hasPlugin(name2) {
        return this.plugins.has(name2);
    }
    getPluginOption(plugin1, name1) {
        if (this.hasPlugin(plugin1)) return this.plugins.get(plugin1)[name1];
    }
}
function setTrailingComments(node, comments) {
    if (node.trailingComments === undefined) node.trailingComments = comments;
    else node.trailingComments.unshift(...comments);
}
function setLeadingComments(node, comments) {
    if (node.leadingComments === undefined) node.leadingComments = comments;
    else node.leadingComments.unshift(...comments);
}
function setInnerComments(node, comments) {
    if (node.innerComments === undefined) node.innerComments = comments;
    else node.innerComments.unshift(...comments);
}
function adjustInnerComments(node, elements, commentWS) {
    let lastElement = null;
    let i = elements.length;
    while(lastElement === null && i > 0)lastElement = elements[--i];
    if (lastElement === null || lastElement.start > commentWS.start) setInnerComments(node, commentWS.comments);
    else setTrailingComments(lastElement, commentWS.comments);
}
class CommentsParser extends BaseParser {
    addComment(comment1) {
        if (this.filename) comment1.loc.filename = this.filename;
        this.state.comments.push(comment1);
    }
    processComment(node3) {
        const { commentStack  } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1;
        const lastCommentWS = commentStack[i];
        if (lastCommentWS.start === node3.end) {
            lastCommentWS.leadingNode = node3;
            i--;
        }
        const { start: nodeStart  } = node3;
        for(; i >= 0; i--){
            const commentWS = commentStack[i];
            const commentEnd = commentWS.end;
            if (commentEnd > nodeStart) {
                commentWS.containingNode = node3;
                this.finalizeComment(commentWS);
                commentStack.splice(i, 1);
            } else {
                if (commentEnd === nodeStart) commentWS.trailingNode = node3;
                break;
            }
        }
    }
    finalizeComment(commentWS) {
        const { comments  } = commentWS;
        if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
            if (commentWS.leadingNode !== null) setTrailingComments(commentWS.leadingNode, comments);
            if (commentWS.trailingNode !== null) setLeadingComments(commentWS.trailingNode, comments);
        } else {
            const { containingNode: node , start: commentStart  } = commentWS;
            if (this.input.charCodeAt(commentStart - 1) === 44) switch(node.type){
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                    adjustInnerComments(node, node.properties, commentWS);
                    break;
                case "CallExpression":
                case "OptionalCallExpression":
                    adjustInnerComments(node, node.arguments, commentWS);
                    break;
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "ArrowFunctionExpression":
                case "ObjectMethod":
                case "ClassMethod":
                case "ClassPrivateMethod":
                    adjustInnerComments(node, node.params, commentWS);
                    break;
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                    adjustInnerComments(node, node.elements, commentWS);
                    break;
                case "ExportNamedDeclaration":
                case "ImportDeclaration":
                    adjustInnerComments(node, node.specifiers, commentWS);
                    break;
                default:
                    setInnerComments(node, comments);
            }
            else setInnerComments(node, comments);
        }
    }
    finalizeRemainingComments() {
        const { commentStack  } = this.state;
        for(let i = commentStack.length - 1; i >= 0; i--)this.finalizeComment(commentStack[i]);
        this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(node1) {
        const { commentStack  } = this.state;
        const { length  } = commentStack;
        if (length === 0) return;
        const commentWS = commentStack[length - 1];
        if (commentWS.leadingNode === node1) commentWS.leadingNode = null;
    }
    takeSurroundingComments(node2, start1, end1) {
        const { commentStack  } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1;
        for(; i >= 0; i--){
            const commentWS = commentStack[i];
            const commentEnd = commentWS.end;
            const commentStart = commentWS.start;
            if (commentStart === end1) commentWS.leadingNode = node2;
            else if (commentEnd === start1) commentWS.trailingNode = node2;
            else if (commentEnd < start1) break;
        }
    }
}
const ErrorCodes = Object.freeze({
    SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
    SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
});
const ErrorMessages = makeErrorTemplates({
    AccessorIsGenerator: "A %0ter cannot be a generator.",
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accesor must not have any formal parameters.",
    BadSetterArity: "A 'set' accesor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: "'%0' require an initialization value.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?",
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: "Unsyntactic %0.",
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: "`import()` requires exactly %0.",
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: "Expected number in radix %0.",
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: "Escape sequence in keyword %0.",
    InvalidIdentifier: "Invalid identifier %0.",
    InvalidLhs: "Invalid left-hand side in %0.",
    InvalidLhsBinding: "Binding invalid left-hand side in %0.",
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: "Unexpected character '%0'.",
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: "Private name #%0 is not defined.",
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: "Label '%0' is already declared.",
    LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.',
    ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.",
    ModuleExportUndefined: "Export '%0' is not defined.",
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PipeBodyIsTighter: "Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: 'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "%0" }.',
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: "Hack-style pipe body cannot be an unparenthesized %0 expression; please wrap it in parentheses.",
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
    PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).",
    PrivateNameRedeclaration: "Duplicate private name #%0.",
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
    StaticPrototype: "Classes may not have static property named prototype.",
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: "Assigning to '%0' in strict mode.",
    StrictEvalArgumentsBinding: "Binding '%0' in strict mode.",
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: "Unexpected keyword '%0'.",
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",
    UnexpectedReservedWord: "Unexpected reserved word '%0'.",
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: "Unexpected token '%0'.",
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.",
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    VarRedeclaration: "Identifier '%0' has already been declared.",
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
}, ErrorCodes.SyntaxError);
const SourceTypeModuleErrorMessages = makeErrorTemplates({
    ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`,
    ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'`
}, ErrorCodes.SourceTypeModuleError);
function keepReasonCodeCompat(reasonCode, syntaxPlugin) {
    if (syntaxPlugin === "flow" && reasonCode === "PatternIsOptional") return "OptionalBindingPattern";
    return reasonCode;
}
function makeErrorTemplates(messages, code, syntaxPlugin) {
    const templates = {
    };
    Object.keys(messages).forEach((reasonCode)=>{
        templates[reasonCode] = Object.freeze({
            code,
            reasonCode: keepReasonCodeCompat(reasonCode, syntaxPlugin),
            template: messages[reasonCode]
        });
    });
    return Object.freeze(templates);
}
class ParserError extends CommentsParser {
    getLocationForPosition(pos4) {
        let loc;
        if (pos4 === this.state.start) loc = this.state.startLoc;
        else if (pos4 === this.state.lastTokStart) loc = this.state.lastTokStartLoc;
        else if (pos4 === this.state.end) loc = this.state.endLoc;
        else if (pos4 === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;
        else loc = getLineInfo(this.input, pos4);
        return loc;
    }
    raise(pos1, { code: code2 , reasonCode , template: template6  }, ...params3) {
        return this.raiseWithData(pos1, {
            code: code2,
            reasonCode
        }, template6, ...params3);
    }
    raiseOverwrite(pos2, { code: code1 , template: template1  }, ...params1) {
        const loc = this.getLocationForPosition(pos2);
        const message = template1.replace(/%(\d+)/g, (_, i)=>params1[i]
        ) + ` (${loc.line}:${loc.column})`;
        if (this.options.errorRecovery) {
            const errors = this.state.errors;
            for(let i = errors.length - 1; i >= 0; i--){
                const error = errors[i];
                if (error.pos === pos2) return Object.assign(error, {
                    message
                });
                else if (error.pos < pos2) break;
            }
        }
        return this._raise({
            code: code1,
            loc,
            pos: pos2
        }, message);
    }
    raiseWithData(pos3, data, errorTemplate1, ...params2) {
        const loc = this.getLocationForPosition(pos3);
        const message = errorTemplate1.replace(/%(\d+)/g, (_, i)=>params2[i]
        ) + ` (${loc.line}:${loc.column})`;
        return this._raise(Object.assign({
            loc,
            pos: pos3
        }, data), message);
    }
    _raise(errorContext, message1) {
        const err = new SyntaxError(message1);
        Object.assign(err, errorContext);
        if (this.options.errorRecovery) {
            if (!this.isLookahead) this.state.errors.push(err);
            return err;
        } else throw err;
    }
}
var estree = (superClass)=>class extends superClass {
        parseRegExpLiteral({ pattern , flags  }) {
            let regex = null;
            try {
                regex = new RegExp(pattern, flags);
            } catch (e) {
            }
            const node = this.estreeParseLiteral(regex);
            node.regex = {
                pattern,
                flags
            };
            return node;
        }
        parseBigIntLiteral(value) {
            let bigInt;
            try {
                bigInt = BigInt(value);
            } catch (_unused) {
                bigInt = null;
            }
            const node = this.estreeParseLiteral(bigInt);
            node.bigint = String(node.value || value);
            return node;
        }
        parseDecimalLiteral(value1) {
            const decimal = null;
            const node = this.estreeParseLiteral(decimal);
            node.decimal = String(node.value || value1);
            return node;
        }
        estreeParseLiteral(value2) {
            return this.parseLiteral(value2, "Literal");
        }
        parseStringLiteral(value3) {
            return this.estreeParseLiteral(value3);
        }
        parseNumericLiteral(value4) {
            return this.estreeParseLiteral(value4);
        }
        parseNullLiteral() {
            return this.estreeParseLiteral(null);
        }
        parseBooleanLiteral(value5) {
            return this.estreeParseLiteral(value5);
        }
        directiveToStmt(directive) {
            const directiveLiteral = directive.value;
            const stmt = this.startNodeAt(directive.start, directive.loc.start);
            const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
            expression.value = directiveLiteral.extra.expressionValue;
            expression.raw = directiveLiteral.extra.raw;
            stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
            stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
            return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
        }
        initFunction(node, isAsync) {
            super.initFunction(node, isAsync);
            node.expression = false;
        }
        checkDeclaration(node4) {
            if (node4 != null && this.isObjectProperty(node4)) this.checkDeclaration(node4.value);
            else super.checkDeclaration(node4);
        }
        getObjectOrClassMethodParams(method) {
            return method.value.params;
        }
        isValidDirective(stmt) {
            var _stmt$expression$extr;
            return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
        }
        stmtToDirective(stmt1) {
            const value = stmt1.expression.value;
            const directive = super.stmtToDirective(stmt1);
            this.addExtra(directive.value, "expressionValue", value);
            return directive;
        }
        parseBlockBody(node5, ...args) {
            super.parseBlockBody(node5, ...args);
            const directiveStatements = node5.directives.map((d)=>this.directiveToStmt(d)
            );
            node5.body = directiveStatements.concat(node5.body);
            delete node5.directives;
        }
        pushClassMethod(classBody, method1, isGenerator, isAsync1, isConstructor, allowsDirectSuper) {
            this.parseMethod(method1, isGenerator, isAsync1, isConstructor, allowsDirectSuper, "ClassMethod", true);
            if (method1.typeParameters) {
                method1.value.typeParameters = method1.typeParameters;
                delete method1.typeParameters;
            }
            classBody.body.push(method1);
        }
        parsePrivateName() {
            const node = super.parsePrivateName();
            if (!this.getPluginOption("estree", "classFeatures")) return node;
            return this.convertPrivateNameToPrivateIdentifier(node);
        }
        convertPrivateNameToPrivateIdentifier(node6) {
            const name = super.getPrivateNameSV(node6);
            delete node6.id;
            node6.name = name;
            node6.type = "PrivateIdentifier";
            return node6;
        }
        isPrivateName(node7) {
            if (!this.getPluginOption("estree", "classFeatures")) return super.isPrivateName(node7);
            return node7.type === "PrivateIdentifier";
        }
        getPrivateNameSV(node8) {
            if (!this.getPluginOption("estree", "classFeatures")) return super.getPrivateNameSV(node8);
            return node8.name;
        }
        parseLiteral(value6, type) {
            const node = super.parseLiteral(value6, type);
            node.raw = node.extra.raw;
            delete node.extra;
            return node;
        }
        parseFunctionBody(node9, allowExpression, isMethod = false) {
            super.parseFunctionBody(node9, allowExpression, isMethod);
            node9.expression = node9.body.type !== "BlockStatement";
        }
        parseMethod(node10, isGenerator1, isAsync2, isConstructor1, allowDirectSuper, type1, inClassScope = false) {
            let funcNode = this.startNode();
            funcNode.kind = node10.kind;
            funcNode = super.parseMethod(funcNode, isGenerator1, isAsync2, isConstructor1, allowDirectSuper, type1, inClassScope);
            funcNode.type = "FunctionExpression";
            delete funcNode.kind;
            node10.value = funcNode;
            if (type1 === "ClassPrivateMethod") node10.computed = false;
            type1 = "MethodDefinition";
            return this.finishNode(node10, type1);
        }
        parseClassProperty(...args1) {
            const propertyNode = super.parseClassProperty(...args1);
            if (!this.getPluginOption("estree", "classFeatures")) return propertyNode;
            propertyNode.type = "PropertyDefinition";
            return propertyNode;
        }
        parseClassPrivateProperty(...args2) {
            const propertyNode = super.parseClassPrivateProperty(...args2);
            if (!this.getPluginOption("estree", "classFeatures")) return propertyNode;
            propertyNode.type = "PropertyDefinition";
            propertyNode.computed = false;
            return propertyNode;
        }
        parseObjectMethod(prop, isGenerator2, isAsync3, isPattern, isAccessor) {
            const node = super.parseObjectMethod(prop, isGenerator2, isAsync3, isPattern, isAccessor);
            if (node) {
                node.type = "Property";
                if (node.kind === "method") node.kind = "init";
                node.shorthand = false;
            }
            return node;
        }
        parseObjectProperty(prop1, startPos, startLoc, isPattern1, refExpressionErrors) {
            const node = super.parseObjectProperty(prop1, startPos, startLoc, isPattern1, refExpressionErrors);
            if (node) {
                node.kind = "init";
                node.type = "Property";
            }
            return node;
        }
        isAssignable(node11, isBinding) {
            if (node11 != null && this.isObjectProperty(node11)) return this.isAssignable(node11.value, isBinding);
            return super.isAssignable(node11, isBinding);
        }
        toAssignable(node12, isLHS = false) {
            if (node12 != null && this.isObjectProperty(node12)) {
                this.toAssignable(node12.value, isLHS);
                return node12;
            }
            return super.toAssignable(node12, isLHS);
        }
        toAssignableObjectExpressionProp(prop2, ...args3) {
            if (prop2.kind === "get" || prop2.kind === "set") this.raise(prop2.key.start, ErrorMessages.PatternHasAccessor);
            else if (prop2.method) this.raise(prop2.key.start, ErrorMessages.PatternHasMethod);
            else super.toAssignableObjectExpressionProp(prop2, ...args3);
        }
        finishCallExpression(node13, optional) {
            super.finishCallExpression(node13, optional);
            if (node13.callee.type === "Import") {
                node13.type = "ImportExpression";
                node13.source = node13.arguments[0];
                if (this.hasPlugin("importAssertions")) {
                    var _node$arguments$;
                    node13.attributes = (_node$arguments$ = node13.arguments[1]) != null ? _node$arguments$ : null;
                }
                delete node13.arguments;
                delete node13.callee;
            }
            return node13;
        }
        toReferencedArguments(node14) {
            if (node14.type === "ImportExpression") return;
            super.toReferencedArguments(node14);
        }
        parseExport(node15) {
            super.parseExport(node15);
            switch(node15.type){
                case "ExportAllDeclaration":
                    node15.exported = null;
                    break;
                case "ExportNamedDeclaration":
                    if (node15.specifiers.length === 1 && node15.specifiers[0].type === "ExportNamespaceSpecifier") {
                        node15.type = "ExportAllDeclaration";
                        node15.exported = node15.specifiers[0].exported;
                        delete node15.specifiers;
                    }
                    break;
            }
            return node15;
        }
        parseSubscript(base, startPos1, startLoc1, noCalls, state) {
            const node = super.parseSubscript(base, startPos1, startLoc1, noCalls, state);
            if (state.optionalChainMember) {
                if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") node.type = node.type.substring(8);
                if (state.stop) {
                    const chain = this.startNodeAtNode(node);
                    chain.expression = node;
                    return this.finishNode(chain, "ChainExpression");
                }
            } else if (node.type === "MemberExpression" || node.type === "CallExpression") node.optional = false;
            return node;
        }
        hasPropertyAsPrivateName(node16) {
            if (node16.type === "ChainExpression") node16 = node16.expression;
            return super.hasPropertyAsPrivateName(node16);
        }
        isOptionalChain(node17) {
            return node17.type === "ChainExpression";
        }
        isObjectProperty(node18) {
            return node18.type === "Property" && node18.kind === "init" && !node18.method;
        }
        isObjectMethod(node19) {
            return node19.method || node19.kind === "get" || node19.kind === "set";
        }
    }
;
class TokContext {
    constructor(token1, preserveSpace){
        this.token = void 0;
        this.preserveSpace = void 0;
        this.token = token1;
        this.preserveSpace = !!preserveSpace;
    }
}
const types1 = {
    brace: new TokContext("{"),
    template: new TokContext("`", true)
};
const beforeExpr = true;
const startsExpr = true;
const isLoop = true;
const isAssign = true;
const prefix = true;
const postfix = true;
class ExportedTokenType {
    constructor(label1, conf = {
    }){
        this.label = void 0;
        this.keyword = void 0;
        this.beforeExpr = void 0;
        this.startsExpr = void 0;
        this.rightAssociative = void 0;
        this.isLoop = void 0;
        this.isAssign = void 0;
        this.prefix = void 0;
        this.postfix = void 0;
        this.binop = void 0;
        this.label = label1;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.rightAssociative = !!conf.rightAssociative;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop != null ? conf.binop : null;
        this.updateContext = null;
    }
}
const keywords$1 = new Map();
function createKeyword(name, options = {
}) {
    options.keyword = name;
    const token = createToken(name, options);
    keywords$1.set(name, token);
    return token;
}
function createBinop(name, binop) {
    return createToken(name, {
        beforeExpr,
        binop
    });
}
let tokenTypeCounter = -1;
const tokenTypes1 = [];
const tokenLabels = [];
const tokenBinops = [];
const tokenBeforeExprs = [];
const tokenStartsExprs = [];
const tokenPrefixes = [];
function createToken(name, options = {
}) {
    var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
    ++tokenTypeCounter;
    tokenLabels.push(name);
    tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
    tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
    tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
    tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
    tokenTypes1.push(new ExportedTokenType(name, options));
    return tokenTypeCounter;
}
function createKeywordLike(name, options = {
}) {
    var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
    ++tokenTypeCounter;
    keywords$1.set(name, tokenTypeCounter);
    tokenLabels.push(name);
    tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
    tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
    tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
    tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
    tokenTypes1.push(new ExportedTokenType("name", options));
    return tokenTypeCounter;
}
const tt = {
    bracketL: createToken("[", {
        beforeExpr,
        startsExpr
    }),
    bracketHashL: createToken("#[", {
        beforeExpr,
        startsExpr
    }),
    bracketBarL: createToken("[|", {
        beforeExpr,
        startsExpr
    }),
    bracketR: createToken("]"),
    bracketBarR: createToken("|]"),
    braceL: createToken("{", {
        beforeExpr,
        startsExpr
    }),
    braceBarL: createToken("{|", {
        beforeExpr,
        startsExpr
    }),
    braceHashL: createToken("#{", {
        beforeExpr,
        startsExpr
    }),
    braceR: createToken("}", {
        beforeExpr
    }),
    braceBarR: createToken("|}"),
    parenL: createToken("(", {
        beforeExpr,
        startsExpr
    }),
    parenR: createToken(")"),
    comma: createToken(",", {
        beforeExpr
    }),
    semi: createToken(";", {
        beforeExpr
    }),
    colon: createToken(":", {
        beforeExpr
    }),
    doubleColon: createToken("::", {
        beforeExpr
    }),
    dot: createToken("."),
    question: createToken("?", {
        beforeExpr
    }),
    questionDot: createToken("?."),
    arrow: createToken("=>", {
        beforeExpr
    }),
    template: createToken("template"),
    ellipsis: createToken("...", {
        beforeExpr
    }),
    backQuote: createToken("`", {
        startsExpr
    }),
    dollarBraceL: createToken("${", {
        beforeExpr,
        startsExpr
    }),
    at: createToken("@"),
    hash: createToken("#", {
        startsExpr
    }),
    interpreterDirective: createToken("#!..."),
    eq: createToken("=", {
        beforeExpr,
        isAssign
    }),
    assign: createToken("_=", {
        beforeExpr,
        isAssign
    }),
    slashAssign: createToken("_=", {
        beforeExpr,
        isAssign
    }),
    xorAssign: createToken("_=", {
        beforeExpr,
        isAssign
    }),
    moduloAssign: createToken("_=", {
        beforeExpr,
        isAssign
    }),
    incDec: createToken("++/--", {
        prefix,
        postfix,
        startsExpr
    }),
    bang: createToken("!", {
        beforeExpr,
        prefix,
        startsExpr
    }),
    tilde: createToken("~", {
        beforeExpr,
        prefix,
        startsExpr
    }),
    pipeline: createBinop("|>", 0),
    nullishCoalescing: createBinop("??", 1),
    logicalOR: createBinop("||", 1),
    logicalAND: createBinop("&&", 2),
    bitwiseOR: createBinop("|", 3),
    bitwiseXOR: createBinop("^", 4),
    bitwiseAND: createBinop("&", 5),
    equality: createBinop("==/!=/===/!==", 6),
    lt: createBinop("</>/<=/>=", 7),
    gt: createBinop("</>/<=/>=", 7),
    relational: createBinop("</>/<=/>=", 7),
    bitShift: createBinop("<</>>/>>>", 8),
    plusMin: createToken("+/-", {
        beforeExpr,
        binop: 9,
        prefix,
        startsExpr
    }),
    modulo: createToken("%", {
        binop: 10,
        startsExpr
    }),
    star: createToken("*", {
        binop: 10
    }),
    slash: createBinop("/", 10),
    exponent: createToken("**", {
        beforeExpr,
        binop: 11,
        rightAssociative: true
    }),
    _in: createKeyword("in", {
        beforeExpr,
        binop: 7
    }),
    _instanceof: createKeyword("instanceof", {
        beforeExpr,
        binop: 7
    }),
    _break: createKeyword("break"),
    _case: createKeyword("case", {
        beforeExpr
    }),
    _catch: createKeyword("catch"),
    _continue: createKeyword("continue"),
    _debugger: createKeyword("debugger"),
    _default: createKeyword("default", {
        beforeExpr
    }),
    _else: createKeyword("else", {
        beforeExpr
    }),
    _finally: createKeyword("finally"),
    _function: createKeyword("function", {
        startsExpr
    }),
    _if: createKeyword("if"),
    _return: createKeyword("return", {
        beforeExpr
    }),
    _switch: createKeyword("switch"),
    _throw: createKeyword("throw", {
        beforeExpr,
        prefix,
        startsExpr
    }),
    _try: createKeyword("try"),
    _var: createKeyword("var"),
    _const: createKeyword("const"),
    _with: createKeyword("with"),
    _new: createKeyword("new", {
        beforeExpr,
        startsExpr
    }),
    _this: createKeyword("this", {
        startsExpr
    }),
    _super: createKeyword("super", {
        startsExpr
    }),
    _class: createKeyword("class", {
        startsExpr
    }),
    _extends: createKeyword("extends", {
        beforeExpr
    }),
    _export: createKeyword("export"),
    _import: createKeyword("import", {
        startsExpr
    }),
    _null: createKeyword("null", {
        startsExpr
    }),
    _true: createKeyword("true", {
        startsExpr
    }),
    _false: createKeyword("false", {
        startsExpr
    }),
    _typeof: createKeyword("typeof", {
        beforeExpr,
        prefix,
        startsExpr
    }),
    _void: createKeyword("void", {
        beforeExpr,
        prefix,
        startsExpr
    }),
    _delete: createKeyword("delete", {
        beforeExpr,
        prefix,
        startsExpr
    }),
    _do: createKeyword("do", {
        isLoop,
        beforeExpr
    }),
    _for: createKeyword("for", {
        isLoop
    }),
    _while: createKeyword("while", {
        isLoop
    }),
    _as: createKeywordLike("as", {
        startsExpr
    }),
    _assert: createKeywordLike("assert", {
        startsExpr
    }),
    _async: createKeywordLike("async", {
        startsExpr
    }),
    _await: createKeywordLike("await", {
        startsExpr
    }),
    _from: createKeywordLike("from", {
        startsExpr
    }),
    _get: createKeywordLike("get", {
        startsExpr
    }),
    _let: createKeywordLike("let", {
        startsExpr
    }),
    _meta: createKeywordLike("meta", {
        startsExpr
    }),
    _of: createKeywordLike("of", {
        startsExpr
    }),
    _sent: createKeywordLike("sent", {
        startsExpr
    }),
    _set: createKeywordLike("set", {
        startsExpr
    }),
    _static: createKeywordLike("static", {
        startsExpr
    }),
    _yield: createKeywordLike("yield", {
        startsExpr
    }),
    _asserts: createKeywordLike("asserts", {
        startsExpr
    }),
    _checks: createKeywordLike("checks", {
        startsExpr
    }),
    _exports: createKeywordLike("exports", {
        startsExpr
    }),
    _global: createKeywordLike("global", {
        startsExpr
    }),
    _implements: createKeywordLike("implements", {
        startsExpr
    }),
    _intrinsic: createKeywordLike("intrinsic", {
        startsExpr
    }),
    _infer: createKeywordLike("infer", {
        startsExpr
    }),
    _is: createKeywordLike("is", {
        startsExpr
    }),
    _mixins: createKeywordLike("mixins", {
        startsExpr
    }),
    _proto: createKeywordLike("proto", {
        startsExpr
    }),
    _require: createKeywordLike("require", {
        startsExpr
    }),
    _keyof: createKeywordLike("keyof", {
        startsExpr
    }),
    _readonly: createKeywordLike("readonly", {
        startsExpr
    }),
    _unique: createKeywordLike("unique", {
        startsExpr
    }),
    _abstract: createKeywordLike("abstract", {
        startsExpr
    }),
    _declare: createKeywordLike("declare", {
        startsExpr
    }),
    _enum: createKeywordLike("enum", {
        startsExpr
    }),
    _module: createKeywordLike("module", {
        startsExpr
    }),
    _namespace: createKeywordLike("namespace", {
        startsExpr
    }),
    _interface: createKeywordLike("interface", {
        startsExpr
    }),
    _type: createKeywordLike("type", {
        startsExpr
    }),
    _opaque: createKeywordLike("opaque", {
        startsExpr
    }),
    name: createToken("name", {
        startsExpr
    }),
    string: createToken("string", {
        startsExpr
    }),
    num: createToken("num", {
        startsExpr
    }),
    bigint: createToken("bigint", {
        startsExpr
    }),
    decimal: createToken("decimal", {
        startsExpr
    }),
    regexp: createToken("regexp", {
        startsExpr
    }),
    privateName: createToken("#name", {
        startsExpr
    }),
    eof: createToken("eof"),
    jsxName: createToken("jsxName"),
    jsxText: createToken("jsxText", {
        beforeExpr: true
    }),
    jsxTagStart: createToken("jsxTagStart", {
        startsExpr: true
    }),
    jsxTagEnd: createToken("jsxTagEnd"),
    placeholder: createToken("%%", {
        startsExpr: true
    })
};
function tokenIsIdentifier(token) {
    return token >= 87 && token <= 122;
}
function tokenKeywordOrIdentifierIsKeyword(token) {
    return token <= 86;
}
function tokenIsKeywordOrIdentifier(token) {
    return token >= 52 && token <= 122;
}
function tokenIsLiteralPropertyName(token) {
    return token >= 52 && token <= 126;
}
function tokenComesBeforeExpression(token) {
    return tokenBeforeExprs[token];
}
function tokenCanStartExpression(token) {
    return tokenStartsExprs[token];
}
function tokenIsAssignment(token) {
    return token >= 27 && token <= 31;
}
function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
    return token >= 119 && token <= 121;
}
function tokenIsLoop(token) {
    return token >= 84 && token <= 86;
}
function tokenIsKeyword(token) {
    return token >= 52 && token <= 86;
}
function tokenIsOperator(token) {
    return token >= 35 && token <= 53;
}
function tokenIsPostfix(token) {
    return token === 32;
}
function tokenIsPrefix(token) {
    return tokenPrefixes[token];
}
function tokenIsTSTypeOperator(token) {
    return token >= 111 && token <= 113;
}
function tokenIsTSDeclarationStart(token) {
    return token >= 114 && token <= 120;
}
function tokenLabelName(token) {
    return tokenLabels[token];
}
function tokenOperatorPrecedence(token) {
    return tokenBinops[token];
}
function tokenIsRightAssociative(token) {
    return token === 51;
}
function getExportedToken(token) {
    return tokenTypes1[token];
}
function isTokenType(obj) {
    return typeof obj === "number";
}
tokenTypes1[8].updateContext = (context)=>{
    context.pop();
};
tokenTypes1[5].updateContext = tokenTypes1[7].updateContext = tokenTypes1[23].updateContext = (context)=>{
    context.push(types1.brace);
};
tokenTypes1[22].updateContext = (context)=>{
    if (context[context.length - 1] === types1.template) context.pop();
    else context.push(types1.template);
};
tokenTypes1[132].updateContext = (context)=>{
    context.push(types1.j_expr, types1.j_oTag);
};
let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
let nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
const astralIdentifierStartCodes = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    13,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    2,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    68,
    310,
    10,
    21,
    11,
    7,
    25,
    5,
    2,
    41,
    2,
    8,
    70,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    349,
    41,
    7,
    1,
    79,
    28,
    11,
    0,
    9,
    21,
    43,
    17,
    47,
    20,
    28,
    22,
    13,
    52,
    58,
    1,
    3,
    0,
    14,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    85,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    159,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    38,
    6,
    186,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    19,
    72,
    264,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    328,
    18,
    190,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2637,
    96,
    16,
    1070,
    4050,
    582,
    8634,
    568,
    8,
    30,
    18,
    78,
    18,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    689,
    63,
    129,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    29,
    6135,
    9,
    1237,
    43,
    8,
    8936,
    3,
    2,
    6,
    2,
    1,
    2,
    290,
    46,
    2,
    18,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    1845,
    30,
    482,
    44,
    11,
    6,
    17,
    0,
    322,
    29,
    19,
    43,
    1269,
    6,
    2,
    3,
    2,
    1,
    2,
    14,
    2,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42719,
    33,
    4152,
    8,
    221,
    3,
    5761,
    15,
    7472,
    3104,
    541,
    1507,
    4938
];
const astralIdentifierCodes = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    370,
    1,
    154,
    10,
    50,
    3,
    123,
    2,
    54,
    14,
    32,
    10,
    3,
    1,
    11,
    3,
    46,
    10,
    8,
    0,
    46,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    161,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    193,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    84,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    406,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    330,
    3,
    19306,
    9,
    87,
    9,
    39,
    4,
    60,
    6,
    26,
    9,
    1014,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    4706,
    45,
    3,
    22,
    543,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    262,
    6,
    10,
    9,
    357,
    0,
    62,
    13,
    1495,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239
];
function isInAstralSet(code, set) {
    let pos = 65536;
    for(let i = 0, length = set.length; i < length; i += 2){
        pos += set[i];
        if (pos > code) return false;
        pos += set[i + 1];
        if (pos >= code) return true;
    }
    return false;
}
function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 65535) return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
    return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 65535) return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
const reservedWords = {
    keyword: [
        "break",
        "case",
        "catch",
        "continue",
        "debugger",
        "default",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "return",
        "switch",
        "throw",
        "try",
        "var",
        "const",
        "while",
        "with",
        "new",
        "this",
        "super",
        "class",
        "extends",
        "export",
        "import",
        "null",
        "true",
        "false",
        "in",
        "instanceof",
        "typeof",
        "void",
        "delete"
    ],
    strict: [
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "yield"
    ],
    strictBind: [
        "eval",
        "arguments"
    ]
};
const keywords = new Set(reservedWords.keyword);
const reservedWordsStrictSet = new Set(reservedWords.strict);
const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
}
function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}
function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
}
function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
}
function isKeyword(word) {
    return keywords.has(word);
}
function isIteratorStart(current, next) {
    return current === 64 && next === 64;
}
const reservedWordLikeSet = new Set([
    "break",
    "case",
    "catch",
    "continue",
    "debugger",
    "default",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "return",
    "switch",
    "throw",
    "try",
    "var",
    "const",
    "while",
    "with",
    "new",
    "this",
    "super",
    "class",
    "extends",
    "export",
    "import",
    "null",
    "true",
    "false",
    "in",
    "instanceof",
    "typeof",
    "void",
    "delete",
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield",
    "eval",
    "arguments",
    "enum",
    "await"
]);
function canBeReservedWord(word) {
    return reservedWordLikeSet.has(word);
}
const SCOPE_OTHER = 0, SCOPE_PROGRAM = 1, SCOPE_FUNCTION = 2, SCOPE_ARROW = 4, SCOPE_SIMPLE_CATCH = 8, SCOPE_SUPER = 16, SCOPE_DIRECT_SUPER = 32, SCOPE_CLASS = 64, SCOPE_STATIC_BLOCK = 128, SCOPE_TS_MODULE = 256, SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
const BIND_KIND_VALUE = 1, BIND_KIND_TYPE = 2, BIND_SCOPE_VAR = 4, BIND_SCOPE_LEXICAL = 8, BIND_SCOPE_FUNCTION = 16, BIND_FLAGS_NONE = 64, BIND_FLAGS_CLASS = 128, BIND_FLAGS_TS_ENUM = 256, BIND_FLAGS_TS_CONST_ENUM = 512, BIND_FLAGS_TS_EXPORT_ONLY = 1024, BIND_FLAGS_FLOW_DECLARE_FN = 2048;
const BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS, BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0, BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0, BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0, BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS, BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0, BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM, BIND_TS_AMBIENT = 0 | BIND_FLAGS_TS_EXPORT_ONLY, BIND_NONE = 0 | BIND_FLAGS_NONE, BIND_OUTSIDE = BIND_KIND_VALUE | 0 | BIND_FLAGS_NONE, BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM, BIND_TS_NAMESPACE = 0 | BIND_FLAGS_TS_EXPORT_ONLY, BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
const CLASS_ELEMENT_FLAG_STATIC = 4, CLASS_ELEMENT_KIND_GETTER = 2, CLASS_ELEMENT_KIND_SETTER = 1, CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
const CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC, CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC, CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER, CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER, CLASS_ELEMENT_OTHER = 0;
class Scope {
    constructor(flags){
        this.var = new Set();
        this.lexical = new Set();
        this.functions = new Set();
        this.flags = flags;
    }
}
class ScopeHandler {
    constructor(raise, inModule){
        this.scopeStack = [];
        this.undefinedExports = new Map();
        this.undefinedPrivateNames = new Map();
        this.raise = raise;
        this.inModule = inModule;
    }
    get inFunction() {
        return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
    }
    get allowSuper() {
        return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
    }
    get allowDirectSuper() {
        return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
    }
    get inClass() {
        return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
        const flags = this.currentThisScopeFlags();
        return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
    }
    get inStaticBlock() {
        for(let i = this.scopeStack.length - 1;; i--){
            const { flags  } = this.scopeStack[i];
            if (flags & SCOPE_STATIC_BLOCK) return true;
            if (flags & (SCOPE_VAR | SCOPE_CLASS)) return false;
        }
    }
    get inNonArrowFunction() {
        return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
    }
    get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(flags1) {
        return new Scope(flags1);
    }
    enter(flags2) {
        this.scopeStack.push(this.createScope(flags2));
    }
    exit() {
        this.scopeStack.pop();
    }
    treatFunctionsAsVarInScope(scope6) {
        return !!(scope6.flags & SCOPE_FUNCTION || !this.inModule && scope6.flags & SCOPE_PROGRAM);
    }
    declareName(name13, bindingType, pos9) {
        let scope = this.currentScope();
        if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
            this.checkRedeclarationInScope(scope, name13, bindingType, pos9);
            if (bindingType & BIND_SCOPE_FUNCTION) scope.functions.add(name13);
            else scope.lexical.add(name13);
            if (bindingType & BIND_SCOPE_LEXICAL) this.maybeExportDefined(scope, name13);
        } else if (bindingType & BIND_SCOPE_VAR) for(let i = this.scopeStack.length - 1; i >= 0; --i){
            scope = this.scopeStack[i];
            this.checkRedeclarationInScope(scope, name13, bindingType, pos9);
            scope.var.add(name13);
            this.maybeExportDefined(scope, name13);
            if (scope.flags & SCOPE_VAR) break;
        }
        if (this.inModule && scope.flags & SCOPE_PROGRAM) this.undefinedExports.delete(name13);
    }
    maybeExportDefined(scope1, name3) {
        if (this.inModule && scope1.flags & SCOPE_PROGRAM) this.undefinedExports.delete(name3);
    }
    checkRedeclarationInScope(scope2, name4, bindingType1, pos5) {
        if (this.isRedeclaredInScope(scope2, name4, bindingType1)) this.raise(pos5, ErrorMessages.VarRedeclaration, name4);
    }
    isRedeclaredInScope(scope3, name5, bindingType2) {
        if (!(bindingType2 & BIND_KIND_VALUE)) return false;
        if (bindingType2 & BIND_SCOPE_LEXICAL) return scope3.lexical.has(name5) || scope3.functions.has(name5) || scope3.var.has(name5);
        if (bindingType2 & BIND_SCOPE_FUNCTION) return scope3.lexical.has(name5) || !this.treatFunctionsAsVarInScope(scope3) && scope3.var.has(name5);
        return scope3.lexical.has(name5) && !(scope3.flags & SCOPE_SIMPLE_CATCH && scope3.lexical.values().next().value === name5) || !this.treatFunctionsAsVarInScope(scope3) && scope3.functions.has(name5);
    }
    checkLocalExport(id2) {
        const { name  } = id2;
        const topLevelScope = this.scopeStack[0];
        if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) this.undefinedExports.set(name, id2.start);
    }
    currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
        for(let i = this.scopeStack.length - 1;; i--){
            const { flags  } = this.scopeStack[i];
            if (flags & SCOPE_VAR) return flags;
        }
    }
    currentThisScopeFlags() {
        for(let i = this.scopeStack.length - 1;; i--){
            const { flags  } = this.scopeStack[i];
            if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) return flags;
        }
    }
}
class FlowScope extends Scope {
    constructor(...args4){
        super(...args4);
        this.declareFunctions = new Set();
    }
}
class FlowScopeHandler extends ScopeHandler {
    createScope(flags3) {
        return new FlowScope(flags3);
    }
    declareName(name6, bindingType3, pos6) {
        const scope = this.currentScope();
        if (bindingType3 & BIND_FLAGS_FLOW_DECLARE_FN) {
            this.checkRedeclarationInScope(scope, name6, bindingType3, pos6);
            this.maybeExportDefined(scope, name6);
            scope.declareFunctions.add(name6);
            return;
        }
        super.declareName(...arguments);
    }
    isRedeclaredInScope(scope4, name7, bindingType4) {
        if (super.isRedeclaredInScope(...arguments)) return true;
        if (bindingType4 & BIND_FLAGS_FLOW_DECLARE_FN) return !scope4.declareFunctions.has(name7) && (scope4.lexical.has(name7) || scope4.functions.has(name7));
        return false;
    }
    checkLocalExport(id1) {
        if (!this.scopeStack[0].declareFunctions.has(id1.name)) super.checkLocalExport(id1);
    }
}
class State {
    constructor(){
        this.strict = void 0;
        this.curLine = void 0;
        this.lineStart = void 0;
        this.startLoc = void 0;
        this.endLoc = void 0;
        this.errors = [];
        this.potentialArrowAt = -1;
        this.noArrowAt = [];
        this.noArrowParamsConversionAt = [];
        this.maybeInArrowParameters = false;
        this.inType = false;
        this.noAnonFunctionType = false;
        this.hasFlowComment = false;
        this.isAmbientContext = false;
        this.inAbstractClass = false;
        this.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
        };
        this.soloAwait = false;
        this.inFSharpPipelineDirectBody = false;
        this.labels = [];
        this.decoratorStack = [
            []
        ];
        this.comments = [];
        this.commentStack = [];
        this.pos = 0;
        this.type = 129;
        this.value = null;
        this.start = 0;
        this.end = 0;
        this.lastTokEndLoc = null;
        this.lastTokStartLoc = null;
        this.lastTokStart = 0;
        this.lastTokEnd = 0;
        this.context = [
            types1.brace
        ];
        this.canStartJSXElement = true;
        this.containsEsc = false;
        this.strictErrors = new Map();
        this.tokensLength = 0;
    }
    init({ strictMode , sourceType , startLine , startColumn  }) {
        this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
        this.curLine = startLine;
        this.lineStart = -startColumn;
        this.startLoc = this.endLoc = new Position(startLine, startColumn);
    }
    curPosition() {
        return new Position(this.curLine, this.pos - this.lineStart);
    }
    clone(skipArrays) {
        const state = new State();
        const keys = Object.keys(this);
        for(let i = 0, length = keys.length; i < length; i++){
            const key = keys[i];
            let val = this[key];
            if (!skipArrays && Array.isArray(val)) val = val.slice();
            state[key] = val;
        }
        return state;
    }
}
var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
};
const VALID_REGEX_FLAGS = new Set([
    103,
    109,
    115,
    105,
    121,
    117,
    100
]);
const forbiddenNumericSeparatorSiblings = {
    decBinOct: [
        46,
        66,
        69,
        79,
        95,
        98,
        101,
        111
    ],
    hex: [
        46,
        88,
        95,
        120
    ]
};
const allowedNumericSeparatorSiblings = {
};
allowedNumericSeparatorSiblings.bin = [
    48,
    49
];
allowedNumericSeparatorSiblings.oct = [
    ...allowedNumericSeparatorSiblings.bin,
    50,
    51,
    52,
    53,
    54,
    55
];
allowedNumericSeparatorSiblings.dec = [
    ...allowedNumericSeparatorSiblings.oct,
    56,
    57
];
allowedNumericSeparatorSiblings.hex = [
    ...allowedNumericSeparatorSiblings.dec,
    65,
    66,
    67,
    68,
    69,
    70,
    97,
    98,
    99,
    100,
    101,
    102
];
class Token {
    constructor(state2){
        this.type = state2.type;
        this.value = state2.value;
        this.start = state2.start;
        this.end = state2.end;
        this.loc = new SourceLocation(state2.startLoc, state2.endLoc);
    }
}
class Tokenizer extends ParserError {
    constructor(options1, input2){
        super();
        this.isLookahead = void 0;
        this.tokens = [];
        this.state = new State();
        this.state.init(options1);
        this.input = input2;
        this.length = input2.length;
        this.isLookahead = false;
    }
    pushToken(token5) {
        this.tokens.length = this.state.tokensLength;
        this.tokens.push(token5);
        ++this.state.tokensLength;
    }
    next() {
        this.checkKeywordEscapes();
        if (this.options.tokens) this.pushToken(new Token(this.state));
        this.state.lastTokEnd = this.state.end;
        this.state.lastTokStart = this.state.start;
        this.state.lastTokEndLoc = this.state.endLoc;
        this.state.lastTokStartLoc = this.state.startLoc;
        this.nextToken();
    }
    eat(type9) {
        if (this.match(type9)) {
            this.next();
            return true;
        } else return false;
    }
    match(type2) {
        return this.state.type === type2;
    }
    createLookaheadState(state1) {
        return {
            pos: state1.pos,
            value: null,
            type: state1.type,
            start: state1.start,
            end: state1.end,
            lastTokEnd: state1.end,
            context: [
                this.curContext()
            ],
            inType: state1.inType
        };
    }
    lookahead() {
        const old = this.state;
        this.state = this.createLookaheadState(old);
        this.isLookahead = true;
        this.nextToken();
        this.isLookahead = false;
        const curr = this.state;
        this.state = old;
        return curr;
    }
    nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(pos7) {
        skipWhiteSpace.lastIndex = pos7;
        return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos7;
    }
    lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
    }
    codePointAtPos(pos8) {
        let cp = this.input.charCodeAt(pos8);
        if ((cp & 64512) === 55296 && ++pos8 < this.input.length) {
            const trail = this.input.charCodeAt(pos8);
            if ((trail & 64512) === 56320) cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
        }
        return cp;
    }
    setStrict(strict) {
        this.state.strict = strict;
        if (strict) {
            this.state.strictErrors.forEach((message, pos)=>this.raise(pos, message)
            );
            this.state.strictErrors.clear();
        }
    }
    curContext() {
        return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
        const curContext = this.curContext();
        if (!curContext.preserveSpace) this.skipSpace();
        this.state.start = this.state.pos;
        if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
        if (this.state.pos >= this.length) {
            this.finishToken(129);
            return;
        }
        if (curContext === types1.template) this.readTmplToken();
        else this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment() {
        let startLoc;
        if (!this.isLookahead) startLoc = this.state.curPosition();
        const start = this.state.pos;
        const end = this.input.indexOf("*/", start + 2);
        if (end === -1) throw this.raise(start, ErrorMessages.UnterminatedComment);
        this.state.pos = end + 2;
        lineBreakG.lastIndex = start + 2;
        while(lineBreakG.test(this.input) && lineBreakG.lastIndex <= end){
            ++this.state.curLine;
            this.state.lineStart = lineBreakG.lastIndex;
        }
        if (this.isLookahead) return;
        const comment = {
            type: "CommentBlock",
            value: this.input.slice(start + 2, end),
            start,
            end: end + 2,
            loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.options.tokens) this.pushToken(comment);
        return comment;
    }
    skipLineComment(startSkip) {
        const start = this.state.pos;
        let startLoc;
        if (!this.isLookahead) startLoc = this.state.curPosition();
        let ch = this.input.charCodeAt(this.state.pos += startSkip);
        if (this.state.pos < this.length) while(!isNewLine(ch) && ++this.state.pos < this.length)ch = this.input.charCodeAt(this.state.pos);
        if (this.isLookahead) return;
        const end = this.state.pos;
        const value = this.input.slice(start + startSkip, end);
        const comment = {
            type: "CommentLine",
            value,
            start,
            end,
            loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.options.tokens) this.pushToken(comment);
        return comment;
    }
    skipSpace() {
        const spaceStart = this.state.pos;
        const comments = [];
        loop: while(this.state.pos < this.length){
            const ch = this.input.charCodeAt(this.state.pos);
            switch(ch){
                case 32:
                case 160:
                case 9:
                    ++this.state.pos;
                    break;
                case 13:
                    if (this.input.charCodeAt(this.state.pos + 1) === 10) ++this.state.pos;
                case 10:
                case 8232:
                case 8233:
                    ++this.state.pos;
                    ++this.state.curLine;
                    this.state.lineStart = this.state.pos;
                    break;
                case 47:
                    switch(this.input.charCodeAt(this.state.pos + 1)){
                        case 42:
                            {
                                const comment = this.skipBlockComment();
                                if (comment !== undefined) {
                                    this.addComment(comment);
                                    if (this.options.attachComment) comments.push(comment);
                                }
                                break;
                            }
                        case 47:
                            {
                                const comment = this.skipLineComment(2);
                                if (comment !== undefined) {
                                    this.addComment(comment);
                                    if (this.options.attachComment) comments.push(comment);
                                }
                                break;
                            }
                        default:
                            break loop;
                    }
                    break;
                default:
                    if (isWhitespace(ch)) ++this.state.pos;
                    else if (ch === 45 && !this.inModule) {
                        const pos = this.state.pos;
                        if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                            const comment = this.skipLineComment(3);
                            if (comment !== undefined) {
                                this.addComment(comment);
                                if (this.options.attachComment) comments.push(comment);
                            }
                        } else break loop;
                    } else if (ch === 60 && !this.inModule) {
                        const pos = this.state.pos;
                        if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                            const comment = this.skipLineComment(4);
                            if (comment !== undefined) {
                                this.addComment(comment);
                                if (this.options.attachComment) comments.push(comment);
                            }
                        } else break loop;
                    } else break loop;
            }
        }
        if (comments.length > 0) {
            const end = this.state.pos;
            const CommentWhitespace = {
                start: spaceStart,
                end,
                comments,
                leadingNode: null,
                trailingNode: null,
                containingNode: null
            };
            this.state.commentStack.push(CommentWhitespace);
        }
    }
    finishToken(type3, val2) {
        this.state.end = this.state.pos;
        const prevType = this.state.type;
        this.state.type = type3;
        this.state.value = val2;
        if (!this.isLookahead) {
            this.state.endLoc = this.state.curPosition();
            this.updateContext(prevType);
        }
    }
    replaceToken(type4) {
        this.state.type = type4;
        this.updateContext();
    }
    readToken_numberSign() {
        if (this.state.pos === 0 && this.readToken_interpreter()) return;
        const nextPos = this.state.pos + 1;
        const next = this.codePointAtPos(nextPos);
        if (next >= 48 && next <= 57) throw this.raise(this.state.pos, ErrorMessages.UnexpectedDigitAfterHash);
        if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
            this.expectPlugin("recordAndTuple");
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") throw this.raise(this.state.pos, next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType);
            this.state.pos += 2;
            if (next === 123) this.finishToken(7);
            else this.finishToken(1);
        } else if (isIdentifierStart(next)) {
            ++this.state.pos;
            this.finishToken(128, this.readWord1(next));
        } else if (next === 92) {
            ++this.state.pos;
            this.finishToken(128, this.readWord1());
        } else this.finishOp(25, 1);
    }
    readToken_dot() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next >= 48 && next <= 57) {
            this.readNumber(true);
            return;
        }
        if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
            this.state.pos += 3;
            this.finishToken(21);
        } else {
            ++this.state.pos;
            this.finishToken(16);
        }
    }
    readToken_slash() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) this.finishOp(29, 2);
        else this.finishOp(50, 1);
    }
    readToken_interpreter() {
        if (this.state.pos !== 0 || this.length < 2) return false;
        let ch = this.input.charCodeAt(this.state.pos + 1);
        if (ch !== 33) return false;
        const start = this.state.pos;
        this.state.pos += 1;
        while(!isNewLine(ch) && ++this.state.pos < this.length)ch = this.input.charCodeAt(this.state.pos);
        const value = this.input.slice(start + 2, this.state.pos);
        this.finishToken(26, value);
        return true;
    }
    readToken_mult_modulo(code7) {
        let type = code7 === 42 ? 49 : 48;
        let width = 1;
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (code7 === 42 && next === 42) {
            width++;
            next = this.input.charCodeAt(this.state.pos + 2);
            type = 51;
        }
        if (next === 61 && !this.state.inType) {
            width++;
            type = code7 === 37 ? 31 : 28;
        }
        this.finishOp(type, width);
    }
    readToken_pipe_amp(code3) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code3) {
            if (this.input.charCodeAt(this.state.pos + 2) === 61) this.finishOp(28, 3);
            else this.finishOp(code3 === 124 ? 37 : 38, 2);
            return;
        }
        if (code3 === 124) {
            if (next === 62) {
                this.finishOp(35, 2);
                return;
            }
            if (this.hasPlugin("recordAndTuple") && next === 125) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType);
                this.state.pos += 2;
                this.finishToken(9);
                return;
            }
            if (this.hasPlugin("recordAndTuple") && next === 93) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType);
                this.state.pos += 2;
                this.finishToken(4);
                return;
            }
        }
        if (next === 61) {
            this.finishOp(28, 2);
            return;
        }
        this.finishOp(code3 === 124 ? 39 : 41, 1);
    }
    readToken_caret() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61 && !this.state.inType) this.finishOp(30, 2);
        else this.finishOp(40, 1);
    }
    readToken_plus_min(code4) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code4) {
            this.finishOp(32, 2);
            return;
        }
        if (next === 61) this.finishOp(28, 2);
        else this.finishOp(47, 1);
    }
    readToken_lt() {
        const { pos  } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 60) {
            if (this.input.charCodeAt(pos + 2) === 61) {
                this.finishOp(28, 3);
                return;
            }
            this.finishOp(46, 2);
            return;
        }
        if (next === 61) {
            this.finishOp(45, 2);
            return;
        }
        this.finishOp(43, 1);
    }
    readToken_gt() {
        const { pos  } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 62) {
            const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(pos + size) === 61) {
                this.finishOp(28, size + 1);
                return;
            }
            this.finishOp(46, size);
            return;
        }
        if (next === 61) {
            this.finishOp(45, 2);
            return;
        }
        this.finishOp(44, 1);
    }
    readToken_eq_excl(code5) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
            this.finishOp(42, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
            return;
        }
        if (code5 === 61 && next === 62) {
            this.state.pos += 2;
            this.finishToken(19);
            return;
        }
        this.finishOp(code5 === 61 ? 27 : 33, 1);
    }
    readToken_question() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        const next2 = this.input.charCodeAt(this.state.pos + 2);
        if (next === 63) {
            if (next2 === 61) this.finishOp(28, 3);
            else this.finishOp(36, 2);
        } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
            this.state.pos += 2;
            this.finishToken(18);
        } else {
            ++this.state.pos;
            this.finishToken(17);
        }
    }
    getTokenFromCode(code6) {
        switch(code6){
            case 46:
                this.readToken_dot();
                return;
            case 40:
                ++this.state.pos;
                this.finishToken(10);
                return;
            case 41:
                ++this.state.pos;
                this.finishToken(11);
                return;
            case 59:
                ++this.state.pos;
                this.finishToken(13);
                return;
            case 44:
                ++this.state.pos;
                this.finishToken(12);
                return;
            case 91:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType);
                    this.state.pos += 2;
                    this.finishToken(2);
                } else {
                    ++this.state.pos;
                    this.finishToken(0);
                }
                return;
            case 93:
                ++this.state.pos;
                this.finishToken(3);
                return;
            case 123:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType);
                    this.state.pos += 2;
                    this.finishToken(6);
                } else {
                    ++this.state.pos;
                    this.finishToken(5);
                }
                return;
            case 125:
                ++this.state.pos;
                this.finishToken(8);
                return;
            case 58:
                if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) this.finishOp(15, 2);
                else {
                    ++this.state.pos;
                    this.finishToken(14);
                }
                return;
            case 63:
                this.readToken_question();
                return;
            case 96:
                ++this.state.pos;
                this.finishToken(22);
                return;
            case 48:
                {
                    const next = this.input.charCodeAt(this.state.pos + 1);
                    if (next === 120 || next === 88) {
                        this.readRadixNumber(16);
                        return;
                    }
                    if (next === 111 || next === 79) {
                        this.readRadixNumber(8);
                        return;
                    }
                    if (next === 98 || next === 66) {
                        this.readRadixNumber(2);
                        return;
                    }
                }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
                this.readNumber(false);
                return;
            case 34:
            case 39:
                this.readString(code6);
                return;
            case 47:
                this.readToken_slash();
                return;
            case 37:
            case 42:
                this.readToken_mult_modulo(code6);
                return;
            case 124:
            case 38:
                this.readToken_pipe_amp(code6);
                return;
            case 94:
                this.readToken_caret();
                return;
            case 43:
            case 45:
                this.readToken_plus_min(code6);
                return;
            case 60:
                this.readToken_lt();
                return;
            case 62:
                this.readToken_gt();
                return;
            case 61:
            case 33:
                this.readToken_eq_excl(code6);
                return;
            case 126:
                this.finishOp(34, 1);
                return;
            case 64:
                ++this.state.pos;
                this.finishToken(24);
                return;
            case 35:
                this.readToken_numberSign();
                return;
            case 92:
                this.readWord();
                return;
            default:
                if (isIdentifierStart(code6)) {
                    this.readWord(code6);
                    return;
                }
        }
        throw this.raise(this.state.pos, ErrorMessages.InvalidOrUnexpectedToken, String.fromCodePoint(code6));
    }
    finishOp(type5, size) {
        const str = this.input.slice(this.state.pos, this.state.pos + size);
        this.state.pos += size;
        this.finishToken(type5, str);
    }
    readRegexp() {
        const start = this.state.start + 1;
        let escaped, inClass;
        let { pos  } = this.state;
        for(;; ++pos){
            if (pos >= this.length) throw this.raise(start, ErrorMessages.UnterminatedRegExp);
            const ch = this.input.charCodeAt(pos);
            if (isNewLine(ch)) throw this.raise(start, ErrorMessages.UnterminatedRegExp);
            if (escaped) escaped = false;
            else {
                if (ch === 91) inClass = true;
                else if (ch === 93 && inClass) inClass = false;
                else if (ch === 47 && !inClass) break;
                escaped = ch === 92;
            }
        }
        const content = this.input.slice(start, pos);
        ++pos;
        let mods = "";
        while(pos < this.length){
            const cp = this.codePointAtPos(pos);
            const char = String.fromCharCode(cp);
            if (VALID_REGEX_FLAGS.has(cp)) {
                if (mods.includes(char)) this.raise(pos + 1, ErrorMessages.DuplicateRegExpFlags);
            } else if (isIdentifierChar(cp) || cp === 92) this.raise(pos + 1, ErrorMessages.MalformedRegExpFlags);
            else break;
            ++pos;
            mods += char;
        }
        this.state.pos = pos;
        this.finishToken(127, {
            pattern: content,
            flags: mods
        });
    }
    readInt(radix, len, forceLen, allowNumSeparator = true) {
        const start = this.state.pos;
        const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
        const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
        let invalid = false;
        let total = 0;
        for(let i = 0, e = len == null ? Infinity : len; i < e; ++i){
            const code = this.input.charCodeAt(this.state.pos);
            let val;
            if (code === 95) {
                const prev = this.input.charCodeAt(this.state.pos - 1);
                const next = this.input.charCodeAt(this.state.pos + 1);
                if (allowedSiblings.indexOf(next) === -1) this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
                else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
                if (!allowNumSeparator) this.raise(this.state.pos, ErrorMessages.NumericSeparatorInEscapeSequence);
                ++this.state.pos;
                continue;
            }
            if (code >= 97) val = code - 97 + 10;
            else if (code >= 65) val = code - 65 + 10;
            else if (_isDigit(code)) val = code - 48;
            else val = Infinity;
            if (val >= radix) {
                if (this.options.errorRecovery && val <= 9) {
                    val = 0;
                    this.raise(this.state.start + i + 2, ErrorMessages.InvalidDigit, radix);
                } else if (forceLen) {
                    val = 0;
                    invalid = true;
                } else break;
            }
            ++this.state.pos;
            total = total * radix + val;
        }
        if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) return null;
        return total;
    }
    readRadixNumber(radix1) {
        const start = this.state.pos;
        let isBigInt = false;
        this.state.pos += 2;
        const val = this.readInt(radix1);
        if (val == null) this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix1);
        const next = this.input.charCodeAt(this.state.pos);
        if (next === 110) {
            ++this.state.pos;
            isBigInt = true;
        } else if (next === 109) throw this.raise(start, ErrorMessages.InvalidDecimal);
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
        if (isBigInt) {
            const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
            this.finishToken(125, str);
            return;
        }
        this.finishToken(124, val);
    }
    readNumber(startsWithDot) {
        const start = this.state.pos;
        let isFloat = false;
        let isBigInt = false;
        let isDecimal = false;
        let hasExponent = false;
        let isOctal = false;
        if (!startsWithDot && this.readInt(10) === null) this.raise(start, ErrorMessages.InvalidNumber);
        const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (hasLeadingZero) {
            const integer = this.input.slice(start, this.state.pos);
            this.recordStrictModeErrors(start, ErrorMessages.StrictOctalLiteral);
            if (!this.state.strict) {
                const underscorePos = integer.indexOf("_");
                if (underscorePos > 0) this.raise(underscorePos + start, ErrorMessages.ZeroDigitNumericSeparator);
            }
            isOctal = hasLeadingZero && !/[89]/.test(integer);
        }
        let next = this.input.charCodeAt(this.state.pos);
        if (next === 46 && !isOctal) {
            ++this.state.pos;
            this.readInt(10);
            isFloat = true;
            next = this.input.charCodeAt(this.state.pos);
        }
        if ((next === 69 || next === 101) && !isOctal) {
            next = this.input.charCodeAt(++this.state.pos);
            if (next === 43 || next === 45) ++this.state.pos;
            if (this.readInt(10) === null) this.raise(start, ErrorMessages.InvalidOrMissingExponent);
            isFloat = true;
            hasExponent = true;
            next = this.input.charCodeAt(this.state.pos);
        }
        if (next === 110) {
            if (isFloat || hasLeadingZero) this.raise(start, ErrorMessages.InvalidBigIntLiteral);
            ++this.state.pos;
            isBigInt = true;
        }
        if (next === 109) {
            this.expectPlugin("decimal", this.state.pos);
            if (hasExponent || hasLeadingZero) this.raise(start, ErrorMessages.InvalidDecimal);
            ++this.state.pos;
            isDecimal = true;
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
        const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
        if (isBigInt) {
            this.finishToken(125, str);
            return;
        }
        if (isDecimal) {
            this.finishToken(126, str);
            return;
        }
        const val = isOctal ? parseInt(str, 8) : parseFloat(str);
        this.finishToken(124, val);
    }
    readCodePoint(throwOnInvalid) {
        const ch = this.input.charCodeAt(this.state.pos);
        let code;
        if (ch === 123) {
            const codePos = ++this.state.pos;
            code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
            ++this.state.pos;
            if (code !== null && code > 1114111) {
                if (throwOnInvalid) this.raise(codePos, ErrorMessages.InvalidCodePoint);
                else return null;
            }
        } else code = this.readHexChar(4, false, throwOnInvalid);
        return code;
    }
    readString(quote1) {
        let out = "", chunkStart = ++this.state.pos;
        for(;;){
            if (this.state.pos >= this.length) throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
            const ch = this.input.charCodeAt(this.state.pos);
            if (ch === quote1) break;
            if (ch === 92) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.readEscapedChar(false);
                chunkStart = this.state.pos;
            } else if (ch === 8232 || ch === 8233) {
                ++this.state.pos;
                ++this.state.curLine;
                this.state.lineStart = this.state.pos;
            } else if (isNewLine(ch)) throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
            else ++this.state.pos;
        }
        out += this.input.slice(chunkStart, this.state.pos++);
        this.finishToken(123, out);
    }
    readTmplToken() {
        let out = "", chunkStart = this.state.pos, containsInvalid = false;
        for(;;){
            if (this.state.pos >= this.length) throw this.raise(this.state.start, ErrorMessages.UnterminatedTemplate);
            const ch = this.input.charCodeAt(this.state.pos);
            if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
                if (this.state.pos === this.state.start && this.match(20)) {
                    if (ch === 36) {
                        this.state.pos += 2;
                        this.finishToken(23);
                        return;
                    } else {
                        ++this.state.pos;
                        this.finishToken(22);
                        return;
                    }
                }
                out += this.input.slice(chunkStart, this.state.pos);
                this.finishToken(20, containsInvalid ? null : out);
                return;
            }
            if (ch === 92) {
                out += this.input.slice(chunkStart, this.state.pos);
                const escaped = this.readEscapedChar(true);
                if (escaped === null) containsInvalid = true;
                else out += escaped;
                chunkStart = this.state.pos;
            } else if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                ++this.state.pos;
                switch(ch){
                    case 13:
                        if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos;
                    case 10:
                        out += "\n";
                        break;
                    default:
                        out += String.fromCharCode(ch);
                        break;
                }
                ++this.state.curLine;
                this.state.lineStart = this.state.pos;
                chunkStart = this.state.pos;
            } else ++this.state.pos;
        }
    }
    recordStrictModeErrors(pos17, message3) {
        if (this.state.strict && !this.state.strictErrors.has(pos17)) this.raise(pos17, message3);
        else this.state.strictErrors.set(pos17, message3);
    }
    readEscapedChar(inTemplate) {
        const throwOnInvalid = !inTemplate;
        const ch = this.input.charCodeAt(++this.state.pos);
        ++this.state.pos;
        switch(ch){
            case 110:
                return "\n";
            case 114:
                return "\r";
            case 120:
                {
                    const code = this.readHexChar(2, false, throwOnInvalid);
                    return code === null ? null : String.fromCharCode(code);
                }
            case 117:
                {
                    const code = this.readCodePoint(throwOnInvalid);
                    return code === null ? null : String.fromCodePoint(code);
                }
            case 116:
                return "\t";
            case 98:
                return "\b";
            case 118:
                return "\u000b";
            case 102:
                return "\f";
            case 13:
                if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos;
            case 10:
                this.state.lineStart = this.state.pos;
                ++this.state.curLine;
            case 8232:
            case 8233:
                return "";
            case 56:
            case 57:
                if (inTemplate) return null;
                else this.recordStrictModeErrors(this.state.pos - 1, ErrorMessages.StrictNumericEscape);
            default:
                if (ch >= 48 && ch <= 55) {
                    const codePos = this.state.pos - 1;
                    const match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);
                    let octalStr = match[0];
                    let octal = parseInt(octalStr, 8);
                    if (octal > 255) {
                        octalStr = octalStr.slice(0, -1);
                        octal = parseInt(octalStr, 8);
                    }
                    this.state.pos += octalStr.length - 1;
                    const next = this.input.charCodeAt(this.state.pos);
                    if (octalStr !== "0" || next === 56 || next === 57) {
                        if (inTemplate) return null;
                        else this.recordStrictModeErrors(codePos, ErrorMessages.StrictNumericEscape);
                    }
                    return String.fromCharCode(octal);
                }
                return String.fromCharCode(ch);
        }
    }
    readHexChar(len1, forceLen1, throwOnInvalid1) {
        const codePos = this.state.pos;
        const n = this.readInt(16, len1, forceLen1, false);
        if (n === null) {
            if (throwOnInvalid1) this.raise(codePos, ErrorMessages.InvalidEscapeSequence);
            else this.state.pos = codePos - 1;
        }
        return n;
    }
    readWord1(firstCode) {
        this.state.containsEsc = false;
        let word = "";
        const start = this.state.pos;
        let chunkStart = this.state.pos;
        if (firstCode !== undefined) this.state.pos += firstCode <= 65535 ? 1 : 2;
        while(this.state.pos < this.length){
            const ch = this.codePointAtPos(this.state.pos);
            if (isIdentifierChar(ch)) this.state.pos += ch <= 65535 ? 1 : 2;
            else if (ch === 92) {
                this.state.containsEsc = true;
                word += this.input.slice(chunkStart, this.state.pos);
                const escStart = this.state.pos;
                const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
                if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);
                    chunkStart = this.state.pos - 1;
                    continue;
                }
                ++this.state.pos;
                const esc = this.readCodePoint(true);
                if (esc !== null) {
                    if (!identifierCheck(esc)) this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier);
                    word += String.fromCodePoint(esc);
                }
                chunkStart = this.state.pos;
            } else break;
        }
        return word + this.input.slice(chunkStart, this.state.pos);
    }
    readWord(firstCode1) {
        const word = this.readWord1(firstCode1);
        const type = keywords$1.get(word);
        if (type !== undefined) this.finishToken(type, tokenLabelName(type));
        else this.finishToken(122, word);
    }
    checkKeywordEscapes() {
        const { type  } = this.state;
        if (tokenIsKeyword(type) && this.state.containsEsc) this.raise(this.state.start, ErrorMessages.InvalidEscapedReservedWord, tokenLabelName(type));
    }
    updateContext(prevType1) {
        const { context , type  } = this.state;
        switch(type){
            case 8:
                context.pop();
                break;
            case 5:
            case 7:
            case 23:
                context.push(types1.brace);
                break;
            case 22:
                if (context[context.length - 1] === types1.template) context.pop();
                else context.push(types1.template);
                break;
        }
    }
}
class ClassScope {
    constructor(){
        this.privateNames = new Set();
        this.loneAccessors = new Map();
        this.undefinedPrivateNames = new Map();
    }
}
class ClassScopeHandler {
    constructor(raise1){
        this.stack = [];
        this.undefinedPrivateNames = new Map();
        this.raise = raise1;
    }
    current() {
        return this.stack[this.stack.length - 1];
    }
    enter() {
        this.stack.push(new ClassScope());
    }
    exit() {
        const oldClassScope = this.stack.pop();
        const current = this.current();
        for (const [name, pos] of Array.from(oldClassScope.undefinedPrivateNames)){
            if (current) {
                if (!current.undefinedPrivateNames.has(name)) current.undefinedPrivateNames.set(name, pos);
            } else this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
        }
    }
    declarePrivateName(name8, elementType, pos10) {
        const classScope = this.current();
        let redefined = classScope.privateNames.has(name8);
        if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
            const accessor = redefined && classScope.loneAccessors.get(name8);
            if (accessor) {
                const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
                const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
                const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
                const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
                redefined = oldKind === newKind || oldStatic !== newStatic;
                if (!redefined) classScope.loneAccessors.delete(name8);
            } else if (!redefined) classScope.loneAccessors.set(name8, elementType);
        }
        if (redefined) this.raise(pos10, ErrorMessages.PrivateNameRedeclaration, name8);
        classScope.privateNames.add(name8);
        classScope.undefinedPrivateNames.delete(name8);
    }
    usePrivateName(name9, pos11) {
        let classScope;
        for (classScope of this.stack){
            if (classScope.privateNames.has(name9)) return;
        }
        if (classScope) classScope.undefinedPrivateNames.set(name9, pos11);
        else this.raise(pos11, ErrorMessages.InvalidPrivateFieldResolution, name9);
    }
}
const kExpression = 0, kMaybeArrowParameterDeclaration = 1, kMaybeAsyncArrowParameterDeclaration = 2, kParameterDeclaration = 3;
class ExpressionScope {
    constructor(type6 = kExpression){
        this.type = void 0;
        this.type = type6;
    }
    canBeArrowParameterDeclaration() {
        return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
    }
    isCertainlyParameterDeclaration() {
        return this.type === kParameterDeclaration;
    }
}
class ArrowHeadParsingScope extends ExpressionScope {
    constructor(type7){
        super(type7);
        this.errors = new Map();
    }
    recordDeclarationError(pos12, template2) {
        this.errors.set(pos12, template2);
    }
    clearDeclarationError(pos13) {
        this.errors.delete(pos13);
    }
    iterateErrors(iterator) {
        this.errors.forEach(iterator);
    }
}
class ExpressionScopeHandler {
    constructor(raise2){
        this.stack = [
            new ExpressionScope()
        ];
        this.raise = raise2;
    }
    enter(scope5) {
        this.stack.push(scope5);
    }
    exit() {
        this.stack.pop();
    }
    recordParameterInitializerError(pos14, template3) {
        const { stack  } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while(!scope.isCertainlyParameterDeclaration()){
            if (scope.canBeArrowParameterDeclaration()) scope.recordDeclarationError(pos14, template3);
            else return;
            scope = stack[--i];
        }
        this.raise(pos14, template3);
    }
    recordParenthesizedIdentifierError(pos15, template4) {
        const { stack  } = this;
        const scope = stack[stack.length - 1];
        if (scope.isCertainlyParameterDeclaration()) this.raise(pos15, template4);
        else if (scope.canBeArrowParameterDeclaration()) scope.recordDeclarationError(pos15, template4);
        else return;
    }
    recordAsyncArrowParametersError(pos16, template5) {
        const { stack  } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while(scope.canBeArrowParameterDeclaration()){
            if (scope.type === kMaybeAsyncArrowParameterDeclaration) scope.recordDeclarationError(pos16, template5);
            scope = stack[--i];
        }
    }
    validateAsPattern() {
        const { stack  } = this;
        const currentScope = stack[stack.length - 1];
        if (!currentScope.canBeArrowParameterDeclaration()) return;
        currentScope.iterateErrors((template, pos)=>{
            this.raise(pos, template);
            let i = stack.length - 2;
            let scope = stack[i];
            while(scope.canBeArrowParameterDeclaration()){
                scope.clearDeclarationError(pos);
                scope = stack[--i];
            }
        });
    }
}
function newParameterDeclarationScope() {
    return new ExpressionScope(kParameterDeclaration);
}
function newArrowHeadScope() {
    return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
}
function newAsyncArrowScope() {
    return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
}
function newExpressionScope() {
    return new ExpressionScope();
}
const PARAM = 0, PARAM_YIELD = 1, PARAM_AWAIT = 2, PARAM_RETURN = 4, PARAM_IN = 8;
class ProductionParameterHandler {
    constructor(){
        this.stacks = [];
    }
    enter(flags4) {
        this.stacks.push(flags4);
    }
    exit() {
        this.stacks.pop();
    }
    currentFlags() {
        return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
        return (this.currentFlags() & PARAM_AWAIT) > 0;
    }
    get hasYield() {
        return (this.currentFlags() & PARAM_YIELD) > 0;
    }
    get hasReturn() {
        return (this.currentFlags() & PARAM_RETURN) > 0;
    }
    get hasIn() {
        return (this.currentFlags() & PARAM_IN) > 0;
    }
}
function functionFlags(isAsync, isGenerator) {
    return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
}
class UtilParser extends Tokenizer {
    addExtra(node27, key1, val1) {
        if (!node27) return;
        const extra = node27.extra = node27.extra || {
        };
        extra[key1] = val1;
    }
    isContextual(token2) {
        return this.state.type === token2 && !this.state.containsEsc;
    }
    isUnparsedContextual(nameStart, name10) {
        const nameEnd = nameStart + name10.length;
        if (this.input.slice(nameStart, nameEnd) === name10) {
            const nextCh = this.input.charCodeAt(nameEnd);
            return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
        }
        return false;
    }
    isLookaheadContextual(name11) {
        const next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name11);
    }
    eatContextual(token3) {
        if (this.isContextual(token3)) {
            this.next();
            return true;
        }
        return false;
    }
    expectContextual(token4, template) {
        if (!this.eatContextual(token4)) this.unexpected(null, template);
    }
    canInsertSemicolon() {
        return this.match(129) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
        return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    }
    hasFollowingLineBreak() {
        skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
        return skipWhiteSpaceToLineBreak.test(this.input);
    }
    isLineTerminator() {
        return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(allowAsi = true) {
        if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
        this.raise(this.state.lastTokEnd, ErrorMessages.MissingSemicolon);
    }
    expect(type8, pos24) {
        this.eat(type8) || this.unexpected(pos24, type8);
    }
    assertNoSpace(message2 = "Unexpected space.") {
        if (this.state.start > this.state.lastTokEnd) this.raise(this.state.lastTokEnd, {
            code: ErrorCodes.SyntaxError,
            reasonCode: "UnexpectedSpace",
            template: message2
        });
    }
    unexpected(pos18, messageOrType = {
        code: ErrorCodes.SyntaxError,
        reasonCode: "UnexpectedToken",
        template: "Unexpected token"
    }) {
        if (isTokenType(messageOrType)) messageOrType = {
            code: ErrorCodes.SyntaxError,
            reasonCode: "UnexpectedToken",
            template: `Unexpected token, expected "${tokenLabelName(messageOrType)}"`
        };
        throw this.raise(pos18 != null ? pos18 : this.state.start, messageOrType);
    }
    expectPlugin(name12, pos19) {
        if (!this.hasPlugin(name12)) throw this.raiseWithData(pos19 != null ? pos19 : this.state.start, {
            missingPlugin: [
                name12
            ]
        }, `This experimental syntax requires enabling the parser plugin: '${name12}'`);
        return true;
    }
    expectOnePlugin(names, pos20) {
        if (!names.some((n)=>this.hasPlugin(n)
        )) throw this.raiseWithData(pos20 != null ? pos20 : this.state.start, {
            missingPlugin: names
        }, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(", ")}'`);
    }
    tryParse(fn, oldState = this.state.clone()) {
        const abortSignal = {
            node: null
        };
        try {
            const node20 = fn((node = null)=>{
                abortSignal.node = node;
                throw abortSignal;
            });
            if (this.state.errors.length > oldState.errors.length) {
                const failState = this.state;
                this.state = oldState;
                this.state.tokensLength = failState.tokensLength;
                return {
                    node: node20,
                    error: failState.errors[oldState.errors.length],
                    thrown: false,
                    aborted: false,
                    failState
                };
            }
            return {
                node: node20,
                error: null,
                thrown: false,
                aborted: false,
                failState: null
            };
        } catch (error) {
            const failState = this.state;
            this.state = oldState;
            if (error instanceof SyntaxError) return {
                node: null,
                error,
                thrown: true,
                aborted: false,
                failState
            };
            if (error === abortSignal) return {
                node: abortSignal.node,
                error: null,
                thrown: false,
                aborted: true,
                failState
            };
            throw error;
        }
    }
    checkExpressionErrors(refExpressionErrors1, andThrow) {
        if (!refExpressionErrors1) return false;
        const { shorthandAssign , doubleProto , optionalParameters  } = refExpressionErrors1;
        if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0 || optionalParameters >= 0;
        if (shorthandAssign >= 0) this.unexpected(shorthandAssign);
        if (doubleProto >= 0) this.raise(doubleProto, ErrorMessages.DuplicateProto);
        if (optionalParameters >= 0) this.unexpected(optionalParameters);
    }
    isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.state.type);
    }
    isPrivateName(node21) {
        return node21.type === "PrivateName";
    }
    getPrivateNameSV(node22) {
        return node22.id.name;
    }
    hasPropertyAsPrivateName(node23) {
        return (node23.type === "MemberExpression" || node23.type === "OptionalMemberExpression") && this.isPrivateName(node23.property);
    }
    isOptionalChain(node24) {
        return node24.type === "OptionalMemberExpression" || node24.type === "OptionalCallExpression";
    }
    isObjectProperty(node25) {
        return node25.type === "ObjectProperty";
    }
    isObjectMethod(node26) {
        return node26.type === "ObjectMethod";
    }
    initializeScopes(inModule1 = this.options.sourceType === "module") {
        const oldLabels = this.state.labels;
        this.state.labels = [];
        const oldExportedIdentifiers = this.exportedIdentifiers;
        this.exportedIdentifiers = new Set();
        const oldInModule = this.inModule;
        this.inModule = inModule1;
        const oldScope = this.scope;
        const ScopeHandler = this.getScopeHandler();
        this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);
        const oldProdParam = this.prodParam;
        this.prodParam = new ProductionParameterHandler();
        const oldClassScope = this.classScope;
        this.classScope = new ClassScopeHandler(this.raise.bind(this));
        const oldExpressionScope = this.expressionScope;
        this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));
        return ()=>{
            this.state.labels = oldLabels;
            this.exportedIdentifiers = oldExportedIdentifiers;
            this.inModule = oldInModule;
            this.scope = oldScope;
            this.prodParam = oldProdParam;
            this.classScope = oldClassScope;
            this.expressionScope = oldExpressionScope;
        };
    }
    enterInitialScopes() {
        let paramFlags = PARAM;
        if (this.inModule) paramFlags |= PARAM_AWAIT;
        this.scope.enter(SCOPE_PROGRAM);
        this.prodParam.enter(paramFlags);
    }
}
class ExpressionErrors {
    constructor(){
        this.shorthandAssign = -1;
        this.doubleProto = -1;
        this.optionalParameters = -1;
    }
}
class Node {
    constructor(parser1, pos21, loc1){
        this.type = "";
        this.start = pos21;
        this.end = 0;
        this.loc = new SourceLocation(loc1);
        if (parser1 != null && parser1.options.ranges) this.range = [
            pos21,
            0
        ];
        if (parser1 != null && parser1.filename) this.loc.filename = parser1.filename;
    }
}
const NodePrototype = Node.prototype;
NodePrototype.__clone = function() {
    const newNode = new Node();
    const keys = Object.keys(this);
    for(let i = 0, length = keys.length; i < length; i++){
        const key = keys[i];
        if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") newNode[key] = this[key];
    }
    return newNode;
};
function clonePlaceholder(node) {
    return cloneIdentifier(node);
}
function cloneIdentifier(node) {
    const { type , start , end , loc , range , extra , name  } = node;
    const cloned = Object.create(NodePrototype);
    cloned.type = type;
    cloned.start = start;
    cloned.end = end;
    cloned.loc = loc;
    cloned.range = range;
    cloned.extra = extra;
    cloned.name = name;
    if (type === "Placeholder") cloned.expectedNode = node.expectedNode;
    return cloned;
}
function cloneStringLiteral(node) {
    const { type , start , end , loc , range , extra  } = node;
    if (type === "Placeholder") return clonePlaceholder(node);
    const cloned = Object.create(NodePrototype);
    cloned.type = "StringLiteral";
    cloned.start = start;
    cloned.end = end;
    cloned.loc = loc;
    cloned.range = range;
    cloned.extra = extra;
    cloned.value = node.value;
    return cloned;
}
class NodeUtils extends UtilParser {
    startNode() {
        return new Node(this, this.state.start, this.state.startLoc);
    }
    startNodeAt(pos22, loc3) {
        return new Node(this, pos22, loc3);
    }
    startNodeAtNode(type12) {
        return this.startNodeAt(type12.start, type12.loc.start);
    }
    finishNode(node32, type10) {
        return this.finishNodeAt(node32, type10, this.state.lastTokEnd, this.state.lastTokEndLoc);
    }
    finishNodeAt(node28, type11, pos23, loc2) {
        node28.type = type11;
        node28.end = pos23;
        node28.loc.end = loc2;
        if (this.options.ranges) node28.range[1] = pos23;
        if (this.options.attachComment) this.processComment(node28);
        return node28;
    }
    resetStartLocation(node29, start3, startLoc2) {
        node29.start = start3;
        node29.loc.start = startLoc2;
        if (this.options.ranges) node29.range[0] = start3;
    }
    resetEndLocation(node30, end3 = this.state.lastTokEnd, endLoc = this.state.lastTokEndLoc) {
        node30.end = end3;
        node30.loc.end = endLoc;
        if (this.options.ranges) node30.range[1] = end3;
    }
    resetStartLocationFromNode(node31, locationNode) {
        this.resetStartLocation(node31, locationNode.start, locationNode.loc.start);
    }
}
const reservedTypes = new Set([
    "_",
    "any",
    "bool",
    "boolean",
    "empty",
    "extends",
    "false",
    "interface",
    "mixed",
    "null",
    "number",
    "static",
    "string",
    "true",
    "typeof",
    "void"
]);
const FlowErrors = makeErrorTemplates({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
    AssignReservedType: "Cannot overwrite reserved type %0.",
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
    EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
    EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
    EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
    EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
    EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
    EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
    EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
    EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
    EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
    EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: "Unexpected reserved type %0.",
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.",
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
}, ErrorCodes.SyntaxError, "flow");
function isEsModuleType(bodyElement) {
    return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
}
function hasTypeImportKind(node) {
    return node.importKind === "type" || node.importKind === "typeof";
}
function isMaybeDefaultImport(type) {
    return tokenIsKeywordOrIdentifier(type) && type !== 91;
}
const exportSuggestions = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
};
function partition(list, test) {
    const list1 = [];
    const list2 = [];
    for(let i = 0; i < list.length; i++)(test(list[i], i, list) ? list1 : list2).push(list[i]);
    return [
        list1,
        list2
    ];
}
const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
var flow = (superClass)=>class extends superClass {
        constructor(...args){
            super(...args);
            this.flowPragma = undefined;
        }
        getScopeHandler() {
            return FlowScopeHandler;
        }
        shouldParseTypes() {
            return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
        }
        shouldParseEnums() {
            return !!this.getPluginOption("flow", "enums");
        }
        finishToken(type, val) {
            if (type !== 123 && type !== 13 && type !== 26) {
                if (this.flowPragma === undefined) this.flowPragma = null;
            }
            return super.finishToken(type, val);
        }
        addComment(comment) {
            if (this.flowPragma === undefined) {
                const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
                if (!matches) ;
                else if (matches[1] === "flow") this.flowPragma = "flow";
                else if (matches[1] === "noflow") this.flowPragma = "noflow";
                else throw new Error("Unexpected flow pragma");
            }
            return super.addComment(comment);
        }
        flowParseTypeInitialiser(tok) {
            const oldInType = this.state.inType;
            this.state.inType = true;
            this.expect(tok || 14);
            const type = this.flowParseType();
            this.state.inType = oldInType;
            return type;
        }
        flowParsePredicate() {
            const node = this.startNode();
            const moduloPos = this.state.start;
            this.next();
            this.expectContextual(101);
            if (this.state.lastTokStart > moduloPos + 1) this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);
            if (this.eat(10)) {
                node.value = this.parseExpression();
                this.expect(11);
                return this.finishNode(node, "DeclaredPredicate");
            } else return this.finishNode(node, "InferredPredicate");
        }
        flowParseTypeAndPredicateInitialiser() {
            const oldInType = this.state.inType;
            this.state.inType = true;
            this.expect(14);
            let type = null;
            let predicate = null;
            if (this.match(48)) {
                this.state.inType = oldInType;
                predicate = this.flowParsePredicate();
            } else {
                type = this.flowParseType();
                this.state.inType = oldInType;
                if (this.match(48)) predicate = this.flowParsePredicate();
            }
            return [
                type,
                predicate
            ];
        }
        flowParseDeclareClass(node57) {
            this.next();
            this.flowParseInterfaceish(node57, true);
            return this.finishNode(node57, "DeclareClass");
        }
        flowParseDeclareFunction(node33) {
            this.next();
            const id = node33.id = this.parseIdentifier();
            const typeNode = this.startNode();
            const typeContainer = this.startNode();
            if (this.match(43)) typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
            else typeNode.typeParameters = null;
            this.expect(10);
            const tmp = this.flowParseFunctionTypeParams();
            typeNode.params = tmp.params;
            typeNode.rest = tmp.rest;
            typeNode.this = tmp._this;
            this.expect(11);
            [typeNode.returnType, node33.predicate] = this.flowParseTypeAndPredicateInitialiser();
            typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
            id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
            this.resetEndLocation(id);
            this.semicolon();
            this.scope.declareName(node33.id.name, BIND_FLOW_DECLARE_FN, node33.id.start);
            return this.finishNode(node33, "DeclareFunction");
        }
        flowParseDeclare(node34, insideModule) {
            if (this.match(74)) return this.flowParseDeclareClass(node34);
            else if (this.match(62)) return this.flowParseDeclareFunction(node34);
            else if (this.match(68)) return this.flowParseDeclareVariable(node34);
            else if (this.eatContextual(117)) {
                if (this.match(16)) return this.flowParseDeclareModuleExports(node34);
                else {
                    if (insideModule) this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);
                    return this.flowParseDeclareModule(node34);
                }
            } else if (this.isContextual(120)) return this.flowParseDeclareTypeAlias(node34);
            else if (this.isContextual(121)) return this.flowParseDeclareOpaqueType(node34);
            else if (this.isContextual(119)) return this.flowParseDeclareInterface(node34);
            else if (this.match(76)) return this.flowParseDeclareExportDeclaration(node34, insideModule);
            else throw this.unexpected();
        }
        flowParseDeclareVariable(node35) {
            this.next();
            node35.id = this.flowParseTypeAnnotatableIdentifier(true);
            this.scope.declareName(node35.id.name, BIND_VAR, node35.id.start);
            this.semicolon();
            return this.finishNode(node35, "DeclareVariable");
        }
        flowParseDeclareModule(node36) {
            this.scope.enter(SCOPE_OTHER);
            if (this.match(123)) node36.id = this.parseExprAtom();
            else node36.id = this.parseIdentifier();
            const bodyNode = node36.body = this.startNode();
            const body = bodyNode.body = [];
            this.expect(5);
            while(!this.match(8)){
                let bodyNode = this.startNode();
                if (this.match(77)) {
                    this.next();
                    if (!this.isContextual(120) && !this.match(81)) this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);
                    this.parseImport(bodyNode);
                } else {
                    this.expectContextual(115, FlowErrors.UnsupportedStatementInDeclareModule);
                    bodyNode = this.flowParseDeclare(bodyNode, true);
                }
                body.push(bodyNode);
            }
            this.scope.exit();
            this.expect(8);
            this.finishNode(bodyNode, "BlockStatement");
            let kind = null;
            let hasModuleExport = false;
            body.forEach((bodyElement)=>{
                if (isEsModuleType(bodyElement)) {
                    if (kind === "CommonJS") this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
                    kind = "ES";
                } else if (bodyElement.type === "DeclareModuleExports") {
                    if (hasModuleExport) this.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);
                    if (kind === "ES") this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
                    kind = "CommonJS";
                    hasModuleExport = true;
                }
            });
            node36.kind = kind || "CommonJS";
            return this.finishNode(node36, "DeclareModule");
        }
        flowParseDeclareExportDeclaration(node37, insideModule1) {
            this.expect(76);
            if (this.eat(59)) {
                if (this.match(62) || this.match(74)) node37.declaration = this.flowParseDeclare(this.startNode());
                else {
                    node37.declaration = this.flowParseType();
                    this.semicolon();
                }
                node37.default = true;
                return this.finishNode(node37, "DeclareExportDeclaration");
            } else {
                if (this.match(69) || this.isLet() || (this.isContextual(120) || this.isContextual(119)) && !insideModule1) {
                    const label = this.state.value;
                    const suggestion = exportSuggestions[label];
                    throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);
                }
                if (this.match(68) || this.match(62) || this.match(74) || this.isContextual(121)) {
                    node37.declaration = this.flowParseDeclare(this.startNode());
                    node37.default = false;
                    return this.finishNode(node37, "DeclareExportDeclaration");
                } else if (this.match(49) || this.match(5) || this.isContextual(119) || this.isContextual(120) || this.isContextual(121)) {
                    node37 = this.parseExport(node37);
                    if (node37.type === "ExportNamedDeclaration") {
                        node37.type = "ExportDeclaration";
                        node37.default = false;
                        delete node37.exportKind;
                    }
                    node37.type = "Declare" + node37.type;
                    return node37;
                }
            }
            throw this.unexpected();
        }
        flowParseDeclareModuleExports(node38) {
            this.next();
            this.expectContextual(102);
            node38.typeAnnotation = this.flowParseTypeAnnotation();
            this.semicolon();
            return this.finishNode(node38, "DeclareModuleExports");
        }
        flowParseDeclareTypeAlias(node39) {
            this.next();
            this.flowParseTypeAlias(node39);
            node39.type = "DeclareTypeAlias";
            return node39;
        }
        flowParseDeclareOpaqueType(node40) {
            this.next();
            this.flowParseOpaqueType(node40, true);
            node40.type = "DeclareOpaqueType";
            return node40;
        }
        flowParseDeclareInterface(node41) {
            this.next();
            this.flowParseInterfaceish(node41);
            return this.finishNode(node41, "DeclareInterface");
        }
        flowParseInterfaceish(node42, isClass = false) {
            node42.id = this.flowParseRestrictedIdentifier(!isClass, true);
            this.scope.declareName(node42.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node42.id.start);
            if (this.match(43)) node42.typeParameters = this.flowParseTypeParameterDeclaration();
            else node42.typeParameters = null;
            node42.extends = [];
            node42.implements = [];
            node42.mixins = [];
            if (this.eat(75)) do node42.extends.push(this.flowParseInterfaceExtends());
            while (!isClass && this.eat(12))
            if (this.isContextual(108)) {
                this.next();
                do node42.mixins.push(this.flowParseInterfaceExtends());
                while (this.eat(12))
            }
            if (this.isContextual(104)) {
                this.next();
                do node42.implements.push(this.flowParseInterfaceExtends());
                while (this.eat(12))
            }
            node42.body = this.flowParseObjectType({
                allowStatic: isClass,
                allowExact: false,
                allowSpread: false,
                allowProto: isClass,
                allowInexact: false
            });
        }
        flowParseInterfaceExtends() {
            const node = this.startNode();
            node.id = this.flowParseQualifiedTypeIdentifier();
            if (this.match(43)) node.typeParameters = this.flowParseTypeParameterInstantiation();
            else node.typeParameters = null;
            return this.finishNode(node, "InterfaceExtends");
        }
        flowParseInterface(node43) {
            this.flowParseInterfaceish(node43);
            return this.finishNode(node43, "InterfaceDeclaration");
        }
        checkNotUnderscore(word) {
            if (word === "_") this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);
        }
        checkReservedType(word1, startLoc, declaration) {
            if (!reservedTypes.has(word1)) return;
            this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word1);
        }
        flowParseRestrictedIdentifier(liberal, declaration1) {
            this.checkReservedType(this.state.value, this.state.start, declaration1);
            return this.parseIdentifier(liberal);
        }
        flowParseTypeAlias(node44) {
            node44.id = this.flowParseRestrictedIdentifier(false, true);
            this.scope.declareName(node44.id.name, BIND_LEXICAL, node44.id.start);
            if (this.match(43)) node44.typeParameters = this.flowParseTypeParameterDeclaration();
            else node44.typeParameters = null;
            node44.right = this.flowParseTypeInitialiser(27);
            this.semicolon();
            return this.finishNode(node44, "TypeAlias");
        }
        flowParseOpaqueType(node45, declare) {
            this.expectContextual(120);
            node45.id = this.flowParseRestrictedIdentifier(true, true);
            this.scope.declareName(node45.id.name, BIND_LEXICAL, node45.id.start);
            if (this.match(43)) node45.typeParameters = this.flowParseTypeParameterDeclaration();
            else node45.typeParameters = null;
            node45.supertype = null;
            if (this.match(14)) node45.supertype = this.flowParseTypeInitialiser(14);
            node45.impltype = null;
            if (!declare) node45.impltype = this.flowParseTypeInitialiser(27);
            this.semicolon();
            return this.finishNode(node45, "OpaqueType");
        }
        flowParseTypeParameter(requireDefault = false) {
            const nodeStart = this.state.start;
            const node = this.startNode();
            const variance = this.flowParseVariance();
            const ident = this.flowParseTypeAnnotatableIdentifier();
            node.name = ident.name;
            node.variance = variance;
            node.bound = ident.typeAnnotation;
            if (this.match(27)) {
                this.eat(27);
                node.default = this.flowParseType();
            } else if (requireDefault) this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);
            return this.finishNode(node, "TypeParameter");
        }
        flowParseTypeParameterDeclaration() {
            const oldInType = this.state.inType;
            const node = this.startNode();
            node.params = [];
            this.state.inType = true;
            if (this.match(43) || this.match(132)) this.next();
            else this.unexpected();
            let defaultRequired = false;
            do {
                const typeParameter = this.flowParseTypeParameter(defaultRequired);
                node.params.push(typeParameter);
                if (typeParameter.default) defaultRequired = true;
                if (!this.match(44)) this.expect(12);
            }while (!this.match(44))
            this.expect(44);
            this.state.inType = oldInType;
            return this.finishNode(node, "TypeParameterDeclaration");
        }
        flowParseTypeParameterInstantiation() {
            const node = this.startNode();
            const oldInType = this.state.inType;
            node.params = [];
            this.state.inType = true;
            this.expect(43);
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = false;
            while(!this.match(44)){
                node.params.push(this.flowParseType());
                if (!this.match(44)) this.expect(12);
            }
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            this.expect(44);
            this.state.inType = oldInType;
            return this.finishNode(node, "TypeParameterInstantiation");
        }
        flowParseTypeParameterInstantiationCallOrNew() {
            const node = this.startNode();
            const oldInType = this.state.inType;
            node.params = [];
            this.state.inType = true;
            this.expect(43);
            while(!this.match(44)){
                node.params.push(this.flowParseTypeOrImplicitInstantiation());
                if (!this.match(44)) this.expect(12);
            }
            this.expect(44);
            this.state.inType = oldInType;
            return this.finishNode(node, "TypeParameterInstantiation");
        }
        flowParseInterfaceType() {
            const node = this.startNode();
            this.expectContextual(119);
            node.extends = [];
            if (this.eat(75)) do node.extends.push(this.flowParseInterfaceExtends());
            while (this.eat(12))
            node.body = this.flowParseObjectType({
                allowStatic: false,
                allowExact: false,
                allowSpread: false,
                allowProto: false,
                allowInexact: false
            });
            return this.finishNode(node, "InterfaceTypeAnnotation");
        }
        flowParseObjectPropertyKey() {
            return this.match(124) || this.match(123) ? this.parseExprAtom() : this.parseIdentifier(true);
        }
        flowParseObjectTypeIndexer(node46, isStatic, variance) {
            node46.static = isStatic;
            if (this.lookahead().type === 14) {
                node46.id = this.flowParseObjectPropertyKey();
                node46.key = this.flowParseTypeInitialiser();
            } else {
                node46.id = null;
                node46.key = this.flowParseType();
            }
            this.expect(3);
            node46.value = this.flowParseTypeInitialiser();
            node46.variance = variance;
            return this.finishNode(node46, "ObjectTypeIndexer");
        }
        flowParseObjectTypeInternalSlot(node47, isStatic1) {
            node47.static = isStatic1;
            node47.id = this.flowParseObjectPropertyKey();
            this.expect(3);
            this.expect(3);
            if (this.match(43) || this.match(10)) {
                node47.method = true;
                node47.optional = false;
                node47.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node47.start, node47.loc.start));
            } else {
                node47.method = false;
                if (this.eat(17)) node47.optional = true;
                node47.value = this.flowParseTypeInitialiser();
            }
            return this.finishNode(node47, "ObjectTypeInternalSlot");
        }
        flowParseObjectTypeMethodish(node48) {
            node48.params = [];
            node48.rest = null;
            node48.typeParameters = null;
            node48.this = null;
            if (this.match(43)) node48.typeParameters = this.flowParseTypeParameterDeclaration();
            this.expect(10);
            if (this.match(72)) {
                node48.this = this.flowParseFunctionTypeParam(true);
                node48.this.name = null;
                if (!this.match(11)) this.expect(12);
            }
            while(!this.match(11) && !this.match(21)){
                node48.params.push(this.flowParseFunctionTypeParam(false));
                if (!this.match(11)) this.expect(12);
            }
            if (this.eat(21)) node48.rest = this.flowParseFunctionTypeParam(false);
            this.expect(11);
            node48.returnType = this.flowParseTypeInitialiser();
            return this.finishNode(node48, "FunctionTypeAnnotation");
        }
        flowParseObjectTypeCallProperty(node49, isStatic2) {
            const valueNode = this.startNode();
            node49.static = isStatic2;
            node49.value = this.flowParseObjectTypeMethodish(valueNode);
            return this.finishNode(node49, "ObjectTypeCallProperty");
        }
        flowParseObjectType({ allowStatic , allowExact , allowSpread , allowProto , allowInexact  }) {
            const oldInType = this.state.inType;
            this.state.inType = true;
            const nodeStart = this.startNode();
            nodeStart.callProperties = [];
            nodeStart.properties = [];
            nodeStart.indexers = [];
            nodeStart.internalSlots = [];
            let endDelim;
            let exact;
            let inexact = false;
            if (allowExact && this.match(6)) {
                this.expect(6);
                endDelim = 9;
                exact = true;
            } else {
                this.expect(5);
                endDelim = 8;
                exact = false;
            }
            nodeStart.exact = exact;
            while(!this.match(endDelim)){
                let isStatic = false;
                let protoStart = null;
                let inexactStart = null;
                const node = this.startNode();
                if (allowProto && this.isContextual(109)) {
                    const lookahead = this.lookahead();
                    if (lookahead.type !== 14 && lookahead.type !== 17) {
                        this.next();
                        protoStart = this.state.start;
                        allowStatic = false;
                    }
                }
                if (allowStatic && this.isContextual(98)) {
                    const lookahead = this.lookahead();
                    if (lookahead.type !== 14 && lookahead.type !== 17) {
                        this.next();
                        isStatic = true;
                    }
                }
                const variance = this.flowParseVariance();
                if (this.eat(0)) {
                    if (protoStart != null) this.unexpected(protoStart);
                    if (this.eat(0)) {
                        if (variance) this.unexpected(variance.start);
                        nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
                    } else nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
                } else if (this.match(10) || this.match(43)) {
                    if (protoStart != null) this.unexpected(protoStart);
                    if (variance) this.unexpected(variance.start);
                    nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
                } else {
                    let kind = "init";
                    if (this.isContextual(92) || this.isContextual(97)) {
                        const lookahead = this.lookahead();
                        if (tokenIsLiteralPropertyName(lookahead.type)) {
                            kind = this.state.value;
                            this.next();
                        }
                    }
                    const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
                    if (propOrInexact === null) {
                        inexact = true;
                        inexactStart = this.state.lastTokStart;
                    } else nodeStart.properties.push(propOrInexact);
                }
                this.flowObjectTypeSemicolon();
                if (inexactStart && !this.match(8) && !this.match(9)) this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);
            }
            this.expect(endDelim);
            if (allowSpread) nodeStart.inexact = inexact;
            const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
            this.state.inType = oldInType;
            return out;
        }
        flowParseObjectTypeProperty(node50, isStatic3, protoStart, variance1, kind, allowSpread1, allowInexact1) {
            if (this.eat(21)) {
                const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
                if (isInexactToken) {
                    if (!allowSpread1) this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);
                    else if (!allowInexact1) this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);
                    if (variance1) this.raise(variance1.start, FlowErrors.InexactVariance);
                    return null;
                }
                if (!allowSpread1) this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);
                if (protoStart != null) this.unexpected(protoStart);
                if (variance1) this.raise(variance1.start, FlowErrors.SpreadVariance);
                node50.argument = this.flowParseType();
                return this.finishNode(node50, "ObjectTypeSpreadProperty");
            } else {
                node50.key = this.flowParseObjectPropertyKey();
                node50.static = isStatic3;
                node50.proto = protoStart != null;
                node50.kind = kind;
                let optional = false;
                if (this.match(43) || this.match(10)) {
                    node50.method = true;
                    if (protoStart != null) this.unexpected(protoStart);
                    if (variance1) this.unexpected(variance1.start);
                    node50.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node50.start, node50.loc.start));
                    if (kind === "get" || kind === "set") this.flowCheckGetterSetterParams(node50);
                    if (!allowSpread1 && node50.key.name === "constructor" && node50.value.this) this.raise(node50.value.this.start, FlowErrors.ThisParamBannedInConstructor);
                } else {
                    if (kind !== "init") this.unexpected();
                    node50.method = false;
                    if (this.eat(17)) optional = true;
                    node50.value = this.flowParseTypeInitialiser();
                    node50.variance = variance1;
                }
                node50.optional = optional;
                return this.finishNode(node50, "ObjectTypeProperty");
            }
        }
        flowCheckGetterSetterParams(property) {
            const paramCount = property.kind === "get" ? 0 : 1;
            const start = property.start;
            const length = property.value.params.length + (property.value.rest ? 1 : 0);
            if (property.value.this) this.raise(property.value.this.start, property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam);
            if (length !== paramCount) {
                if (property.kind === "get") this.raise(start, ErrorMessages.BadGetterArity);
                else this.raise(start, ErrorMessages.BadSetterArity);
            }
            if (property.kind === "set" && property.value.rest) this.raise(start, ErrorMessages.BadSetterRestParameter);
        }
        flowObjectTypeSemicolon() {
            if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) this.unexpected();
        }
        flowParseQualifiedTypeIdentifier(startPos, startLoc3, id) {
            startPos = startPos || this.state.start;
            startLoc3 = startLoc3 || this.state.startLoc;
            let node = id || this.flowParseRestrictedIdentifier(true);
            while(this.eat(16)){
                const node2 = this.startNodeAt(startPos, startLoc3);
                node2.qualification = node;
                node2.id = this.flowParseRestrictedIdentifier(true);
                node = this.finishNode(node2, "QualifiedTypeIdentifier");
            }
            return node;
        }
        flowParseGenericType(startPos2, startLoc4, id3) {
            const node = this.startNodeAt(startPos2, startLoc4);
            node.typeParameters = null;
            node.id = this.flowParseQualifiedTypeIdentifier(startPos2, startLoc4, id3);
            if (this.match(43)) node.typeParameters = this.flowParseTypeParameterInstantiation();
            return this.finishNode(node, "GenericTypeAnnotation");
        }
        flowParseTypeofType() {
            const node = this.startNode();
            this.expect(81);
            node.argument = this.flowParsePrimaryType();
            return this.finishNode(node, "TypeofTypeAnnotation");
        }
        flowParseTupleType() {
            const node = this.startNode();
            node.types = [];
            this.expect(0);
            while(this.state.pos < this.length && !this.match(3)){
                node.types.push(this.flowParseType());
                if (this.match(3)) break;
                this.expect(12);
            }
            this.expect(3);
            return this.finishNode(node, "TupleTypeAnnotation");
        }
        flowParseFunctionTypeParam(first) {
            let name = null;
            let optional = false;
            let typeAnnotation = null;
            const node = this.startNode();
            const lh = this.lookahead();
            const isThis = this.state.type === 72;
            if (lh.type === 14 || lh.type === 17) {
                if (isThis && !first) this.raise(node.start, FlowErrors.ThisParamMustBeFirst);
                name = this.parseIdentifier(isThis);
                if (this.eat(17)) {
                    optional = true;
                    if (isThis) this.raise(node.start, FlowErrors.ThisParamMayNotBeOptional);
                }
                typeAnnotation = this.flowParseTypeInitialiser();
            } else typeAnnotation = this.flowParseType();
            node.name = name;
            node.optional = optional;
            node.typeAnnotation = typeAnnotation;
            return this.finishNode(node, "FunctionTypeParam");
        }
        reinterpretTypeAsFunctionTypeParam(type13) {
            const node = this.startNodeAt(type13.start, type13.loc.start);
            node.name = null;
            node.optional = false;
            node.typeAnnotation = type13;
            return this.finishNode(node, "FunctionTypeParam");
        }
        flowParseFunctionTypeParams(params = []) {
            let rest = null;
            let _this = null;
            if (this.match(72)) {
                _this = this.flowParseFunctionTypeParam(true);
                _this.name = null;
                if (!this.match(11)) this.expect(12);
            }
            while(!this.match(11) && !this.match(21)){
                params.push(this.flowParseFunctionTypeParam(false));
                if (!this.match(11)) this.expect(12);
            }
            if (this.eat(21)) rest = this.flowParseFunctionTypeParam(false);
            return {
                params,
                rest,
                _this
            };
        }
        flowIdentToTypeAnnotation(startPos3, startLoc5, node51, id4) {
            switch(id4.name){
                case "any":
                    return this.finishNode(node51, "AnyTypeAnnotation");
                case "bool":
                case "boolean":
                    return this.finishNode(node51, "BooleanTypeAnnotation");
                case "mixed":
                    return this.finishNode(node51, "MixedTypeAnnotation");
                case "empty":
                    return this.finishNode(node51, "EmptyTypeAnnotation");
                case "number":
                    return this.finishNode(node51, "NumberTypeAnnotation");
                case "string":
                    return this.finishNode(node51, "StringTypeAnnotation");
                case "symbol":
                    return this.finishNode(node51, "SymbolTypeAnnotation");
                default:
                    this.checkNotUnderscore(id4.name);
                    return this.flowParseGenericType(startPos3, startLoc5, id4);
            }
        }
        flowParsePrimaryType() {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            const node = this.startNode();
            let tmp;
            let type;
            let isGroupedType = false;
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            switch(this.state.type){
                case 5:
                    return this.flowParseObjectType({
                        allowStatic: false,
                        allowExact: false,
                        allowSpread: true,
                        allowProto: false,
                        allowInexact: true
                    });
                case 6:
                    return this.flowParseObjectType({
                        allowStatic: false,
                        allowExact: true,
                        allowSpread: true,
                        allowProto: false,
                        allowInexact: false
                    });
                case 0:
                    this.state.noAnonFunctionType = false;
                    type = this.flowParseTupleType();
                    this.state.noAnonFunctionType = oldNoAnonFunctionType;
                    return type;
                case 43:
                    node.typeParameters = this.flowParseTypeParameterDeclaration();
                    this.expect(10);
                    tmp = this.flowParseFunctionTypeParams();
                    node.params = tmp.params;
                    node.rest = tmp.rest;
                    node.this = tmp._this;
                    this.expect(11);
                    this.expect(19);
                    node.returnType = this.flowParseType();
                    return this.finishNode(node, "FunctionTypeAnnotation");
                case 10:
                    this.next();
                    if (!this.match(11) && !this.match(21)) {
                        if (tokenIsIdentifier(this.state.type) || this.match(72)) {
                            const token = this.lookahead().type;
                            isGroupedType = token !== 17 && token !== 14;
                        } else isGroupedType = true;
                    }
                    if (isGroupedType) {
                        this.state.noAnonFunctionType = false;
                        type = this.flowParseType();
                        this.state.noAnonFunctionType = oldNoAnonFunctionType;
                        if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                            this.expect(11);
                            return type;
                        } else this.eat(12);
                    }
                    if (type) tmp = this.flowParseFunctionTypeParams([
                        this.reinterpretTypeAsFunctionTypeParam(type)
                    ]);
                    else tmp = this.flowParseFunctionTypeParams();
                    node.params = tmp.params;
                    node.rest = tmp.rest;
                    node.this = tmp._this;
                    this.expect(11);
                    this.expect(19);
                    node.returnType = this.flowParseType();
                    node.typeParameters = null;
                    return this.finishNode(node, "FunctionTypeAnnotation");
                case 123:
                    return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                case 79:
                case 80:
                    node.value = this.match(79);
                    this.next();
                    return this.finishNode(node, "BooleanLiteralTypeAnnotation");
                case 47:
                    if (this.state.value === "-") {
                        this.next();
                        if (this.match(124)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
                        if (this.match(125)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
                        throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);
                    }
                    throw this.unexpected();
                case 124:
                    return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                case 125:
                    return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                case 82:
                    this.next();
                    return this.finishNode(node, "VoidTypeAnnotation");
                case 78:
                    this.next();
                    return this.finishNode(node, "NullLiteralTypeAnnotation");
                case 72:
                    this.next();
                    return this.finishNode(node, "ThisTypeAnnotation");
                case 49:
                    this.next();
                    return this.finishNode(node, "ExistsTypeAnnotation");
                case 81:
                    return this.flowParseTypeofType();
                default:
                    if (tokenIsKeyword(this.state.type)) {
                        const label = tokenLabelName(this.state.type);
                        this.next();
                        return super.createIdentifier(node, label);
                    } else if (tokenIsIdentifier(this.state.type)) {
                        if (this.isContextual(119)) return this.flowParseInterfaceType();
                        return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());
                    }
            }
            throw this.unexpected();
        }
        flowParsePostfixType() {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            let type = this.flowParsePrimaryType();
            let seenOptionalIndexedAccess = false;
            while((this.match(0) || this.match(18)) && !this.canInsertSemicolon()){
                const node = this.startNodeAt(startPos, startLoc);
                const optional = this.eat(18);
                seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
                this.expect(0);
                if (!optional && this.match(3)) {
                    node.elementType = type;
                    this.next();
                    type = this.finishNode(node, "ArrayTypeAnnotation");
                } else {
                    node.objectType = type;
                    node.indexType = this.flowParseType();
                    this.expect(3);
                    if (seenOptionalIndexedAccess) {
                        node.optional = optional;
                        type = this.finishNode(node, "OptionalIndexedAccessType");
                    } else type = this.finishNode(node, "IndexedAccessType");
                }
            }
            return type;
        }
        flowParsePrefixType() {
            const node = this.startNode();
            if (this.eat(17)) {
                node.typeAnnotation = this.flowParsePrefixType();
                return this.finishNode(node, "NullableTypeAnnotation");
            } else return this.flowParsePostfixType();
        }
        flowParseAnonFunctionWithoutParens() {
            const param = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
                const node = this.startNodeAt(param.start, param.loc.start);
                node.params = [
                    this.reinterpretTypeAsFunctionTypeParam(param)
                ];
                node.rest = null;
                node.this = null;
                node.returnType = this.flowParseType();
                node.typeParameters = null;
                return this.finishNode(node, "FunctionTypeAnnotation");
            }
            return param;
        }
        flowParseIntersectionType() {
            const node = this.startNode();
            this.eat(41);
            const type = this.flowParseAnonFunctionWithoutParens();
            node.types = [
                type
            ];
            while(this.eat(41))node.types.push(this.flowParseAnonFunctionWithoutParens());
            return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
        }
        flowParseUnionType() {
            const node = this.startNode();
            this.eat(39);
            const type = this.flowParseIntersectionType();
            node.types = [
                type
            ];
            while(this.eat(39))node.types.push(this.flowParseIntersectionType());
            return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
        }
        flowParseType() {
            const oldInType = this.state.inType;
            this.state.inType = true;
            const type = this.flowParseUnionType();
            this.state.inType = oldInType;
            return type;
        }
        flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === 122 && this.state.value === "_") {
                const startPos = this.state.start;
                const startLoc = this.state.startLoc;
                const node = this.parseIdentifier();
                return this.flowParseGenericType(startPos, startLoc, node);
            } else return this.flowParseType();
        }
        flowParseTypeAnnotation() {
            const node = this.startNode();
            node.typeAnnotation = this.flowParseTypeInitialiser();
            return this.finishNode(node, "TypeAnnotation");
        }
        flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
            const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            if (this.match(14)) {
                ident.typeAnnotation = this.flowParseTypeAnnotation();
                this.resetEndLocation(ident);
            }
            return ident;
        }
        typeCastToParameter(node52) {
            node52.expression.typeAnnotation = node52.typeAnnotation;
            this.resetEndLocation(node52.expression, node52.typeAnnotation.end, node52.typeAnnotation.loc.end);
            return node52.expression;
        }
        flowParseVariance() {
            let variance = null;
            if (this.match(47)) {
                variance = this.startNode();
                if (this.state.value === "+") variance.kind = "plus";
                else variance.kind = "minus";
                this.next();
                this.finishNode(variance, "Variance");
            }
            return variance;
        }
        parseFunctionBody(node53, allowExpressionBody, isMethod = false) {
            if (allowExpressionBody) return this.forwardNoArrowParamsConversionAt(node53, ()=>super.parseFunctionBody(node53, true, isMethod)
            );
            return super.parseFunctionBody(node53, false, isMethod);
        }
        parseFunctionBodyAndFinish(node54, type14, isMethod1 = false) {
            if (this.match(14)) {
                const typeNode = this.startNode();
                [typeNode.typeAnnotation, node54.predicate] = this.flowParseTypeAndPredicateInitialiser();
                node54.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
            }
            super.parseFunctionBodyAndFinish(node54, type14, isMethod1);
        }
        parseStatement(context, topLevel) {
            if (this.state.strict && this.isContextual(119)) {
                const lookahead = this.lookahead();
                if (tokenIsKeywordOrIdentifier(lookahead.type)) {
                    const node = this.startNode();
                    this.next();
                    return this.flowParseInterface(node);
                }
            } else if (this.shouldParseEnums() && this.isContextual(116)) {
                const node = this.startNode();
                this.next();
                return this.flowParseEnumDeclaration(node);
            }
            const stmt = super.parseStatement(context, topLevel);
            if (this.flowPragma === undefined && !this.isValidDirective(stmt)) this.flowPragma = null;
            return stmt;
        }
        parseExpressionStatement(node55, expr3) {
            if (expr3.type === "Identifier") {
                if (expr3.name === "declare") {
                    if (this.match(74) || tokenIsIdentifier(this.state.type) || this.match(62) || this.match(68) || this.match(76)) return this.flowParseDeclare(node55);
                } else if (tokenIsIdentifier(this.state.type)) {
                    if (expr3.name === "interface") return this.flowParseInterface(node55);
                    else if (expr3.name === "type") return this.flowParseTypeAlias(node55);
                    else if (expr3.name === "opaque") return this.flowParseOpaqueType(node55, false);
                }
            }
            return super.parseExpressionStatement(node55, expr3);
        }
        shouldParseExportDeclaration() {
            const { type  } = this.state;
            if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 116) return !this.state.containsEsc;
            return super.shouldParseExportDeclaration();
        }
        isExportDefaultSpecifier() {
            const { type  } = this.state;
            if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 116) return this.state.containsEsc;
            return super.isExportDefaultSpecifier();
        }
        parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(116)) {
                const node = this.startNode();
                this.next();
                return this.flowParseEnumDeclaration(node);
            }
            return super.parseExportDefaultExpression();
        }
        parseConditional(expr1, startPos4, startLoc6, refExpressionErrors) {
            if (!this.match(17)) return expr1;
            if (this.state.maybeInArrowParameters) {
                const nextCh = this.lookaheadCharCode();
                if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
                    this.setOptionalParametersError(refExpressionErrors);
                    return expr1;
                }
            }
            this.expect(17);
            const state = this.state.clone();
            const originalNoArrowAt = this.state.noArrowAt;
            const node = this.startNodeAt(startPos4, startLoc6);
            let { consequent , failed  } = this.tryParseConditionalConsequent();
            let [valid, invalid] = this.getArrowLikeExpressions(consequent);
            if (failed || invalid.length > 0) {
                const noArrowAt = [
                    ...originalNoArrowAt
                ];
                if (invalid.length > 0) {
                    this.state = state;
                    this.state.noArrowAt = noArrowAt;
                    for(let i = 0; i < invalid.length; i++)noArrowAt.push(invalid[i].start);
                    ({ consequent , failed  } = this.tryParseConditionalConsequent());
                    [valid, invalid] = this.getArrowLikeExpressions(consequent);
                }
                if (failed && valid.length > 1) this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);
                if (failed && valid.length === 1) {
                    this.state = state;
                    noArrowAt.push(valid[0].start);
                    this.state.noArrowAt = noArrowAt;
                    ({ consequent , failed  } = this.tryParseConditionalConsequent());
                }
            }
            this.getArrowLikeExpressions(consequent, true);
            this.state.noArrowAt = originalNoArrowAt;
            this.expect(14);
            node.test = expr1;
            node.consequent = consequent;
            node.alternate = this.forwardNoArrowParamsConversionAt(node, ()=>this.parseMaybeAssign(undefined, undefined)
            );
            return this.finishNode(node, "ConditionalExpression");
        }
        tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            const consequent = this.parseMaybeAssignAllowIn();
            const failed = !this.match(14);
            this.state.noArrowParamsConversionAt.pop();
            return {
                consequent,
                failed
            };
        }
        getArrowLikeExpressions(node56, disallowInvalid) {
            const stack = [
                node56
            ];
            const arrows = [];
            while(stack.length !== 0){
                const node = stack.pop();
                if (node.type === "ArrowFunctionExpression") {
                    if (node.typeParameters || !node.returnType) this.finishArrowValidation(node);
                    else arrows.push(node);
                    stack.push(node.body);
                } else if (node.type === "ConditionalExpression") {
                    stack.push(node.consequent);
                    stack.push(node.alternate);
                }
            }
            if (disallowInvalid) {
                arrows.forEach((node)=>this.finishArrowValidation(node)
                );
                return [
                    arrows,
                    []
                ];
            }
            return partition(arrows, (node)=>node.params.every((param)=>this.isAssignable(param, true)
                )
            );
        }
        finishArrowValidation(node) {
            var _node$extra;
            this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma, false);
            this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
            super.checkParams(node, false, true);
            this.scope.exit();
        }
        forwardNoArrowParamsConversionAt(node58, parse) {
            let result;
            if (this.state.noArrowParamsConversionAt.indexOf(node58.start) !== -1) {
                this.state.noArrowParamsConversionAt.push(this.state.start);
                result = parse();
                this.state.noArrowParamsConversionAt.pop();
            } else result = parse();
            return result;
        }
        parseParenItem(node59, startPos5, startLoc7) {
            node59 = super.parseParenItem(node59, startPos5, startLoc7);
            if (this.eat(17)) {
                node59.optional = true;
                this.resetEndLocation(node59);
            }
            if (this.match(14)) {
                const typeCastNode = this.startNodeAt(startPos5, startLoc7);
                typeCastNode.expression = node59;
                typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
                return this.finishNode(typeCastNode, "TypeCastExpression");
            }
            return node59;
        }
        assertModuleNodeAllowed(node60) {
            if (node60.type === "ImportDeclaration" && (node60.importKind === "type" || node60.importKind === "typeof") || node60.type === "ExportNamedDeclaration" && node60.exportKind === "type" || node60.type === "ExportAllDeclaration" && node60.exportKind === "type") return;
            super.assertModuleNodeAllowed(node60);
        }
        parseExport(node61) {
            const decl = super.parseExport(node61);
            if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") decl.exportKind = decl.exportKind || "value";
            return decl;
        }
        parseExportDeclaration(node62) {
            if (this.isContextual(120)) {
                node62.exportKind = "type";
                const declarationNode = this.startNode();
                this.next();
                if (this.match(5)) {
                    node62.specifiers = this.parseExportSpecifiers(true);
                    this.parseExportFrom(node62);
                    return null;
                } else return this.flowParseTypeAlias(declarationNode);
            } else if (this.isContextual(121)) {
                node62.exportKind = "type";
                const declarationNode = this.startNode();
                this.next();
                return this.flowParseOpaqueType(declarationNode, false);
            } else if (this.isContextual(119)) {
                node62.exportKind = "type";
                const declarationNode = this.startNode();
                this.next();
                return this.flowParseInterface(declarationNode);
            } else if (this.shouldParseEnums() && this.isContextual(116)) {
                node62.exportKind = "value";
                const declarationNode = this.startNode();
                this.next();
                return this.flowParseEnumDeclaration(declarationNode);
            } else return super.parseExportDeclaration(node62);
        }
        eatExportStar(node63) {
            if (super.eatExportStar(...arguments)) return true;
            if (this.isContextual(120) && this.lookahead().type === 49) {
                node63.exportKind = "type";
                this.next();
                this.next();
                return true;
            }
            return false;
        }
        maybeParseExportNamespaceSpecifier(node64) {
            const pos = this.state.start;
            const hasNamespace = super.maybeParseExportNamespaceSpecifier(node64);
            if (hasNamespace && node64.exportKind === "type") this.unexpected(pos);
            return hasNamespace;
        }
        parseClassId(node65, isStatement, optionalId) {
            super.parseClassId(node65, isStatement, optionalId);
            if (this.match(43)) node65.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        parseClassMember(classBody, member, state) {
            const pos = this.state.start;
            if (this.isContextual(115)) {
                if (this.parseClassMemberFromModifier(classBody, member)) return;
                member.declare = true;
            }
            super.parseClassMember(classBody, member, state);
            if (member.declare) {
                if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") this.raise(pos, FlowErrors.DeclareClassElement);
                else if (member.value) this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);
            }
        }
        isIterator(word2) {
            return word2 === "iterator" || word2 === "asyncIterator";
        }
        readIterator() {
            const word = super.readWord1();
            const fullWord = "@@" + word;
            if (!this.isIterator(word) || !this.state.inType) this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, fullWord);
            this.finishToken(122, fullWord);
        }
        getTokenFromCode(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (code === 123 && next === 124) return this.finishOp(6, 2);
            else if (this.state.inType && (code === 62 || code === 60)) return this.finishOp(code === 62 ? 44 : 43, 1);
            else if (this.state.inType && code === 63) {
                if (next === 46) return this.finishOp(18, 2);
                return this.finishOp(17, 1);
            } else if (isIteratorStart(code, next)) {
                this.state.pos += 2;
                return this.readIterator();
            } else return super.getTokenFromCode(code);
        }
        isAssignable(node66, isBinding) {
            if (node66.type === "TypeCastExpression") return this.isAssignable(node66.expression, isBinding);
            else return super.isAssignable(node66, isBinding);
        }
        toAssignable(node67, isLHS = false) {
            if (node67.type === "TypeCastExpression") return super.toAssignable(this.typeCastToParameter(node67), isLHS);
            else return super.toAssignable(node67, isLHS);
        }
        toAssignableList(exprList, trailingCommaPos, isLHS1) {
            for(let i = 0; i < exprList.length; i++){
                const expr = exprList[i];
                if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") exprList[i] = this.typeCastToParameter(expr);
            }
            return super.toAssignableList(exprList, trailingCommaPos, isLHS1);
        }
        toReferencedList(exprList1, isParenthesizedExpr) {
            for(let i = 0; i < exprList1.length; i++){
                var _expr$extra;
                const expr = exprList1[i];
                if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList1.length > 1 || !isParenthesizedExpr)) this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);
            }
            return exprList1;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors2) {
            const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors2);
            if (canBePattern && !this.state.maybeInArrowParameters) this.toReferencedList(node.elements);
            return node;
        }
        checkLVal(expr2, ...args5) {
            if (expr2.type !== "TypeCastExpression") return super.checkLVal(expr2, ...args5);
        }
        parseClassProperty(node68) {
            if (this.match(14)) node68.typeAnnotation = this.flowParseTypeAnnotation();
            return super.parseClassProperty(node68);
        }
        parseClassPrivateProperty(node69) {
            if (this.match(14)) node69.typeAnnotation = this.flowParseTypeAnnotation();
            return super.parseClassPrivateProperty(node69);
        }
        isClassMethod() {
            return this.match(43) || super.isClassMethod();
        }
        isClassProperty() {
            return this.match(14) || super.isClassProperty();
        }
        isNonstaticConstructor(method) {
            return !this.match(14) && super.isNonstaticConstructor(method);
        }
        pushClassMethod(classBody1, method2, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            if (method2.variance) this.unexpected(method2.variance.start);
            delete method2.variance;
            if (this.match(43)) method2.typeParameters = this.flowParseTypeParameterDeclaration();
            super.pushClassMethod(classBody1, method2, isGenerator, isAsync, isConstructor, allowsDirectSuper);
            if (method2.params && isConstructor) {
                const params = method2.params;
                if (params.length > 0 && this.isThisParam(params[0])) this.raise(method2.start, FlowErrors.ThisParamBannedInConstructor);
            } else if (method2.type === "MethodDefinition" && isConstructor && method2.value.params) {
                const params = method2.value.params;
                if (params.length > 0 && this.isThisParam(params[0])) this.raise(method2.start, FlowErrors.ThisParamBannedInConstructor);
            }
        }
        pushClassPrivateMethod(classBody2, method3, isGenerator3, isAsync4) {
            if (method3.variance) this.unexpected(method3.variance.start);
            delete method3.variance;
            if (this.match(43)) method3.typeParameters = this.flowParseTypeParameterDeclaration();
            super.pushClassPrivateMethod(classBody2, method3, isGenerator3, isAsync4);
        }
        parseClassSuper(node70) {
            super.parseClassSuper(node70);
            if (node70.superClass && this.match(43)) node70.superTypeParameters = this.flowParseTypeParameterInstantiation();
            if (this.isContextual(104)) {
                this.next();
                const implemented = node70.implements = [];
                do {
                    const node = this.startNode();
                    node.id = this.flowParseRestrictedIdentifier(true);
                    if (this.match(43)) node.typeParameters = this.flowParseTypeParameterInstantiation();
                    else node.typeParameters = null;
                    implemented.push(this.finishNode(node, "ClassImplements"));
                }while (this.eat(12))
            }
        }
        checkGetterSetterParams(method4) {
            super.checkGetterSetterParams(method4);
            const params = this.getObjectOrClassMethodParams(method4);
            if (params.length > 0) {
                const param = params[0];
                if (this.isThisParam(param) && method4.kind === "get") this.raise(param.start, FlowErrors.GetterMayNotHaveThisParam);
                else if (this.isThisParam(param)) this.raise(param.start, FlowErrors.SetterMayNotHaveThisParam);
            }
        }
        parsePropertyName(node71, isPrivateNameAllowed) {
            const variance = this.flowParseVariance();
            const key = super.parsePropertyName(node71, isPrivateNameAllowed);
            node71.variance = variance;
            return key;
        }
        parseObjPropValue(prop, startPos6, startLoc8, isGenerator4, isAsync5, isPattern, isAccessor, refExpressionErrors3) {
            if (prop.variance) this.unexpected(prop.variance.start);
            delete prop.variance;
            let typeParameters;
            if (this.match(43) && !isAccessor) {
                typeParameters = this.flowParseTypeParameterDeclaration();
                if (!this.match(10)) this.unexpected();
            }
            super.parseObjPropValue(prop, startPos6, startLoc8, isGenerator4, isAsync5, isPattern, isAccessor, refExpressionErrors3);
            if (typeParameters) (prop.value || prop).typeParameters = typeParameters;
        }
        parseAssignableListItemTypes(param) {
            if (this.eat(17)) {
                if (param.type !== "Identifier") this.raise(param.start, FlowErrors.PatternIsOptional);
                if (this.isThisParam(param)) this.raise(param.start, FlowErrors.ThisParamMayNotBeOptional);
                param.optional = true;
            }
            if (this.match(14)) param.typeAnnotation = this.flowParseTypeAnnotation();
            else if (this.isThisParam(param)) this.raise(param.start, FlowErrors.ThisParamAnnotationRequired);
            if (this.match(27) && this.isThisParam(param)) this.raise(param.start, FlowErrors.ThisParamNoDefault);
            this.resetEndLocation(param);
            return param;
        }
        parseMaybeDefault(startPos7, startLoc9, left) {
            const node = super.parseMaybeDefault(startPos7, startLoc9, left);
            if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);
            return node;
        }
        shouldParseDefaultImport(node72) {
            if (!hasTypeImportKind(node72)) return super.shouldParseDefaultImport(node72);
            return isMaybeDefaultImport(this.state.type);
        }
        parseImportSpecifierLocal(node73, specifier, type15, contextDescription) {
            specifier.local = hasTypeImportKind(node73) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
            this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
            node73.specifiers.push(this.finishNode(specifier, type15));
        }
        maybeParseDefaultImportSpecifier(node74) {
            node74.importKind = "value";
            let kind = null;
            if (this.match(81)) kind = "typeof";
            else if (this.isContextual(120)) kind = "type";
            if (kind) {
                const lh = this.lookahead();
                const { type  } = lh;
                if (kind === "type" && type === 49) this.unexpected(lh.start);
                if (isMaybeDefaultImport(type) || type === 5 || type === 49) {
                    this.next();
                    node74.importKind = kind;
                }
            }
            return super.maybeParseDefaultImportSpecifier(node74);
        }
        parseImportSpecifier(specifier1, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
            const firstIdent = specifier1.imported;
            let specifierTypeKind = null;
            if (firstIdent.type === "Identifier") {
                if (firstIdent.name === "type") specifierTypeKind = "type";
                else if (firstIdent.name === "typeof") specifierTypeKind = "typeof";
            }
            let isBinding = false;
            if (this.isContextual(87) && !this.isLookaheadContextual("as")) {
                const as_ident = this.parseIdentifier(true);
                if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
                    specifier1.imported = as_ident;
                    specifier1.importKind = specifierTypeKind;
                    specifier1.local = cloneIdentifier(as_ident);
                } else {
                    specifier1.imported = firstIdent;
                    specifier1.importKind = null;
                    specifier1.local = this.parseIdentifier();
                }
            } else {
                if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
                    specifier1.imported = this.parseIdentifier(true);
                    specifier1.importKind = specifierTypeKind;
                } else {
                    if (importedIsString) throw this.raise(specifier1.start, ErrorMessages.ImportBindingIsString, firstIdent.value);
                    specifier1.imported = firstIdent;
                    specifier1.importKind = null;
                }
                if (this.eatContextual(87)) specifier1.local = this.parseIdentifier();
                else {
                    isBinding = true;
                    specifier1.local = cloneIdentifier(specifier1.imported);
                }
            }
            const specifierIsTypeImport = hasTypeImportKind(specifier1);
            if (isInTypeOnlyImport && specifierIsTypeImport) this.raise(specifier1.start, FlowErrors.ImportTypeShorthandOnlyInPureImport);
            if (isInTypeOnlyImport || specifierIsTypeImport) this.checkReservedType(specifier1.local.name, specifier1.local.start, true);
            if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) this.checkReservedWord(specifier1.local.name, specifier1.start, true, true);
            this.checkLVal(specifier1.local, "import specifier", BIND_LEXICAL);
            return this.finishNode(specifier1, "ImportSpecifier");
        }
        parseBindingAtom() {
            switch(this.state.type){
                case 72:
                    return this.parseIdentifier(true);
                default:
                    return super.parseBindingAtom();
            }
        }
        parseFunctionParams(node75, allowModifiers) {
            const kind = node75.kind;
            if (kind !== "get" && kind !== "set" && this.match(43)) node75.typeParameters = this.flowParseTypeParameterDeclaration();
            super.parseFunctionParams(node75, allowModifiers);
        }
        parseVarId(decl, kind1) {
            super.parseVarId(decl, kind1);
            if (this.match(14)) {
                decl.id.typeAnnotation = this.flowParseTypeAnnotation();
                this.resetEndLocation(decl.id);
            }
        }
        parseAsyncArrowFromCallExpression(node76, call) {
            if (this.match(14)) {
                const oldNoAnonFunctionType = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                node76.returnType = this.flowParseTypeAnnotation();
                this.state.noAnonFunctionType = oldNoAnonFunctionType;
            }
            return super.parseAsyncArrowFromCallExpression(node76, call);
        }
        shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
        }
        parseMaybeAssign(refExpressionErrors4, afterLeftParse) {
            var _jsx;
            let state = null;
            let jsx;
            if (this.hasPlugin("jsx") && (this.match(132) || this.match(43))) {
                state = this.state.clone();
                jsx = this.tryParse(()=>super.parseMaybeAssign(refExpressionErrors4, afterLeftParse)
                , state);
                if (!jsx.error) return jsx.node;
                const { context  } = this.state;
                const curContext = context[context.length - 1];
                if (curContext === types1.j_oTag) context.length -= 2;
                else if (curContext === types1.j_expr) context.length -= 1;
            }
            if ((_jsx = jsx) != null && _jsx.error || this.match(43)) {
                var _jsx2, _jsx3;
                state = state || this.state.clone();
                let typeParameters;
                const arrow = this.tryParse((abort)=>{
                    var _arrowExpression$extr;
                    typeParameters = this.flowParseTypeParameterDeclaration();
                    const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, ()=>{
                        const result = super.parseMaybeAssign(refExpressionErrors4, afterLeftParse);
                        this.resetStartLocationFromNode(result, typeParameters);
                        return result;
                    });
                    if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();
                    const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);
                    if (expr.type !== "ArrowFunctionExpression") abort();
                    expr.typeParameters = typeParameters;
                    this.resetStartLocationFromNode(expr, typeParameters);
                    return arrowExpression;
                }, state);
                let arrowExpression1 = null;
                if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
                    if (!arrow.error && !arrow.aborted) {
                        if (arrow.node.async) this.raise(typeParameters.start, FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction);
                        return arrow.node;
                    }
                    arrowExpression1 = arrow.node;
                }
                if ((_jsx2 = jsx) != null && _jsx2.node) {
                    this.state = jsx.failState;
                    return jsx.node;
                }
                if (arrowExpression1) {
                    this.state = arrow.failState;
                    return arrowExpression1;
                }
                if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
                if (arrow.thrown) throw arrow.error;
                throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);
            }
            return super.parseMaybeAssign(refExpressionErrors4, afterLeftParse);
        }
        parseArrow(node77) {
            if (this.match(14)) {
                const result = this.tryParse(()=>{
                    const oldNoAnonFunctionType = this.state.noAnonFunctionType;
                    this.state.noAnonFunctionType = true;
                    const typeNode = this.startNode();
                    [typeNode.typeAnnotation, node77.predicate] = this.flowParseTypeAndPredicateInitialiser();
                    this.state.noAnonFunctionType = oldNoAnonFunctionType;
                    if (this.canInsertSemicolon()) this.unexpected();
                    if (!this.match(19)) this.unexpected();
                    return typeNode;
                });
                if (result.thrown) return null;
                if (result.error) this.state = result.failState;
                node77.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(node77);
        }
        shouldParseArrow(params4) {
            return this.match(14) || super.shouldParseArrow(params4);
        }
        setArrowFunctionParameters(node78, params5) {
            if (this.state.noArrowParamsConversionAt.indexOf(node78.start) !== -1) node78.params = params5;
            else super.setArrowFunctionParameters(node78, params5);
        }
        checkParams(node79, allowDuplicates, isArrowFunction) {
            if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node79.start) !== -1) return;
            for(let i = 0; i < node79.params.length; i++)if (this.isThisParam(node79.params[i]) && i > 0) this.raise(node79.params[i].start, FlowErrors.ThisParamMustBeFirst);
            return super.checkParams(...arguments);
        }
        parseParenAndDistinguishExpression(canBeArrow) {
            return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
        }
        parseSubscripts(base, startPos8, startLoc10, noCalls) {
            if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos8) !== -1) {
                this.next();
                const node = this.startNodeAt(startPos8, startLoc10);
                node.callee = base;
                node.arguments = this.parseCallExpressionArguments(11, false);
                base = this.finishNode(node, "CallExpression");
            } else if (base.type === "Identifier" && base.name === "async" && this.match(43)) {
                const state = this.state.clone();
                const arrow = this.tryParse((abort)=>this.parseAsyncArrowWithTypeParameters(startPos8, startLoc10) || abort()
                , state);
                if (!arrow.error && !arrow.aborted) return arrow.node;
                const result = this.tryParse(()=>super.parseSubscripts(base, startPos8, startLoc10, noCalls)
                , state);
                if (result.node && !result.error) return result.node;
                if (arrow.node) {
                    this.state = arrow.failState;
                    return arrow.node;
                }
                if (result.node) {
                    this.state = result.failState;
                    return result.node;
                }
                throw arrow.error || result.error;
            }
            return super.parseSubscripts(base, startPos8, startLoc10, noCalls);
        }
        parseSubscript(base1, startPos9, startLoc11, noCalls1, subscriptState) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
                subscriptState.optionalChainMember = true;
                if (noCalls1) {
                    subscriptState.stop = true;
                    return base1;
                }
                this.next();
                const node = this.startNodeAt(startPos9, startLoc11);
                node.callee = base1;
                node.typeArguments = this.flowParseTypeParameterInstantiation();
                this.expect(10);
                node.arguments = this.parseCallExpressionArguments(11, false);
                node.optional = true;
                return this.finishCallExpression(node, true);
            } else if (!noCalls1 && this.shouldParseTypes() && this.match(43)) {
                const node = this.startNodeAt(startPos9, startLoc11);
                node.callee = base1;
                const result = this.tryParse(()=>{
                    node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
                    this.expect(10);
                    node.arguments = this.parseCallExpressionArguments(11, false);
                    if (subscriptState.optionalChainMember) node.optional = false;
                    return this.finishCallExpression(node, subscriptState.optionalChainMember);
                });
                if (result.node) {
                    if (result.error) this.state = result.failState;
                    return result.node;
                }
            }
            return super.parseSubscript(base1, startPos9, startLoc11, noCalls1, subscriptState);
        }
        parseNewArguments(node80) {
            let targs = null;
            if (this.shouldParseTypes() && this.match(43)) targs = this.tryParse(()=>this.flowParseTypeParameterInstantiationCallOrNew()
            ).node;
            node80.typeArguments = targs;
            super.parseNewArguments(node80);
        }
        parseAsyncArrowWithTypeParameters(startPos10, startLoc12) {
            const node = this.startNodeAt(startPos10, startLoc12);
            this.parseFunctionParams(node);
            if (!this.parseArrow(node)) return;
            return this.parseArrowExpression(node, undefined, true);
        }
        readToken_mult_modulo(code8) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (code8 === 42 && next === 47 && this.state.hasFlowComment) {
                this.state.hasFlowComment = false;
                this.state.pos += 2;
                this.nextToken();
                return;
            }
            super.readToken_mult_modulo(code8);
        }
        readToken_pipe_amp(code9) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (code9 === 124 && next === 125) {
                this.finishOp(9, 2);
                return;
            }
            super.readToken_pipe_amp(code9);
        }
        parseTopLevel(file, program) {
            const fileNode = super.parseTopLevel(file, program);
            if (this.state.hasFlowComment) this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);
            return fileNode;
        }
        skipBlockComment() {
            if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
                if (this.state.hasFlowComment) this.unexpected(null, FlowErrors.NestedFlowComment);
                this.hasFlowCommentCompletion();
                this.state.pos += this.skipFlowComment();
                this.state.hasFlowComment = true;
                return;
            }
            if (this.state.hasFlowComment) {
                const end = this.input.indexOf("*-/", this.state.pos += 2);
                if (end === -1) throw this.raise(this.state.pos - 2, ErrorMessages.UnterminatedComment);
                this.state.pos = end + 3;
                return;
            }
            return super.skipBlockComment();
        }
        skipFlowComment() {
            const { pos  } = this.state;
            let shiftToFirstNonWhiteSpace = 2;
            while([
                32,
                9
            ].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace)))shiftToFirstNonWhiteSpace++;
            const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
            const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
            if (ch2 === 58 && ch3 === 58) return shiftToFirstNonWhiteSpace + 2;
            if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") return shiftToFirstNonWhiteSpace + 12;
            if (ch2 === 58 && ch3 !== 58) return shiftToFirstNonWhiteSpace;
            return false;
        }
        hasFlowCommentCompletion() {
            const end = this.input.indexOf("*/", this.state.pos);
            if (end === -1) throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);
        }
        flowEnumErrorBooleanMemberNotInitialized(pos, { enumName , memberName  }) {
            this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);
        }
        flowEnumErrorInvalidMemberName(pos25, { enumName: enumName1 , memberName: memberName1  }) {
            const suggestion = memberName1[0].toUpperCase() + memberName1.slice(1);
            this.raise(pos25, FlowErrors.EnumInvalidMemberName, memberName1, suggestion, enumName1);
        }
        flowEnumErrorDuplicateMemberName(pos26, { enumName: enumName2 , memberName: memberName2  }) {
            this.raise(pos26, FlowErrors.EnumDuplicateMemberName, memberName2, enumName2);
        }
        flowEnumErrorInconsistentMemberValues(pos27, { enumName: enumName3  }) {
            this.raise(pos27, FlowErrors.EnumInconsistentMemberValues, enumName3);
        }
        flowEnumErrorInvalidExplicitType(pos28, { enumName: enumName4 , suppliedType  }) {
            return this.raise(pos28, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName4, suppliedType);
        }
        flowEnumErrorInvalidMemberInitializer(pos29, { enumName: enumName5 , explicitType , memberName: memberName3  }) {
            let message = null;
            switch(explicitType){
                case "boolean":
                case "number":
                case "string":
                    message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;
                    break;
                case "symbol":
                    message = FlowErrors.EnumInvalidMemberInitializerSymbolType;
                    break;
                default:
                    message = FlowErrors.EnumInvalidMemberInitializerUnknownType;
            }
            return this.raise(pos29, message, enumName5, memberName3, explicitType);
        }
        flowEnumErrorNumberMemberNotInitialized(pos30, { enumName: enumName6 , memberName: memberName4  }) {
            this.raise(pos30, FlowErrors.EnumNumberMemberNotInitialized, enumName6, memberName4);
        }
        flowEnumErrorStringMemberInconsistentlyInitailized(pos31, { enumName: enumName7  }) {
            this.raise(pos31, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName7);
        }
        flowEnumMemberInit() {
            const startPos = this.state.start;
            const endOfInit = ()=>this.match(12) || this.match(8)
            ;
            switch(this.state.type){
                case 124:
                    {
                        const literal = this.parseNumericLiteral(this.state.value);
                        if (endOfInit()) return {
                            type: "number",
                            pos: literal.start,
                            value: literal
                        };
                        return {
                            type: "invalid",
                            pos: startPos
                        };
                    }
                case 123:
                    {
                        const literal = this.parseStringLiteral(this.state.value);
                        if (endOfInit()) return {
                            type: "string",
                            pos: literal.start,
                            value: literal
                        };
                        return {
                            type: "invalid",
                            pos: startPos
                        };
                    }
                case 79:
                case 80:
                    {
                        const literal = this.parseBooleanLiteral(this.match(79));
                        if (endOfInit()) return {
                            type: "boolean",
                            pos: literal.start,
                            value: literal
                        };
                        return {
                            type: "invalid",
                            pos: startPos
                        };
                    }
                default:
                    return {
                        type: "invalid",
                        pos: startPos
                    };
            }
        }
        flowEnumMemberRaw() {
            const pos = this.state.start;
            const id = this.parseIdentifier(true);
            const init = this.eat(27) ? this.flowEnumMemberInit() : {
                type: "none",
                pos
            };
            return {
                id,
                init
            };
        }
        flowEnumCheckExplicitTypeMismatch(pos32, context1, expectedType) {
            const { explicitType  } = context1;
            if (explicitType === null) return;
            if (explicitType !== expectedType) this.flowEnumErrorInvalidMemberInitializer(pos32, context1);
        }
        flowEnumMembers({ enumName: enumName8 , explicitType: explicitType1  }) {
            const seenNames = new Set();
            const members = {
                booleanMembers: [],
                numberMembers: [],
                stringMembers: [],
                defaultedMembers: []
            };
            let hasUnknownMembers = false;
            while(!this.match(8)){
                if (this.eat(21)) {
                    hasUnknownMembers = true;
                    break;
                }
                const memberNode = this.startNode();
                const { id , init  } = this.flowEnumMemberRaw();
                const memberName = id.name;
                if (memberName === "") continue;
                if (/^[a-z]/.test(memberName)) this.flowEnumErrorInvalidMemberName(id.start, {
                    enumName: enumName8,
                    memberName
                });
                if (seenNames.has(memberName)) this.flowEnumErrorDuplicateMemberName(id.start, {
                    enumName: enumName8,
                    memberName
                });
                seenNames.add(memberName);
                const context = {
                    enumName: enumName8,
                    explicitType: explicitType1,
                    memberName
                };
                memberNode.id = id;
                switch(init.type){
                    case "boolean":
                        this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "boolean");
                        memberNode.init = init.value;
                        members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                        break;
                    case "number":
                        this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "number");
                        memberNode.init = init.value;
                        members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                        break;
                    case "string":
                        this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "string");
                        memberNode.init = init.value;
                        members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                        break;
                    case "invalid":
                        throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);
                    case "none":
                        switch(explicitType1){
                            case "boolean":
                                this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);
                                break;
                            case "number":
                                this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);
                                break;
                            default:
                                members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                        }
                }
                if (!this.match(8)) this.expect(12);
            }
            return {
                members,
                hasUnknownMembers
            };
        }
        flowEnumStringMembers(initializedMembers, defaultedMembers, { enumName: enumName9  }) {
            if (initializedMembers.length === 0) return defaultedMembers;
            else if (defaultedMembers.length === 0) return initializedMembers;
            else if (defaultedMembers.length > initializedMembers.length) {
                for (const member of initializedMembers)this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
                    enumName: enumName9
                });
                return defaultedMembers;
            } else {
                for (const member of defaultedMembers)this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
                    enumName: enumName9
                });
                return initializedMembers;
            }
        }
        flowEnumParseExplicitType({ enumName: enumName10  }) {
            if (this.eatContextual(95)) {
                if (!tokenIsIdentifier(this.state.type)) throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
                    enumName: enumName10,
                    suppliedType: null
                });
                const { value  } = this.state;
                this.next();
                if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") this.flowEnumErrorInvalidExplicitType(this.state.start, {
                    enumName: enumName10,
                    suppliedType: value
                });
                return value;
            }
            return null;
        }
        flowEnumBody(node81, { enumName: enumName11 , nameLoc  }) {
            const explicitType = this.flowEnumParseExplicitType({
                enumName: enumName11
            });
            this.expect(5);
            const { members , hasUnknownMembers  } = this.flowEnumMembers({
                enumName: enumName11,
                explicitType
            });
            node81.hasUnknownMembers = hasUnknownMembers;
            switch(explicitType){
                case "boolean":
                    node81.explicitType = true;
                    node81.members = members.booleanMembers;
                    this.expect(8);
                    return this.finishNode(node81, "EnumBooleanBody");
                case "number":
                    node81.explicitType = true;
                    node81.members = members.numberMembers;
                    this.expect(8);
                    return this.finishNode(node81, "EnumNumberBody");
                case "string":
                    node81.explicitType = true;
                    node81.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                        enumName: enumName11
                    });
                    this.expect(8);
                    return this.finishNode(node81, "EnumStringBody");
                case "symbol":
                    node81.members = members.defaultedMembers;
                    this.expect(8);
                    return this.finishNode(node81, "EnumSymbolBody");
                default:
                    {
                        const empty = ()=>{
                            node81.members = [];
                            this.expect(8);
                            return this.finishNode(node81, "EnumStringBody");
                        };
                        node81.explicitType = false;
                        const boolsLen = members.booleanMembers.length;
                        const numsLen = members.numberMembers.length;
                        const strsLen = members.stringMembers.length;
                        const defaultedLen = members.defaultedMembers.length;
                        if (!boolsLen && !numsLen && !strsLen && !defaultedLen) return empty();
                        else if (!boolsLen && !numsLen) {
                            node81.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                                enumName: enumName11
                            });
                            this.expect(8);
                            return this.finishNode(node81, "EnumStringBody");
                        } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                            for (const member of members.defaultedMembers)this.flowEnumErrorBooleanMemberNotInitialized(member.start, {
                                enumName: enumName11,
                                memberName: member.id.name
                            });
                            node81.members = members.booleanMembers;
                            this.expect(8);
                            return this.finishNode(node81, "EnumBooleanBody");
                        } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                            for (const member of members.defaultedMembers)this.flowEnumErrorNumberMemberNotInitialized(member.start, {
                                enumName: enumName11,
                                memberName: member.id.name
                            });
                            node81.members = members.numberMembers;
                            this.expect(8);
                            return this.finishNode(node81, "EnumNumberBody");
                        } else {
                            this.flowEnumErrorInconsistentMemberValues(nameLoc, {
                                enumName: enumName11
                            });
                            return empty();
                        }
                    }
            }
        }
        flowParseEnumDeclaration(node82) {
            const id = this.parseIdentifier();
            node82.id = id;
            node82.body = this.flowEnumBody(this.startNode(), {
                enumName: id.name,
                nameLoc: id.start
            });
            return this.finishNode(node82, "EnumDeclaration");
        }
        isLookaheadToken_lt() {
            const next = this.nextTokenStart();
            if (this.input.charCodeAt(next) === 60) {
                const afterNext = this.input.charCodeAt(next + 1);
                return afterNext !== 60 && afterNext !== 61;
            }
            return false;
        }
        maybeUnwrapTypeCastExpression(node83) {
            return node83.type === "TypeCastExpression" ? node83.expression : node83;
        }
    }
;
const entities = {
    quot: "\u0022",
    amp: "&",
    apos: "\u0027",
    lt: "<",
    gt: ">",
    nbsp: "\u00A0",
    iexcl: "\u00A1",
    cent: "\u00A2",
    pound: "\u00A3",
    curren: "\u00A4",
    yen: "\u00A5",
    brvbar: "\u00A6",
    sect: "\u00A7",
    uml: "\u00A8",
    copy: "\u00A9",
    ordf: "\u00AA",
    laquo: "\u00AB",
    not: "\u00AC",
    shy: "\u00AD",
    reg: "\u00AE",
    macr: "\u00AF",
    deg: "\u00B0",
    plusmn: "\u00B1",
    sup2: "\u00B2",
    sup3: "\u00B3",
    acute: "\u00B4",
    micro: "\u00B5",
    para: "\u00B6",
    middot: "\u00B7",
    cedil: "\u00B8",
    sup1: "\u00B9",
    ordm: "\u00BA",
    raquo: "\u00BB",
    frac14: "\u00BC",
    frac12: "\u00BD",
    frac34: "\u00BE",
    iquest: "\u00BF",
    Agrave: "\u00C0",
    Aacute: "\u00C1",
    Acirc: "\u00C2",
    Atilde: "\u00C3",
    Auml: "\u00C4",
    Aring: "\u00C5",
    AElig: "\u00C6",
    Ccedil: "\u00C7",
    Egrave: "\u00C8",
    Eacute: "\u00C9",
    Ecirc: "\u00CA",
    Euml: "\u00CB",
    Igrave: "\u00CC",
    Iacute: "\u00CD",
    Icirc: "\u00CE",
    Iuml: "\u00CF",
    ETH: "\u00D0",
    Ntilde: "\u00D1",
    Ograve: "\u00D2",
    Oacute: "\u00D3",
    Ocirc: "\u00D4",
    Otilde: "\u00D5",
    Ouml: "\u00D6",
    times: "\u00D7",
    Oslash: "\u00D8",
    Ugrave: "\u00D9",
    Uacute: "\u00DA",
    Ucirc: "\u00DB",
    Uuml: "\u00DC",
    Yacute: "\u00DD",
    THORN: "\u00DE",
    szlig: "\u00DF",
    agrave: "\u00E0",
    aacute: "\u00E1",
    acirc: "\u00E2",
    atilde: "\u00E3",
    auml: "\u00E4",
    aring: "\u00E5",
    aelig: "\u00E6",
    ccedil: "\u00E7",
    egrave: "\u00E8",
    eacute: "\u00E9",
    ecirc: "\u00EA",
    euml: "\u00EB",
    igrave: "\u00EC",
    iacute: "\u00ED",
    icirc: "\u00EE",
    iuml: "\u00EF",
    eth: "\u00F0",
    ntilde: "\u00F1",
    ograve: "\u00F2",
    oacute: "\u00F3",
    ocirc: "\u00F4",
    otilde: "\u00F5",
    ouml: "\u00F6",
    divide: "\u00F7",
    oslash: "\u00F8",
    ugrave: "\u00F9",
    uacute: "\u00FA",
    ucirc: "\u00FB",
    uuml: "\u00FC",
    yacute: "\u00FD",
    thorn: "\u00FE",
    yuml: "\u00FF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
};
const HEX_NUMBER = /^[\da-fA-F]+$/;
const DECIMAL_NUMBER = /^\d+$/;
const JsxErrors = makeErrorTemplates({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.",
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
}, ErrorCodes.SyntaxError, "jsx");
types1.j_oTag = new TokContext("<tag");
types1.j_cTag = new TokContext("</tag");
types1.j_expr = new TokContext("<tag>...</tag>", true);
function isFragment(object) {
    return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
}
function getQualifiedJSXName(object) {
    if (object.type === "JSXIdentifier") return object.name;
    if (object.type === "JSXNamespacedName") return object.namespace.name + ":" + object.name.name;
    if (object.type === "JSXMemberExpression") return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    throw new Error("Node had unexpected type: " + object.type);
}
var jsx1 = (superClass)=>class extends superClass {
        jsxReadToken() {
            let out = "";
            let chunkStart = this.state.pos;
            for(;;){
                if (this.state.pos >= this.length) throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);
                const ch = this.input.charCodeAt(this.state.pos);
                switch(ch){
                    case 60:
                    case 123:
                        if (this.state.pos === this.state.start) {
                            if (ch === 60 && this.state.canStartJSXElement) {
                                ++this.state.pos;
                                return this.finishToken(132);
                            }
                            return super.getTokenFromCode(ch);
                        }
                        out += this.input.slice(chunkStart, this.state.pos);
                        return this.finishToken(131, out);
                    case 38:
                        out += this.input.slice(chunkStart, this.state.pos);
                        out += this.jsxReadEntity();
                        chunkStart = this.state.pos;
                        break;
                    case 62:
                    case 125:
                    default:
                        if (isNewLine(ch)) {
                            out += this.input.slice(chunkStart, this.state.pos);
                            out += this.jsxReadNewLine(true);
                            chunkStart = this.state.pos;
                        } else ++this.state.pos;
                }
            }
        }
        jsxReadNewLine(normalizeCRLF) {
            const ch = this.input.charCodeAt(this.state.pos);
            let out;
            ++this.state.pos;
            if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
                ++this.state.pos;
                out = normalizeCRLF ? "\n" : "\r\n";
            } else out = String.fromCharCode(ch);
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            return out;
        }
        jsxReadString(quote) {
            let out = "";
            let chunkStart = ++this.state.pos;
            for(;;){
                if (this.state.pos >= this.length) throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
                const ch = this.input.charCodeAt(this.state.pos);
                if (ch === quote) break;
                if (ch === 38) {
                    out += this.input.slice(chunkStart, this.state.pos);
                    out += this.jsxReadEntity();
                    chunkStart = this.state.pos;
                } else if (isNewLine(ch)) {
                    out += this.input.slice(chunkStart, this.state.pos);
                    out += this.jsxReadNewLine(false);
                    chunkStart = this.state.pos;
                } else ++this.state.pos;
            }
            out += this.input.slice(chunkStart, this.state.pos++);
            return this.finishToken(123, out);
        }
        jsxReadEntity() {
            let str = "";
            let count = 0;
            let entity;
            let ch = this.input[this.state.pos];
            const startPos = ++this.state.pos;
            while(this.state.pos < this.length && count++ < 10){
                ch = this.input[this.state.pos++];
                if (ch === ";") {
                    if (str[0] === "#") {
                        if (str[1] === "x") {
                            str = str.substr(2);
                            if (HEX_NUMBER.test(str)) entity = String.fromCodePoint(parseInt(str, 16));
                        } else {
                            str = str.substr(1);
                            if (DECIMAL_NUMBER.test(str)) entity = String.fromCodePoint(parseInt(str, 10));
                        }
                    } else entity = entities[str];
                    break;
                }
                str += ch;
            }
            if (!entity) {
                this.state.pos = startPos;
                return "&";
            }
            return entity;
        }
        jsxReadWord() {
            let ch;
            const start = this.state.pos;
            do ch = this.input.charCodeAt(++this.state.pos);
            while (isIdentifierChar(ch) || ch === 45)
            return this.finishToken(130, this.input.slice(start, this.state.pos));
        }
        jsxParseIdentifier() {
            const node = this.startNode();
            if (this.match(130)) node.name = this.state.value;
            else if (tokenIsKeyword(this.state.type)) node.name = tokenLabelName(this.state.type);
            else this.unexpected();
            this.next();
            return this.finishNode(node, "JSXIdentifier");
        }
        jsxParseNamespacedName() {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            const name = this.jsxParseIdentifier();
            if (!this.eat(14)) return name;
            const node = this.startNodeAt(startPos, startLoc);
            node.namespace = name;
            node.name = this.jsxParseIdentifier();
            return this.finishNode(node, "JSXNamespacedName");
        }
        jsxParseElementName() {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            let node = this.jsxParseNamespacedName();
            if (node.type === "JSXNamespacedName") return node;
            while(this.eat(16)){
                const newNode = this.startNodeAt(startPos, startLoc);
                newNode.object = node;
                newNode.property = this.jsxParseIdentifier();
                node = this.finishNode(newNode, "JSXMemberExpression");
            }
            return node;
        }
        jsxParseAttributeValue() {
            let node;
            switch(this.state.type){
                case 5:
                    node = this.startNode();
                    this.next();
                    node = this.jsxParseExpressionContainer(node);
                    if (node.expression.type === "JSXEmptyExpression") this.raise(node.start, JsxErrors.AttributeIsEmpty);
                    return node;
                case 132:
                case 123:
                    return this.parseExprAtom();
                default:
                    throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);
            }
        }
        jsxParseEmptyExpression() {
            const node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
            return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
        }
        jsxParseSpreadChild(node) {
            this.next();
            node.expression = this.parseExpression();
            this.expect(8);
            return this.finishNode(node, "JSXSpreadChild");
        }
        jsxParseExpressionContainer(node84) {
            if (this.match(8)) node84.expression = this.jsxParseEmptyExpression();
            else {
                const expression = this.parseExpression();
                node84.expression = expression;
            }
            this.expect(8);
            return this.finishNode(node84, "JSXExpressionContainer");
        }
        jsxParseAttribute() {
            const node = this.startNode();
            if (this.eat(5)) {
                this.expect(21);
                node.argument = this.parseMaybeAssignAllowIn();
                this.expect(8);
                return this.finishNode(node, "JSXSpreadAttribute");
            }
            node.name = this.jsxParseNamespacedName();
            node.value = this.eat(27) ? this.jsxParseAttributeValue() : null;
            return this.finishNode(node, "JSXAttribute");
        }
        jsxParseOpeningElementAt(startPos, startLoc) {
            const node = this.startNodeAt(startPos, startLoc);
            if (this.match(133)) {
                this.expect(133);
                return this.finishNode(node, "JSXOpeningFragment");
            }
            node.name = this.jsxParseElementName();
            return this.jsxParseOpeningElementAfterName(node);
        }
        jsxParseOpeningElementAfterName(node85) {
            const attributes = [];
            while(!this.match(50) && !this.match(133))attributes.push(this.jsxParseAttribute());
            node85.attributes = attributes;
            node85.selfClosing = this.eat(50);
            this.expect(133);
            return this.finishNode(node85, "JSXOpeningElement");
        }
        jsxParseClosingElementAt(startPos11, startLoc13) {
            const node = this.startNodeAt(startPos11, startLoc13);
            if (this.match(133)) {
                this.expect(133);
                return this.finishNode(node, "JSXClosingFragment");
            }
            node.name = this.jsxParseElementName();
            this.expect(133);
            return this.finishNode(node, "JSXClosingElement");
        }
        jsxParseElementAt(startPos12, startLoc14) {
            const node = this.startNodeAt(startPos12, startLoc14);
            const children = [];
            const openingElement = this.jsxParseOpeningElementAt(startPos12, startLoc14);
            let closingElement = null;
            if (!openingElement.selfClosing) {
                contents: for(;;)switch(this.state.type){
                    case 132:
                        startPos12 = this.state.start;
                        startLoc14 = this.state.startLoc;
                        this.next();
                        if (this.eat(50)) {
                            closingElement = this.jsxParseClosingElementAt(startPos12, startLoc14);
                            break contents;
                        }
                        children.push(this.jsxParseElementAt(startPos12, startLoc14));
                        break;
                    case 131:
                        children.push(this.parseExprAtom());
                        break;
                    case 5:
                        {
                            const node = this.startNode();
                            this.next();
                            if (this.match(21)) children.push(this.jsxParseSpreadChild(node));
                            else children.push(this.jsxParseExpressionContainer(node));
                            break;
                        }
                    default:
                        throw this.unexpected();
                }
                if (isFragment(openingElement) && !isFragment(closingElement)) this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);
                else if (!isFragment(openingElement) && isFragment(closingElement)) this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
                else if (!isFragment(openingElement) && !isFragment(closingElement)) {
                    if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
                }
            }
            if (isFragment(openingElement)) {
                node.openingFragment = openingElement;
                node.closingFragment = closingElement;
            } else {
                node.openingElement = openingElement;
                node.closingElement = closingElement;
            }
            node.children = children;
            if (this.match(43)) throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);
            return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
        }
        jsxParseElement() {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            this.next();
            return this.jsxParseElementAt(startPos, startLoc);
        }
        parseExprAtom(refExpressionErrors) {
            if (this.match(131)) return this.parseLiteral(this.state.value, "JSXText");
            else if (this.match(132)) return this.jsxParseElement();
            else if (this.match(43) && this.input.charCodeAt(this.state.pos) !== 33) {
                this.replaceToken(132);
                return this.jsxParseElement();
            } else return super.parseExprAtom(refExpressionErrors);
        }
        getTokenFromCode(code) {
            const context = this.curContext();
            if (context === types1.j_expr) return this.jsxReadToken();
            if (context === types1.j_oTag || context === types1.j_cTag) {
                if (isIdentifierStart(code)) return this.jsxReadWord();
                if (code === 62) {
                    ++this.state.pos;
                    return this.finishToken(133);
                }
                if ((code === 34 || code === 39) && context === types1.j_oTag) return this.jsxReadString(code);
            }
            if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
                ++this.state.pos;
                return this.finishToken(132);
            }
            return super.getTokenFromCode(code);
        }
        updateContext(prevType) {
            super.updateContext(prevType);
            const { context , type  } = this.state;
            if (type === 50 && prevType === 132) {
                context.splice(-2, 2, types1.j_cTag);
                this.state.canStartJSXElement = false;
            } else if (type === 132) context.push(types1.j_expr, types1.j_oTag);
            else if (type === 133) {
                const out = context.pop();
                if (out === types1.j_oTag && prevType === 50 || out === types1.j_cTag) {
                    context.pop();
                    this.state.canStartJSXElement = context[context.length - 1] === types1.j_expr;
                } else this.state.canStartJSXElement = true;
            } else this.state.canStartJSXElement = tokenComesBeforeExpression(type);
        }
    }
;
class TypeScriptScope extends Scope {
    constructor(...args6){
        super(...args6);
        this.types = new Set();
        this.enums = new Set();
        this.constEnums = new Set();
        this.classes = new Set();
        this.exportOnlyBindings = new Set();
    }
}
class TypeScriptScopeHandler extends ScopeHandler {
    createScope(flags5) {
        return new TypeScriptScope(flags5);
    }
    declareName(name15, bindingType5, pos33) {
        const scope = this.currentScope();
        if (bindingType5 & BIND_FLAGS_TS_EXPORT_ONLY) {
            this.maybeExportDefined(scope, name15);
            scope.exportOnlyBindings.add(name15);
            return;
        }
        super.declareName(...arguments);
        if (bindingType5 & BIND_KIND_TYPE) {
            if (!(bindingType5 & BIND_KIND_VALUE)) {
                this.checkRedeclarationInScope(scope, name15, bindingType5, pos33);
                this.maybeExportDefined(scope, name15);
            }
            scope.types.add(name15);
        }
        if (bindingType5 & BIND_FLAGS_TS_ENUM) scope.enums.add(name15);
        if (bindingType5 & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.add(name15);
        if (bindingType5 & BIND_FLAGS_CLASS) scope.classes.add(name15);
    }
    isRedeclaredInScope(scope, name14, bindingType6) {
        if (scope.enums.has(name14)) {
            if (bindingType6 & BIND_FLAGS_TS_ENUM) {
                const isConst = !!(bindingType6 & BIND_FLAGS_TS_CONST_ENUM);
                const wasConst = scope.constEnums.has(name14);
                return isConst !== wasConst;
            }
            return true;
        }
        if (bindingType6 & BIND_FLAGS_CLASS && scope.classes.has(name14)) {
            if (scope.lexical.has(name14)) return !!(bindingType6 & BIND_KIND_VALUE);
            else return false;
        }
        if (bindingType6 & BIND_KIND_TYPE && scope.types.has(name14)) return true;
        return super.isRedeclaredInScope(...arguments);
    }
    checkLocalExport(id5) {
        const topLevelScope = this.scopeStack[0];
        const { name  } = id5;
        if (!topLevelScope.types.has(name) && !topLevelScope.exportOnlyBindings.has(name)) super.checkLocalExport(id5);
    }
}
function nonNull(x) {
    if (x == null) throw new Error(`Unexpected ${x} value.`);
    return x;
}
function assert(x) {
    if (!x) throw new Error("Assert fail");
}
const TSErrors = makeErrorTemplates({
    AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.",
    AbstractPropertyHasInitializer: "Property '%0' cannot have an initializer because it is marked abstract.",
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: "'declare' is not allowed in %0ters.",
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: "Accessibility modifier already seen.",
    DuplicateModifier: "Duplicate modifier: '%0'.",
    EmptyHeritageClauseType: "'%0' list cannot be empty.",
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.",
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').",
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.",
    InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').",
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."
}, ErrorCodes.SyntaxError, "typescript");
function keywordTypeFromName(value) {
    switch(value){
        case "any":
            return "TSAnyKeyword";
        case "boolean":
            return "TSBooleanKeyword";
        case "bigint":
            return "TSBigIntKeyword";
        case "never":
            return "TSNeverKeyword";
        case "number":
            return "TSNumberKeyword";
        case "object":
            return "TSObjectKeyword";
        case "string":
            return "TSStringKeyword";
        case "symbol":
            return "TSSymbolKeyword";
        case "undefined":
            return "TSUndefinedKeyword";
        case "unknown":
            return "TSUnknownKeyword";
        default:
            return undefined;
    }
}
function tsIsAccessModifier(modifier) {
    return modifier === "private" || modifier === "public" || modifier === "protected";
}
var typescript = (superClass)=>class extends superClass {
        getScopeHandler() {
            return TypeScriptScopeHandler;
        }
        tsIsIdentifier() {
            return tokenIsIdentifier(this.state.type);
        }
        tsTokenCanFollowModifier() {
            return (this.match(0) || this.match(5) || this.match(49) || this.match(21) || this.match(128) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
        }
        tsNextTokenCanFollowModifier() {
            this.next();
            return this.tsTokenCanFollowModifier();
        }
        tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
            if (!tokenIsIdentifier(this.state.type)) return undefined;
            const modifier = this.state.value;
            if (allowedModifiers.indexOf(modifier) !== -1) {
                if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) return undefined;
                if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return modifier;
            }
            return undefined;
        }
        tsParseModifiers(modified, allowedModifiers1, disallowedModifiers, errorTemplate, stopOnStartOfClassStaticBlock1) {
            const enforceOrder = (pos, modifier, before, after)=>{
                if (modifier === before && modified[after]) this.raise(pos, TSErrors.InvalidModifiersOrder, before, after);
            };
            const incompatible = (pos, modifier, mod1, mod2)=>{
                if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) this.raise(pos, TSErrors.IncompatibleModifiers, mod1, mod2);
            };
            for(;;){
                const startPos = this.state.start;
                const modifier = this.tsParseModifier(allowedModifiers1.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock1);
                if (!modifier) break;
                if (tsIsAccessModifier(modifier)) {
                    if (modified.accessibility) this.raise(startPos, TSErrors.DuplicateAccessibilityModifier);
                    else {
                        enforceOrder(startPos, modifier, modifier, "override");
                        enforceOrder(startPos, modifier, modifier, "static");
                        enforceOrder(startPos, modifier, modifier, "readonly");
                        modified.accessibility = modifier;
                    }
                } else {
                    if (Object.hasOwnProperty.call(modified, modifier)) this.raise(startPos, TSErrors.DuplicateModifier, modifier);
                    else {
                        enforceOrder(startPos, modifier, "static", "readonly");
                        enforceOrder(startPos, modifier, "static", "override");
                        enforceOrder(startPos, modifier, "override", "readonly");
                        enforceOrder(startPos, modifier, "abstract", "override");
                        incompatible(startPos, modifier, "declare", "override");
                        incompatible(startPos, modifier, "static", "abstract");
                    }
                    modified[modifier] = true;
                }
                if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) this.raise(startPos, errorTemplate, modifier);
            }
        }
        tsIsListTerminator(kind) {
            switch(kind){
                case "EnumMembers":
                case "TypeMembers":
                    return this.match(8);
                case "HeritageClauseElement":
                    return this.match(5);
                case "TupleElementTypes":
                    return this.match(3);
                case "TypeParametersOrArguments":
                    return this.match(44);
            }
            throw new Error("Unreachable");
        }
        tsParseList(kind2, parseElement) {
            const result = [];
            while(!this.tsIsListTerminator(kind2))result.push(parseElement());
            return result;
        }
        tsParseDelimitedList(kind3, parseElement1, refTrailingCommaPos) {
            return nonNull(this.tsParseDelimitedListWorker(kind3, parseElement1, true, refTrailingCommaPos));
        }
        tsParseDelimitedListWorker(kind4, parseElement2, expectSuccess, refTrailingCommaPos1) {
            const result = [];
            let trailingCommaPos = -1;
            for(;;){
                if (this.tsIsListTerminator(kind4)) break;
                trailingCommaPos = -1;
                const element = parseElement2();
                if (element == null) return undefined;
                result.push(element);
                if (this.eat(12)) {
                    trailingCommaPos = this.state.lastTokStart;
                    continue;
                }
                if (this.tsIsListTerminator(kind4)) break;
                if (expectSuccess) this.expect(12);
                return undefined;
            }
            if (refTrailingCommaPos1) refTrailingCommaPos1.value = trailingCommaPos;
            return result;
        }
        tsParseBracketedList(kind5, parseElement3, bracket, skipFirstToken, refTrailingCommaPos2) {
            if (!skipFirstToken) {
                if (bracket) this.expect(0);
                else this.expect(43);
            }
            const result = this.tsParseDelimitedList(kind5, parseElement3, refTrailingCommaPos2);
            if (bracket) this.expect(3);
            else this.expect(44);
            return result;
        }
        tsParseImportType() {
            const node = this.startNode();
            this.expect(77);
            this.expect(10);
            if (!this.match(123)) this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);
            node.argument = this.parseExprAtom();
            this.expect(11);
            if (this.eat(16)) node.qualifier = this.tsParseEntityName(true);
            if (this.match(43)) node.typeParameters = this.tsParseTypeArguments();
            return this.finishNode(node, "TSImportType");
        }
        tsParseEntityName(allowReservedWords) {
            let entity = this.parseIdentifier();
            while(this.eat(16)){
                const node = this.startNodeAtNode(entity);
                node.left = entity;
                node.right = this.parseIdentifier(allowReservedWords);
                entity = this.finishNode(node, "TSQualifiedName");
            }
            return entity;
        }
        tsParseTypeReference() {
            const node = this.startNode();
            node.typeName = this.tsParseEntityName(false);
            if (!this.hasPrecedingLineBreak() && this.match(43)) node.typeParameters = this.tsParseTypeArguments();
            return this.finishNode(node, "TSTypeReference");
        }
        tsParseThisTypePredicate(lhs) {
            this.next();
            const node = this.startNodeAtNode(lhs);
            node.parameterName = lhs;
            node.typeAnnotation = this.tsParseTypeAnnotation(false);
            node.asserts = false;
            return this.finishNode(node, "TSTypePredicate");
        }
        tsParseThisTypeNode() {
            const node = this.startNode();
            this.next();
            return this.finishNode(node, "TSThisType");
        }
        tsParseTypeQuery() {
            const node = this.startNode();
            this.expect(81);
            if (this.match(77)) node.exprName = this.tsParseImportType();
            else node.exprName = this.tsParseEntityName(true);
            return this.finishNode(node, "TSTypeQuery");
        }
        tsParseTypeParameter() {
            const node = this.startNode();
            node.name = this.tsParseTypeParameterName();
            node.constraint = this.tsEatThenParseType(75);
            node.default = this.tsEatThenParseType(27);
            return this.finishNode(node, "TSTypeParameter");
        }
        tsTryParseTypeParameters() {
            if (this.match(43)) return this.tsParseTypeParameters();
        }
        tsParseTypeParameters() {
            const node = this.startNode();
            if (this.match(43) || this.match(132)) this.next();
            else this.unexpected();
            const refTrailingCommaPos = {
                value: -1
            };
            node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true, refTrailingCommaPos);
            if (node.params.length === 0) this.raise(node.start, TSErrors.EmptyTypeParameters);
            if (refTrailingCommaPos.value !== -1) this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
            return this.finishNode(node, "TSTypeParameterDeclaration");
        }
        tsTryNextParseConstantContext() {
            if (this.lookahead().type === 69) {
                this.next();
                return this.tsParseTypeReference();
            }
            return null;
        }
        tsFillSignature(returnToken, signature) {
            const returnTokenRequired = returnToken === 19;
            signature.typeParameters = this.tsTryParseTypeParameters();
            this.expect(10);
            signature.parameters = this.tsParseBindingListForSignature();
            if (returnTokenRequired) signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
            else if (this.match(returnToken)) signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
        tsParseBindingListForSignature() {
            return this.parseBindingList(11, 41).map((pattern)=>{
                if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);
                return pattern;
            });
        }
        tsParseTypeMemberSemicolon() {
            if (!this.eat(12) && !this.isLineTerminator()) this.expect(13);
        }
        tsParseSignatureMember(kind6, node89) {
            this.tsFillSignature(14, node89);
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(node89, kind6);
        }
        tsIsUnambiguouslyIndexSignature() {
            this.next();
            if (tokenIsIdentifier(this.state.type)) {
                this.next();
                return this.match(14);
            }
            return false;
        }
        tsTryParseIndexSignature(node86) {
            if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) return undefined;
            this.expect(0);
            const id = this.parseIdentifier();
            id.typeAnnotation = this.tsParseTypeAnnotation();
            this.resetEndLocation(id);
            this.expect(3);
            node86.parameters = [
                id
            ];
            const type = this.tsTryParseTypeAnnotation();
            if (type) node86.typeAnnotation = type;
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(node86, "TSIndexSignature");
        }
        tsParsePropertyOrMethodSignature(node87, readonly) {
            if (this.eat(17)) node87.optional = true;
            const nodeAny = node87;
            if (this.match(10) || this.match(43)) {
                if (readonly) this.raise(node87.start, TSErrors.ReadonlyForMethodSignature);
                const method = nodeAny;
                if (method.kind && this.match(43)) this.raise(this.state.pos, TSErrors.AccesorCannotHaveTypeParameters);
                this.tsFillSignature(14, method);
                this.tsParseTypeMemberSemicolon();
                if (method.kind === "get") {
                    if (method.parameters.length > 0) {
                        this.raise(this.state.pos, ErrorMessages.BadGetterArity);
                        if (this.isThisParam(method.parameters[0])) this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
                    }
                } else if (method.kind === "set") {
                    if (method.parameters.length !== 1) this.raise(this.state.pos, ErrorMessages.BadSetterArity);
                    else {
                        const firstParameter = method.parameters[0];
                        if (this.isThisParam(firstParameter)) this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
                        if (firstParameter.type === "Identifier" && firstParameter.optional) this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveOptionalParameter);
                        if (firstParameter.type === "RestElement") this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveRestParameter);
                    }
                    if (method.typeAnnotation) this.raise(method.typeAnnotation.start, TSErrors.SetAccesorCannotHaveReturnType);
                } else method.kind = "method";
                return this.finishNode(method, "TSMethodSignature");
            } else {
                const property = nodeAny;
                if (readonly) property.readonly = true;
                const type = this.tsTryParseTypeAnnotation();
                if (type) property.typeAnnotation = type;
                this.tsParseTypeMemberSemicolon();
                return this.finishNode(property, "TSPropertySignature");
            }
        }
        tsParseTypeMember() {
            const node = this.startNode();
            if (this.match(10) || this.match(43)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
            if (this.match(71)) {
                const id = this.startNode();
                this.next();
                if (this.match(10) || this.match(43)) return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
                else {
                    node.key = this.createIdentifier(id, "new");
                    return this.tsParsePropertyOrMethodSignature(node, false);
                }
            }
            this.tsParseModifiers(node, [
                "readonly"
            ], [
                "declare",
                "abstract",
                "private",
                "protected",
                "public",
                "static",
                "override"
            ], TSErrors.InvalidModifierOnTypeMember);
            const idx = this.tsTryParseIndexSignature(node);
            if (idx) return idx;
            this.parsePropertyName(node, false);
            if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
                node.kind = node.key.name;
                this.parsePropertyName(node, false);
            }
            return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
        }
        tsParseTypeLiteral() {
            const node = this.startNode();
            node.members = this.tsParseObjectTypeMembers();
            return this.finishNode(node, "TSTypeLiteral");
        }
        tsParseObjectTypeMembers() {
            this.expect(5);
            const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            this.expect(8);
            return members;
        }
        tsIsStartOfMappedType() {
            this.next();
            if (this.eat(47)) return this.isContextual(112);
            if (this.isContextual(112)) this.next();
            if (!this.match(0)) return false;
            this.next();
            if (!this.tsIsIdentifier()) return false;
            this.next();
            return this.match(52);
        }
        tsParseMappedTypeParameter() {
            const node = this.startNode();
            node.name = this.tsParseTypeParameterName();
            node.constraint = this.tsExpectThenParseType(52);
            return this.finishNode(node, "TSTypeParameter");
        }
        tsParseMappedType() {
            const node = this.startNode();
            this.expect(5);
            if (this.match(47)) {
                node.readonly = this.state.value;
                this.next();
                this.expectContextual(112);
            } else if (this.eatContextual(112)) node.readonly = true;
            this.expect(0);
            node.typeParameter = this.tsParseMappedTypeParameter();
            node.nameType = this.eatContextual(87) ? this.tsParseType() : null;
            this.expect(3);
            if (this.match(47)) {
                node.optional = this.state.value;
                this.next();
                this.expect(17);
            } else if (this.eat(17)) node.optional = true;
            node.typeAnnotation = this.tsTryParseType();
            this.semicolon();
            this.expect(8);
            return this.finishNode(node, "TSMappedType");
        }
        tsParseTupleType() {
            const node = this.startNode();
            node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
            let seenOptionalElement = false;
            let labeledElements = null;
            node.elementTypes.forEach((elementNode)=>{
                var _labeledElements;
                let { type  } = elementNode;
                if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);
                seenOptionalElement = seenOptionalElement || type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType";
                if (type === "TSRestType") {
                    elementNode = elementNode.typeAnnotation;
                    type = elementNode.type;
                }
                const isLabeled = type === "TSNamedTupleMember";
                labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;
                if (labeledElements !== isLabeled) this.raise(elementNode.start, TSErrors.MixedLabeledAndUnlabeledElements);
            });
            return this.finishNode(node, "TSTupleType");
        }
        tsParseTupleElementType() {
            const { start: startPos , startLoc  } = this.state;
            const rest = this.eat(21);
            let type = this.tsParseType();
            const optional = this.eat(17);
            const labeled = this.eat(14);
            if (labeled) {
                const labeledNode = this.startNodeAtNode(type);
                labeledNode.optional = optional;
                if (type.type === "TSTypeReference" && !type.typeParameters && type.typeName.type === "Identifier") labeledNode.label = type.typeName;
                else {
                    this.raise(type.start, TSErrors.InvalidTupleMemberLabel);
                    labeledNode.label = type;
                }
                labeledNode.elementType = this.tsParseType();
                type = this.finishNode(labeledNode, "TSNamedTupleMember");
            } else if (optional) {
                const optionalTypeNode = this.startNodeAtNode(type);
                optionalTypeNode.typeAnnotation = type;
                type = this.finishNode(optionalTypeNode, "TSOptionalType");
            }
            if (rest) {
                const restNode = this.startNodeAt(startPos, startLoc);
                restNode.typeAnnotation = type;
                type = this.finishNode(restNode, "TSRestType");
            }
            return type;
        }
        tsParseParenthesizedType() {
            const node = this.startNode();
            this.expect(10);
            node.typeAnnotation = this.tsParseType();
            this.expect(11);
            return this.finishNode(node, "TSParenthesizedType");
        }
        tsParseFunctionOrConstructorType(type16, abstract) {
            const node = this.startNode();
            if (type16 === "TSConstructorType") {
                node.abstract = !!abstract;
                if (abstract) this.next();
                this.next();
            }
            this.tsFillSignature(19, node);
            return this.finishNode(node, type16);
        }
        tsParseLiteralTypeNode() {
            const node = this.startNode();
            node.literal = (()=>{
                switch(this.state.type){
                    case 124:
                    case 125:
                    case 123:
                    case 79:
                    case 80:
                        return this.parseExprAtom();
                    default:
                        throw this.unexpected();
                }
            })();
            return this.finishNode(node, "TSLiteralType");
        }
        tsParseTemplateLiteralType() {
            const node = this.startNode();
            node.literal = this.parseTemplate(false);
            return this.finishNode(node, "TSLiteralType");
        }
        parseTemplateSubstitution() {
            if (this.state.inType) return this.tsParseType();
            return super.parseTemplateSubstitution();
        }
        tsParseThisTypeOrThisTypePredicate() {
            const thisKeyword = this.tsParseThisTypeNode();
            if (this.isContextual(107) && !this.hasPrecedingLineBreak()) return this.tsParseThisTypePredicate(thisKeyword);
            else return thisKeyword;
        }
        tsParseNonArrayType() {
            switch(this.state.type){
                case 123:
                case 124:
                case 125:
                case 79:
                case 80:
                    return this.tsParseLiteralTypeNode();
                case 47:
                    if (this.state.value === "-") {
                        const node = this.startNode();
                        const nextToken = this.lookahead();
                        if (nextToken.type !== 124 && nextToken.type !== 125) throw this.unexpected();
                        node.literal = this.parseMaybeUnary();
                        return this.finishNode(node, "TSLiteralType");
                    }
                    break;
                case 72:
                    return this.tsParseThisTypeOrThisTypePredicate();
                case 81:
                    return this.tsParseTypeQuery();
                case 77:
                    return this.tsParseImportType();
                case 5:
                    return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                case 0:
                    return this.tsParseTupleType();
                case 10:
                    return this.tsParseParenthesizedType();
                case 22:
                    return this.tsParseTemplateLiteralType();
                default:
                    {
                        const { type  } = this.state;
                        if (tokenIsIdentifier(type) || type === 82 || type === 78) {
                            const nodeType = type === 82 ? "TSVoidKeyword" : type === 78 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
                            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {
                                const node = this.startNode();
                                this.next();
                                return this.finishNode(node, nodeType);
                            }
                            return this.tsParseTypeReference();
                        }
                    }
            }
            throw this.unexpected();
        }
        tsParseArrayTypeOrHigher() {
            let type = this.tsParseNonArrayType();
            while(!this.hasPrecedingLineBreak() && this.eat(0))if (this.match(3)) {
                const node = this.startNodeAtNode(type);
                node.elementType = type;
                this.expect(3);
                type = this.finishNode(node, "TSArrayType");
            } else {
                const node = this.startNodeAtNode(type);
                node.objectType = type;
                node.indexType = this.tsParseType();
                this.expect(3);
                type = this.finishNode(node, "TSIndexedAccessType");
            }
            return type;
        }
        tsParseTypeOperator() {
            const node = this.startNode();
            const operator = this.state.value;
            this.next();
            node.operator = operator;
            node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
            if (operator === "readonly") this.tsCheckTypeAnnotationForReadOnly(node);
            return this.finishNode(node, "TSTypeOperator");
        }
        tsCheckTypeAnnotationForReadOnly(node88) {
            switch(node88.typeAnnotation.type){
                case "TSTupleType":
                case "TSArrayType":
                    return;
                default:
                    this.raise(node88.start, TSErrors.UnexpectedReadonly);
            }
        }
        tsParseInferType() {
            const node = this.startNode();
            this.expectContextual(106);
            const typeParameter = this.startNode();
            typeParameter.name = this.tsParseTypeParameterName();
            node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
            return this.finishNode(node, "TSInferType");
        }
        tsParseTypeOperatorOrHigher() {
            const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
            return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(106) ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
        }
        tsParseUnionOrIntersectionType(kind7, parseConstituentType, operator) {
            const node = this.startNode();
            const hasLeadingOperator = this.eat(operator);
            const types = [];
            do types.push(parseConstituentType());
            while (this.eat(operator))
            if (types.length === 1 && !hasLeadingOperator) return types[0];
            node.types = types;
            return this.finishNode(node, kind7);
        }
        tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 41);
        }
        tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 39);
        }
        tsIsStartOfFunctionType() {
            if (this.match(43)) return true;
            return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
        }
        tsSkipParameterStart() {
            if (tokenIsIdentifier(this.state.type) || this.match(72)) {
                this.next();
                return true;
            }
            if (this.match(5)) {
                let braceStackCounter = 1;
                this.next();
                while(braceStackCounter > 0){
                    if (this.match(5)) ++braceStackCounter;
                    else if (this.match(8)) --braceStackCounter;
                    this.next();
                }
                return true;
            }
            if (this.match(0)) {
                let braceStackCounter = 1;
                this.next();
                while(braceStackCounter > 0){
                    if (this.match(0)) ++braceStackCounter;
                    else if (this.match(3)) --braceStackCounter;
                    this.next();
                }
                return true;
            }
            return false;
        }
        tsIsUnambiguouslyStartOfFunctionType() {
            this.next();
            if (this.match(11) || this.match(21)) return true;
            if (this.tsSkipParameterStart()) {
                if (this.match(14) || this.match(12) || this.match(17) || this.match(27)) return true;
                if (this.match(11)) {
                    this.next();
                    if (this.match(19)) return true;
                }
            }
            return false;
        }
        tsParseTypeOrTypePredicateAnnotation(returnToken1) {
            return this.tsInType(()=>{
                const t = this.startNode();
                this.expect(returnToken1);
                const node = this.startNode();
                const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
                if (asserts && this.match(72)) {
                    let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
                    if (thisTypePredicate.type === "TSThisType") {
                        node.parameterName = thisTypePredicate;
                        node.asserts = true;
                        node.typeAnnotation = null;
                        thisTypePredicate = this.finishNode(node, "TSTypePredicate");
                    } else {
                        this.resetStartLocationFromNode(thisTypePredicate, node);
                        thisTypePredicate.asserts = true;
                    }
                    t.typeAnnotation = thisTypePredicate;
                    return this.finishNode(t, "TSTypeAnnotation");
                }
                const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
                if (!typePredicateVariable) {
                    if (!asserts) return this.tsParseTypeAnnotation(false, t);
                    node.parameterName = this.parseIdentifier();
                    node.asserts = asserts;
                    node.typeAnnotation = null;
                    t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
                    return this.finishNode(t, "TSTypeAnnotation");
                }
                const type = this.tsParseTypeAnnotation(false);
                node.parameterName = typePredicateVariable;
                node.typeAnnotation = type;
                node.asserts = asserts;
                t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
                return this.finishNode(t, "TSTypeAnnotation");
            });
        }
        tsTryParseTypeOrTypePredicateAnnotation() {
            return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : undefined;
        }
        tsTryParseTypeAnnotation() {
            return this.match(14) ? this.tsParseTypeAnnotation() : undefined;
        }
        tsTryParseType() {
            return this.tsEatThenParseType(14);
        }
        tsParseTypePredicatePrefix() {
            const id = this.parseIdentifier();
            if (this.isContextual(107) && !this.hasPrecedingLineBreak()) {
                this.next();
                return id;
            }
        }
        tsParseTypePredicateAsserts() {
            if (this.state.type !== 100) return false;
            const containsEsc = this.state.containsEsc;
            this.next();
            if (!tokenIsIdentifier(this.state.type) && !this.match(72)) return false;
            if (containsEsc) this.raise(this.state.lastTokStart, ErrorMessages.InvalidEscapedReservedWord, "asserts");
            return true;
        }
        tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
            this.tsInType(()=>{
                if (eatColon) this.expect(14);
                t.typeAnnotation = this.tsParseType();
            });
            return this.finishNode(t, "TSTypeAnnotation");
        }
        tsParseType() {
            assert(this.state.inType);
            const type = this.tsParseNonConditionalType();
            if (this.hasPrecedingLineBreak() || !this.eat(75)) return type;
            const node = this.startNodeAtNode(type);
            node.checkType = type;
            node.extendsType = this.tsParseNonConditionalType();
            this.expect(17);
            node.trueType = this.tsParseType();
            this.expect(14);
            node.falseType = this.tsParseType();
            return this.finishNode(node, "TSConditionalType");
        }
        isAbstractConstructorSignature() {
            return this.isContextual(114) && this.lookahead().type === 71;
        }
        tsParseNonConditionalType() {
            if (this.tsIsStartOfFunctionType()) return this.tsParseFunctionOrConstructorType("TSFunctionType");
            if (this.match(71)) return this.tsParseFunctionOrConstructorType("TSConstructorType");
            else if (this.isAbstractConstructorSignature()) return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
            return this.tsParseUnionTypeOrHigher();
        }
        tsParseTypeAssertion() {
            if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) this.raise(this.state.start, TSErrors.ReservedTypeAssertion);
            const node = this.startNode();
            const _const = this.tsTryNextParseConstantContext();
            node.typeAnnotation = _const || this.tsNextThenParseType();
            this.expect(44);
            node.expression = this.parseMaybeUnary();
            return this.finishNode(node, "TSTypeAssertion");
        }
        tsParseHeritageClause(descriptor) {
            const originalStart = this.state.start;
            const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
            if (!delimitedList.length) this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);
            return delimitedList;
        }
        tsParseExpressionWithTypeArguments() {
            const node = this.startNode();
            node.expression = this.tsParseEntityName(false);
            if (this.match(43)) node.typeParameters = this.tsParseTypeArguments();
            return this.finishNode(node, "TSExpressionWithTypeArguments");
        }
        tsParseInterfaceDeclaration(node91) {
            if (tokenIsIdentifier(this.state.type)) {
                node91.id = this.parseIdentifier();
                this.checkLVal(node91.id, "typescript interface declaration", BIND_TS_INTERFACE);
            } else {
                node91.id = null;
                this.raise(this.state.start, TSErrors.MissingInterfaceName);
            }
            node91.typeParameters = this.tsTryParseTypeParameters();
            if (this.eat(75)) node91.extends = this.tsParseHeritageClause("extends");
            const body = this.startNode();
            body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
            node91.body = this.finishNode(body, "TSInterfaceBody");
            return this.finishNode(node91, "TSInterfaceDeclaration");
        }
        tsParseTypeAliasDeclaration(node90) {
            node90.id = this.parseIdentifier();
            this.checkLVal(node90.id, "typescript type alias", BIND_TS_TYPE);
            node90.typeParameters = this.tsTryParseTypeParameters();
            node90.typeAnnotation = this.tsInType(()=>{
                this.expect(27);
                if (this.isContextual(105) && this.lookahead().type !== 16) {
                    const node = this.startNode();
                    this.next();
                    return this.finishNode(node, "TSIntrinsicKeyword");
                }
                return this.tsParseType();
            });
            this.semicolon();
            return this.finishNode(node90, "TSTypeAliasDeclaration");
        }
        tsInNoContext(cb) {
            const oldContext = this.state.context;
            this.state.context = [
                oldContext[0]
            ];
            try {
                return cb();
            } finally{
                this.state.context = oldContext;
            }
        }
        tsInType(cb1) {
            const oldInType = this.state.inType;
            this.state.inType = true;
            try {
                return cb1();
            } finally{
                this.state.inType = oldInType;
            }
        }
        tsEatThenParseType(token) {
            return !this.match(token) ? undefined : this.tsNextThenParseType();
        }
        tsExpectThenParseType(token6) {
            return this.tsDoThenParseType(()=>this.expect(token6)
            );
        }
        tsNextThenParseType() {
            return this.tsDoThenParseType(()=>this.next()
            );
        }
        tsDoThenParseType(cb2) {
            return this.tsInType(()=>{
                cb2();
                return this.tsParseType();
            });
        }
        tsParseEnumMember() {
            const node = this.startNode();
            node.id = this.match(123) ? this.parseExprAtom() : this.parseIdentifier(true);
            if (this.eat(27)) node.initializer = this.parseMaybeAssignAllowIn();
            return this.finishNode(node, "TSEnumMember");
        }
        tsParseEnumDeclaration(node97, isConst) {
            if (isConst) node97.const = true;
            node97.id = this.parseIdentifier();
            this.checkLVal(node97.id, "typescript enum declaration", isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
            this.expect(5);
            node97.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
            this.expect(8);
            return this.finishNode(node97, "TSEnumDeclaration");
        }
        tsParseModuleBlock() {
            const node = this.startNode();
            this.scope.enter(SCOPE_OTHER);
            this.expect(5);
            this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);
            this.scope.exit();
            return this.finishNode(node, "TSModuleBlock");
        }
        tsParseModuleOrNamespaceDeclaration(node92, nested = false) {
            node92.id = this.parseIdentifier();
            if (!nested) this.checkLVal(node92.id, "module or namespace declaration", BIND_TS_NAMESPACE);
            if (this.eat(16)) {
                const inner = this.startNode();
                this.tsParseModuleOrNamespaceDeclaration(inner, true);
                node92.body = inner;
            } else {
                this.scope.enter(SCOPE_TS_MODULE);
                this.prodParam.enter(PARAM);
                node92.body = this.tsParseModuleBlock();
                this.prodParam.exit();
                this.scope.exit();
            }
            return this.finishNode(node92, "TSModuleDeclaration");
        }
        tsParseAmbientExternalModuleDeclaration(node93) {
            if (this.isContextual(103)) {
                node93.global = true;
                node93.id = this.parseIdentifier();
            } else if (this.match(123)) node93.id = this.parseExprAtom();
            else this.unexpected();
            if (this.match(5)) {
                this.scope.enter(SCOPE_TS_MODULE);
                this.prodParam.enter(PARAM);
                node93.body = this.tsParseModuleBlock();
                this.prodParam.exit();
                this.scope.exit();
            } else this.semicolon();
            return this.finishNode(node93, "TSModuleDeclaration");
        }
        tsParseImportEqualsDeclaration(node94, isExport) {
            node94.isExport = isExport || false;
            node94.id = this.parseIdentifier();
            this.checkLVal(node94.id, "import equals declaration", BIND_LEXICAL);
            this.expect(27);
            const moduleReference = this.tsParseModuleReference();
            if (node94.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") this.raise(moduleReference.start, TSErrors.ImportAliasHasImportType);
            node94.moduleReference = moduleReference;
            this.semicolon();
            return this.finishNode(node94, "TSImportEqualsDeclaration");
        }
        tsIsExternalModuleReference() {
            return this.isContextual(110) && this.lookaheadCharCode() === 40;
        }
        tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
        }
        tsParseExternalModuleReference() {
            const node = this.startNode();
            this.expectContextual(110);
            this.expect(10);
            if (!this.match(123)) throw this.unexpected();
            node.expression = this.parseExprAtom();
            this.expect(11);
            return this.finishNode(node, "TSExternalModuleReference");
        }
        tsLookAhead(f) {
            const state = this.state.clone();
            const res = f();
            this.state = state;
            return res;
        }
        tsTryParseAndCatch(f1) {
            const result = this.tryParse((abort)=>f1() || abort()
            );
            if (result.aborted || !result.node) return undefined;
            if (result.error) this.state = result.failState;
            return result.node;
        }
        tsTryParse(f2) {
            const state = this.state.clone();
            const result = f2();
            if (result !== undefined && result !== false) return result;
            else {
                this.state = state;
                return undefined;
            }
        }
        tsTryParseDeclare(nany) {
            if (this.isLineTerminator()) return;
            let starttype = this.state.type;
            let kind;
            if (this.isContextual(93)) {
                starttype = 68;
                kind = "let";
            }
            return this.tsInAmbientContext(()=>{
                switch(starttype){
                    case 62:
                        nany.declare = true;
                        return this.parseFunctionStatement(nany, false, true);
                    case 74:
                        nany.declare = true;
                        return this.parseClass(nany, true, false);
                    case 69:
                        if (this.match(69) && this.isLookaheadContextual("enum")) {
                            this.expect(69);
                            this.expectContextual(116);
                            return this.tsParseEnumDeclaration(nany, true);
                        }
                    case 68:
                        kind = kind || this.state.value;
                        return this.parseVarStatement(nany, kind);
                    case 103:
                        return this.tsParseAmbientExternalModuleDeclaration(nany);
                    default:
                        if (tokenIsIdentifier(starttype)) return this.tsParseDeclaration(nany, this.state.value, true);
                }
            });
        }
        tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, true);
        }
        tsParseExpressionStatement(node95, expr6) {
            switch(expr6.name){
                case "declare":
                    {
                        const declaration = this.tsTryParseDeclare(node95);
                        if (declaration) {
                            declaration.declare = true;
                            return declaration;
                        }
                        break;
                    }
                case "global":
                    if (this.match(5)) {
                        this.scope.enter(SCOPE_TS_MODULE);
                        this.prodParam.enter(PARAM);
                        const mod = node95;
                        mod.global = true;
                        mod.id = expr6;
                        mod.body = this.tsParseModuleBlock();
                        this.scope.exit();
                        this.prodParam.exit();
                        return this.finishNode(mod, "TSModuleDeclaration");
                    }
                    break;
                default:
                    return this.tsParseDeclaration(node95, expr6.name, false);
            }
        }
        tsParseDeclaration(node96, value, next) {
            switch(value){
                case "abstract":
                    if (this.tsCheckLineTerminator(next) && (this.match(74) || tokenIsIdentifier(this.state.type))) return this.tsParseAbstractDeclaration(node96);
                    break;
                case "enum":
                    if (next || tokenIsIdentifier(this.state.type)) {
                        if (next) this.next();
                        return this.tsParseEnumDeclaration(node96, false);
                    }
                    break;
                case "interface":
                    if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) return this.tsParseInterfaceDeclaration(node96);
                    break;
                case "module":
                    if (this.tsCheckLineTerminator(next)) {
                        if (this.match(123)) return this.tsParseAmbientExternalModuleDeclaration(node96);
                        else if (tokenIsIdentifier(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(node96);
                    }
                    break;
                case "namespace":
                    if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(node96);
                    break;
                case "type":
                    if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) return this.tsParseTypeAliasDeclaration(node96);
                    break;
            }
        }
        tsCheckLineTerminator(next1) {
            if (next1) {
                if (this.hasFollowingLineBreak()) return false;
                this.next();
                return true;
            }
            return !this.isLineTerminator();
        }
        tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
            if (!this.match(43)) return undefined;
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = true;
            const res = this.tsTryParseAndCatch(()=>{
                const node = this.startNodeAt(startPos, startLoc);
                node.typeParameters = this.tsParseTypeParameters();
                super.parseFunctionParams(node);
                node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
                this.expect(19);
                return node;
            });
            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
            if (!res) return undefined;
            return this.parseArrowExpression(res, null, true);
        }
        tsParseTypeArguments() {
            const node = this.startNode();
            node.params = this.tsInType(()=>this.tsInNoContext(()=>{
                    this.expect(43);
                    return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
                })
            );
            if (node.params.length === 0) this.raise(node.start, TSErrors.EmptyTypeArguments);
            this.expect(44);
            return this.finishNode(node, "TSTypeParameterInstantiation");
        }
        tsIsDeclarationStart() {
            return tokenIsTSDeclarationStart(this.state.type);
        }
        isExportDefaultSpecifier() {
            if (this.tsIsDeclarationStart()) return false;
            return super.isExportDefaultSpecifier();
        }
        parseAssignableListItem(allowModifiers, decorators) {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            let accessibility;
            let readonly = false;
            let override = false;
            if (allowModifiers !== undefined) {
                const modified = {
                };
                this.tsParseModifiers(modified, [
                    "public",
                    "private",
                    "protected",
                    "override",
                    "readonly"
                ]);
                accessibility = modified.accessibility;
                override = modified.override;
                readonly = modified.readonly;
                if (allowModifiers === false && (accessibility || readonly || override)) this.raise(startPos, TSErrors.UnexpectedParameterModifier);
            }
            const left = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(left);
            const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
            if (accessibility || readonly || override) {
                const pp = this.startNodeAt(startPos, startLoc);
                if (decorators.length) pp.decorators = decorators;
                if (accessibility) pp.accessibility = accessibility;
                if (readonly) pp.readonly = readonly;
                if (override) pp.override = override;
                if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);
                pp.parameter = elt;
                return this.finishNode(pp, "TSParameterProperty");
            }
            if (decorators.length) left.decorators = decorators;
            return elt;
        }
        parseFunctionBodyAndFinish(node99, type, isMethod = false) {
            if (this.match(14)) node99.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
            const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : undefined;
            if (bodilessType && !this.match(5) && this.isLineTerminator()) {
                this.finishNode(node99, bodilessType);
                return;
            }
            if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
                this.raise(node99.start, TSErrors.DeclareFunctionHasImplementation);
                if (node99.declare) {
                    super.parseFunctionBodyAndFinish(node99, bodilessType, isMethod);
                    return;
                }
            }
            super.parseFunctionBodyAndFinish(node99, type, isMethod);
        }
        registerFunctionStatementId(node98) {
            if (!node98.body && node98.id) this.checkLVal(node98.id, "function name", BIND_TS_AMBIENT);
            else super.registerFunctionStatementId(...arguments);
        }
        tsCheckForInvalidTypeCasts(items) {
            items.forEach((node)=>{
                if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") this.raise(node.typeAnnotation.start, TSErrors.UnexpectedTypeAnnotation);
            });
        }
        toReferencedList(exprList, isInParens) {
            this.tsCheckForInvalidTypeCasts(exprList);
            return exprList;
        }
        parseArrayLike(...args7) {
            const node = super.parseArrayLike(...args7);
            if (node.type === "ArrayExpression") this.tsCheckForInvalidTypeCasts(node.elements);
            return node;
        }
        parseSubscript(base, startPos13, startLoc15, noCalls, state) {
            if (!this.hasPrecedingLineBreak() && this.match(33)) {
                this.state.canStartJSXElement = false;
                this.next();
                const nonNullExpression = this.startNodeAt(startPos13, startLoc15);
                nonNullExpression.expression = base;
                return this.finishNode(nonNullExpression, "TSNonNullExpression");
            }
            let isOptionalCall = false;
            if (this.match(18) && this.lookaheadCharCode() === 60) {
                if (noCalls) {
                    state.stop = true;
                    return base;
                }
                state.optionalChainMember = isOptionalCall = true;
                this.next();
            }
            if (this.match(43)) {
                let missingParenErrorPos;
                const result1 = this.tsTryParseAndCatch(()=>{
                    if (!noCalls && this.atPossibleAsyncArrow(base)) {
                        const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos13, startLoc15);
                        if (asyncArrowFn) return asyncArrowFn;
                    }
                    const node = this.startNodeAt(startPos13, startLoc15);
                    node.callee = base;
                    const typeArguments = this.tsParseTypeArguments();
                    if (typeArguments) {
                        if (isOptionalCall && !this.match(10)) {
                            missingParenErrorPos = this.state.pos;
                            this.unexpected();
                        }
                        if (!noCalls && this.eat(10)) {
                            node.arguments = this.parseCallExpressionArguments(11, false);
                            this.tsCheckForInvalidTypeCasts(node.arguments);
                            node.typeParameters = typeArguments;
                            if (state.optionalChainMember) node.optional = isOptionalCall;
                            return this.finishCallExpression(node, state.optionalChainMember);
                        } else if (this.match(22)) {
                            const result = this.parseTaggedTemplateExpression(base, startPos13, startLoc15, state);
                            result.typeParameters = typeArguments;
                            return result;
                        }
                    }
                    this.unexpected();
                });
                if (missingParenErrorPos) this.unexpected(missingParenErrorPos, 10);
                if (result1) return result1;
            }
            return super.parseSubscript(base, startPos13, startLoc15, noCalls, state);
        }
        parseNewArguments(node) {
            if (this.match(43)) {
                const typeParameters = this.tsTryParseAndCatch(()=>{
                    const args = this.tsParseTypeArguments();
                    if (!this.match(10)) this.unexpected();
                    return args;
                });
                if (typeParameters) node.typeParameters = typeParameters;
            }
            super.parseNewArguments(node);
        }
        parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
            if (tokenOperatorPrecedence(52) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(87)) {
                const node = this.startNodeAt(leftStartPos, leftStartLoc);
                node.expression = left;
                const _const = this.tsTryNextParseConstantContext();
                if (_const) node.typeAnnotation = _const;
                else node.typeAnnotation = this.tsNextThenParseType();
                this.finishNode(node, "TSAsExpression");
                this.reScan_lt_gt();
                return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
            }
            return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);
        }
        checkReservedWord(word, startLoc16, checkKeywords, isBinding) {
        }
        checkDuplicateExports() {
        }
        parseImport(node100) {
            node100.importKind = "value";
            if (tokenIsIdentifier(this.state.type) || this.match(49) || this.match(5)) {
                let ahead = this.lookahead();
                if (this.isContextual(120) && ahead.type !== 12 && ahead.type !== 91 && ahead.type !== 27) {
                    node100.importKind = "type";
                    this.next();
                    ahead = this.lookahead();
                }
                if (tokenIsIdentifier(this.state.type) && ahead.type === 27) return this.tsParseImportEqualsDeclaration(node100);
            }
            const importNode = super.parseImport(node100);
            if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") this.raise(importNode.start, TSErrors.TypeImportCannotSpecifyDefaultAndNamed);
            return importNode;
        }
        parseExport(node101) {
            if (this.match(77)) {
                this.next();
                if (this.isContextual(120) && this.lookaheadCharCode() !== 61) {
                    node101.importKind = "type";
                    this.next();
                } else node101.importKind = "value";
                return this.tsParseImportEqualsDeclaration(node101, true);
            } else if (this.eat(27)) {
                const assign = node101;
                assign.expression = this.parseExpression();
                this.semicolon();
                return this.finishNode(assign, "TSExportAssignment");
            } else if (this.eatContextual(87)) {
                const decl = node101;
                this.expectContextual(118);
                decl.id = this.parseIdentifier();
                this.semicolon();
                return this.finishNode(decl, "TSNamespaceExportDeclaration");
            } else {
                if (this.isContextual(120) && this.lookahead().type === 5) {
                    this.next();
                    node101.exportKind = "type";
                } else node101.exportKind = "value";
                return super.parseExport(node101);
            }
        }
        isAbstractClass() {
            return this.isContextual(114) && this.lookahead().type === 74;
        }
        parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
                const cls = this.startNode();
                this.next();
                cls.abstract = true;
                this.parseClass(cls, true, true);
                return cls;
            }
            if (this.match(119)) {
                const interfaceNode = this.startNode();
                this.next();
                const result = this.tsParseInterfaceDeclaration(interfaceNode);
                if (result) return result;
            }
            return super.parseExportDefaultExpression();
        }
        parseStatementContent(context, topLevel) {
            if (this.state.type === 69) {
                const ahead = this.lookahead();
                if (ahead.type === 116) {
                    const node = this.startNode();
                    this.next();
                    this.expectContextual(116);
                    return this.tsParseEnumDeclaration(node, true);
                }
            }
            return super.parseStatementContent(context, topLevel);
        }
        parseAccessModifier() {
            return this.tsParseModifier([
                "public",
                "protected",
                "private"
            ]);
        }
        tsHasSomeModifiers(member, modifiers) {
            return modifiers.some((modifier)=>{
                if (tsIsAccessModifier(modifier)) return member.accessibility === modifier;
                return !!member[modifier];
            });
        }
        tsIsStartOfStaticBlocks() {
            return this.isContextual(98) && this.lookaheadCharCode() === 123;
        }
        parseClassMember(classBody, member1, state3) {
            const modifiers = [
                "declare",
                "private",
                "public",
                "protected",
                "override",
                "abstract",
                "readonly",
                "static"
            ];
            this.tsParseModifiers(member1, modifiers, undefined, undefined, true);
            const callParseClassMemberWithIsStatic = ()=>{
                if (this.tsIsStartOfStaticBlocks()) {
                    this.next();
                    this.next();
                    if (this.tsHasSomeModifiers(member1, modifiers)) this.raise(this.state.pos, TSErrors.StaticBlockCannotHaveModifier);
                    this.parseClassStaticBlock(classBody, member1);
                } else this.parseClassMemberWithIsStatic(classBody, member1, state3, !!member1.static);
            };
            if (member1.declare) this.tsInAmbientContext(callParseClassMemberWithIsStatic);
            else callParseClassMemberWithIsStatic();
        }
        parseClassMemberWithIsStatic(classBody3, member2, state4, isStatic) {
            const idx = this.tsTryParseIndexSignature(member2);
            if (idx) {
                classBody3.body.push(idx);
                if (member2.abstract) this.raise(member2.start, TSErrors.IndexSignatureHasAbstract);
                if (member2.accessibility) this.raise(member2.start, TSErrors.IndexSignatureHasAccessibility, member2.accessibility);
                if (member2.declare) this.raise(member2.start, TSErrors.IndexSignatureHasDeclare);
                if (member2.override) this.raise(member2.start, TSErrors.IndexSignatureHasOverride);
                return;
            }
            if (!this.state.inAbstractClass && member2.abstract) this.raise(member2.start, TSErrors.NonAbstractClassHasAbstractMethod);
            if (member2.override) {
                if (!state4.hadSuperClass) this.raise(member2.start, TSErrors.OverrideNotInSubClass);
            }
            super.parseClassMemberWithIsStatic(classBody3, member2, state4, isStatic);
        }
        parsePostMemberNameModifiers(methodOrProp) {
            const optional = this.eat(17);
            if (optional) methodOrProp.optional = true;
            if (methodOrProp.readonly && this.match(10)) this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);
            if (methodOrProp.declare && this.match(10)) this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);
        }
        parseExpressionStatement(node102, expr4) {
            const decl = expr4.type === "Identifier" ? this.tsParseExpressionStatement(node102, expr4) : undefined;
            return decl || super.parseExpressionStatement(node102, expr4);
        }
        shouldParseExportDeclaration() {
            if (this.tsIsDeclarationStart()) return true;
            return super.shouldParseExportDeclaration();
        }
        parseConditional(expr5, startPos14, startLoc17, refExpressionErrors) {
            if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(expr5, startPos14, startLoc17, refExpressionErrors);
            const result = this.tryParse(()=>super.parseConditional(expr5, startPos14, startLoc17)
            );
            if (!result.node) {
                if (result.error) super.setOptionalParametersError(refExpressionErrors, result.error);
                return expr5;
            }
            if (result.error) this.state = result.failState;
            return result.node;
        }
        parseParenItem(node103, startPos15, startLoc18) {
            node103 = super.parseParenItem(node103, startPos15, startLoc18);
            if (this.eat(17)) {
                node103.optional = true;
                this.resetEndLocation(node103);
            }
            if (this.match(14)) {
                const typeCastNode = this.startNodeAt(startPos15, startLoc18);
                typeCastNode.expression = node103;
                typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
                return this.finishNode(typeCastNode, "TSTypeCastExpression");
            }
            return node103;
        }
        parseExportDeclaration(node104) {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            const isDeclare = this.eatContextual(115);
            if (isDeclare && (this.isContextual(115) || !this.shouldParseExportDeclaration())) throw this.raise(this.state.start, TSErrors.ExpectedAmbientAfterExportDeclare);
            let declaration;
            if (tokenIsIdentifier(this.state.type)) declaration = this.tsTryParseExportDeclaration();
            if (!declaration) declaration = super.parseExportDeclaration(node104);
            if (declaration && (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare)) node104.exportKind = "type";
            if (declaration && isDeclare) {
                this.resetStartLocation(declaration, startPos, startLoc);
                declaration.declare = true;
            }
            return declaration;
        }
        parseClassId(node105, isStatement, optionalId) {
            if ((!isStatement || optionalId) && this.isContextual(104)) return;
            super.parseClassId(node105, isStatement, optionalId, node105.declare ? BIND_TS_AMBIENT : BIND_CLASS);
            const typeParameters = this.tsTryParseTypeParameters();
            if (typeParameters) node105.typeParameters = typeParameters;
        }
        parseClassPropertyAnnotation(node106) {
            if (!node106.optional && this.eat(33)) node106.definite = true;
            const type = this.tsTryParseTypeAnnotation();
            if (type) node106.typeAnnotation = type;
        }
        parseClassProperty(node107) {
            this.parseClassPropertyAnnotation(node107);
            if (this.state.isAmbientContext && this.match(27)) this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);
            if (node107.abstract && this.match(27)) {
                const { key  } = node107;
                this.raise(this.state.start, TSErrors.AbstractPropertyHasInitializer, key.type === "Identifier" && !node107.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`);
            }
            return super.parseClassProperty(node107);
        }
        parseClassPrivateProperty(node108) {
            if (node108.abstract) this.raise(node108.start, TSErrors.PrivateElementHasAbstract);
            if (node108.accessibility) this.raise(node108.start, TSErrors.PrivateElementHasAccessibility, node108.accessibility);
            this.parseClassPropertyAnnotation(node108);
            return super.parseClassPrivateProperty(node108);
        }
        pushClassMethod(classBody4, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            const typeParameters = this.tsTryParseTypeParameters();
            if (typeParameters && isConstructor) this.raise(typeParameters.start, TSErrors.ConstructorHasTypeParameters);
            if (method.declare && (method.kind === "get" || method.kind === "set")) this.raise(method.start, TSErrors.DeclareAccessor, method.kind);
            if (typeParameters) method.typeParameters = typeParameters;
            super.pushClassMethod(classBody4, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        }
        pushClassPrivateMethod(classBody5, method5, isGenerator5, isAsync6) {
            const typeParameters = this.tsTryParseTypeParameters();
            if (typeParameters) method5.typeParameters = typeParameters;
            super.pushClassPrivateMethod(classBody5, method5, isGenerator5, isAsync6);
        }
        declareClassPrivateMethodInScope(node109, kind8) {
            if (node109.type === "TSDeclareMethod") return;
            if (node109.type === "MethodDefinition" && !node109.value.body) return;
            super.declareClassPrivateMethodInScope(node109, kind8);
        }
        parseClassSuper(node110) {
            super.parseClassSuper(node110);
            if (node110.superClass && this.match(43)) node110.superTypeParameters = this.tsParseTypeArguments();
            if (this.eatContextual(104)) node110.implements = this.tsParseHeritageClause("implements");
        }
        parseObjPropValue(prop, ...args) {
            const typeParameters = this.tsTryParseTypeParameters();
            if (typeParameters) prop.typeParameters = typeParameters;
            super.parseObjPropValue(prop, ...args);
        }
        parseFunctionParams(node111, allowModifiers1) {
            const typeParameters = this.tsTryParseTypeParameters();
            if (typeParameters) node111.typeParameters = typeParameters;
            super.parseFunctionParams(node111, allowModifiers1);
        }
        parseVarId(decl, kind9) {
            super.parseVarId(decl, kind9);
            if (decl.id.type === "Identifier" && this.eat(33)) decl.definite = true;
            const type = this.tsTryParseTypeAnnotation();
            if (type) {
                decl.id.typeAnnotation = type;
                this.resetEndLocation(decl.id);
            }
        }
        parseAsyncArrowFromCallExpression(node112, call) {
            if (this.match(14)) node112.returnType = this.tsParseTypeAnnotation();
            return super.parseAsyncArrowFromCallExpression(node112, call);
        }
        parseMaybeAssign(...args8) {
            var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;
            let state;
            let jsx;
            let typeCast;
            if (this.hasPlugin("jsx") && (this.match(132) || this.match(43))) {
                state = this.state.clone();
                jsx = this.tryParse(()=>super.parseMaybeAssign(...args8)
                , state);
                if (!jsx.error) return jsx.node;
                const { context  } = this.state;
                if (context[context.length - 1] === types1.j_oTag) context.length -= 2;
                else if (context[context.length - 1] === types1.j_expr) context.length -= 1;
            }
            if (!((_jsx = jsx) != null && _jsx.error) && !this.match(43)) return super.parseMaybeAssign(...args8);
            let typeParameters;
            state = state || this.state.clone();
            const arrow = this.tryParse((abort)=>{
                var _expr$extra, _typeParameters;
                typeParameters = this.tsParseTypeParameters();
                const expr = super.parseMaybeAssign(...args8);
                if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) abort();
                if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) this.resetStartLocationFromNode(expr, typeParameters);
                expr.typeParameters = typeParameters;
                return expr;
            }, state);
            if (!arrow.error && !arrow.aborted) {
                if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
                return arrow.node;
            }
            if (!jsx) {
                assert(!this.hasPlugin("jsx"));
                typeCast = this.tryParse(()=>super.parseMaybeAssign(...args8)
                , state);
                if (!typeCast.error) return typeCast.node;
            }
            if ((_jsx2 = jsx) != null && _jsx2.node) {
                this.state = jsx.failState;
                return jsx.node;
            }
            if (arrow.node) {
                this.state = arrow.failState;
                if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
                return arrow.node;
            }
            if ((_typeCast = typeCast) != null && _typeCast.node) {
                this.state = typeCast.failState;
                return typeCast.node;
            }
            if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
            if (arrow.thrown) throw arrow.error;
            if ((_typeCast2 = typeCast) != null && _typeCast2.thrown) throw typeCast.error;
            throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
        }
        reportReservedArrowTypeParam(node113) {
            var _node$extra;
            if (node113.params.length === 1 && !((_node$extra = node113.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) this.raise(node113.start, TSErrors.ReservedArrowTypeParam);
        }
        parseMaybeUnary(refExpressionErrors5) {
            if (!this.hasPlugin("jsx") && this.match(43)) return this.tsParseTypeAssertion();
            else return super.parseMaybeUnary(refExpressionErrors5);
        }
        parseArrow(node114) {
            if (this.match(14)) {
                const result = this.tryParse((abort)=>{
                    const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
                    if (this.canInsertSemicolon() || !this.match(19)) abort();
                    return returnType;
                });
                if (result.aborted) return;
                if (!result.thrown) {
                    if (result.error) this.state = result.failState;
                    node114.returnType = result.node;
                }
            }
            return super.parseArrow(node114);
        }
        parseAssignableListItemTypes(param) {
            if (this.eat(17)) {
                if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) this.raise(param.start, TSErrors.PatternIsOptional);
                param.optional = true;
            }
            const type = this.tsTryParseTypeAnnotation();
            if (type) param.typeAnnotation = type;
            this.resetEndLocation(param);
            return param;
        }
        isAssignable(node115, isBinding1) {
            switch(node115.type){
                case "TSTypeCastExpression":
                    return this.isAssignable(node115.expression, isBinding1);
                case "TSParameterProperty":
                    return true;
                default:
                    return super.isAssignable(node115, isBinding1);
            }
        }
        toAssignable(node116, isLHS = false) {
            switch(node116.type){
                case "TSTypeCastExpression":
                    return super.toAssignable(this.typeCastToParameter(node116), isLHS);
                case "TSParameterProperty":
                    return super.toAssignable(node116, isLHS);
                case "ParenthesizedExpression":
                    return this.toAssignableParenthesizedExpression(node116, isLHS);
                case "TSAsExpression":
                case "TSNonNullExpression":
                case "TSTypeAssertion":
                    node116.expression = this.toAssignable(node116.expression, isLHS);
                    return node116;
                default:
                    return super.toAssignable(node116, isLHS);
            }
        }
        toAssignableParenthesizedExpression(node117, isLHS2) {
            switch(node117.expression.type){
                case "TSAsExpression":
                case "TSNonNullExpression":
                case "TSTypeAssertion":
                case "ParenthesizedExpression":
                    node117.expression = this.toAssignable(node117.expression, isLHS2);
                    return node117;
                default:
                    return super.toAssignable(node117, isLHS2);
            }
        }
        checkLVal(expr8, contextDescription, ...args9) {
            var _expr$extra2;
            switch(expr8.type){
                case "TSTypeCastExpression":
                    return;
                case "TSParameterProperty":
                    this.checkLVal(expr8.parameter, "parameter property", ...args9);
                    return;
                case "TSAsExpression":
                case "TSTypeAssertion":
                    if (!args9[0] && contextDescription !== "parenthesized expression" && !((_expr$extra2 = expr8.extra) != null && _expr$extra2.parenthesized)) {
                        this.raise(expr8.start, ErrorMessages.InvalidLhs, contextDescription);
                        break;
                    }
                    this.checkLVal(expr8.expression, "parenthesized expression", ...args9);
                    return;
                case "TSNonNullExpression":
                    this.checkLVal(expr8.expression, contextDescription, ...args9);
                    return;
                default:
                    super.checkLVal(expr8, contextDescription, ...args9);
                    return;
            }
        }
        parseBindingAtom() {
            switch(this.state.type){
                case 72:
                    return this.parseIdentifier(true);
                default:
                    return super.parseBindingAtom();
            }
        }
        parseMaybeDecoratorArguments(expr7) {
            if (this.match(43)) {
                const typeArguments = this.tsParseTypeArguments();
                if (this.match(10)) {
                    const call = super.parseMaybeDecoratorArguments(expr7);
                    call.typeParameters = typeArguments;
                    return call;
                }
                this.unexpected(this.state.start, 10);
            }
            return super.parseMaybeDecoratorArguments(expr7);
        }
        checkCommaAfterRest(close) {
            if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) this.next();
            else super.checkCommaAfterRest(close);
        }
        isClassMethod() {
            return this.match(43) || super.isClassMethod();
        }
        isClassProperty() {
            return this.match(33) || this.match(14) || super.isClassProperty();
        }
        parseMaybeDefault(...args10) {
            const node = super.parseMaybeDefault(...args10);
            if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);
            return node;
        }
        getTokenFromCode(code) {
            if (this.state.inType) {
                if (code === 62) return this.finishOp(44, 1);
                if (code === 60) return this.finishOp(43, 1);
            }
            return super.getTokenFromCode(code);
        }
        reScan_lt_gt() {
            const { type  } = this.state;
            if (type === 43) {
                this.state.pos -= 1;
                this.readToken_lt();
            } else if (type === 44) {
                this.state.pos -= 1;
                this.readToken_gt();
            }
        }
        toAssignableList(exprList2) {
            for(let i = 0; i < exprList2.length; i++){
                const expr = exprList2[i];
                if (!expr) continue;
                switch(expr.type){
                    case "TSTypeCastExpression":
                        exprList2[i] = this.typeCastToParameter(expr);
                        break;
                    case "TSAsExpression":
                    case "TSTypeAssertion":
                        if (!this.state.maybeInArrowParameters) exprList2[i] = this.typeCastToParameter(expr);
                        else this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);
                        break;
                }
            }
            return super.toAssignableList(...arguments);
        }
        typeCastToParameter(node118) {
            node118.expression.typeAnnotation = node118.typeAnnotation;
            this.resetEndLocation(node118.expression, node118.typeAnnotation.end, node118.typeAnnotation.loc.end);
            return node118.expression;
        }
        shouldParseArrow(params) {
            if (this.match(14)) return params.every((expr)=>this.isAssignable(expr, true)
            );
            return super.shouldParseArrow(params);
        }
        shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
        }
        canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
        }
        jsxParseOpeningElementAfterName(node119) {
            if (this.match(43)) {
                const typeArguments = this.tsTryParseAndCatch(()=>this.tsParseTypeArguments()
                );
                if (typeArguments) node119.typeParameters = typeArguments;
            }
            return super.jsxParseOpeningElementAfterName(node119);
        }
        getGetterSetterExpectedParamCount(method6) {
            const baseCount = super.getGetterSetterExpectedParamCount(method6);
            const params = this.getObjectOrClassMethodParams(method6);
            const firstParam = params[0];
            const hasContextParam = firstParam && this.isThisParam(firstParam);
            return hasContextParam ? baseCount + 1 : baseCount;
        }
        parseCatchClauseParam() {
            const param = super.parseCatchClauseParam();
            const type = this.tsTryParseTypeAnnotation();
            if (type) {
                param.typeAnnotation = type;
                this.resetEndLocation(param);
            }
            return param;
        }
        tsInAmbientContext(cb3) {
            const oldIsAmbientContext = this.state.isAmbientContext;
            this.state.isAmbientContext = true;
            try {
                return cb3();
            } finally{
                this.state.isAmbientContext = oldIsAmbientContext;
            }
        }
        parseClass(node120, ...args11) {
            const oldInAbstractClass = this.state.inAbstractClass;
            this.state.inAbstractClass = !!node120.abstract;
            try {
                return super.parseClass(node120, ...args11);
            } finally{
                this.state.inAbstractClass = oldInAbstractClass;
            }
        }
        tsParseAbstractDeclaration(node121) {
            if (this.match(74)) {
                node121.abstract = true;
                return this.parseClass(node121, true, false);
            } else if (this.isContextual(119)) {
                if (!this.hasFollowingLineBreak()) {
                    node121.abstract = true;
                    this.raise(node121.start, TSErrors.NonClassMethodPropertyHasAbstractModifer);
                    this.next();
                    return this.tsParseInterfaceDeclaration(node121);
                }
            } else this.unexpected(null, 74);
        }
        parseMethod(...args12) {
            const method = super.parseMethod(...args12);
            if (method.abstract) {
                const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
                if (hasBody) {
                    const { key  } = method;
                    this.raise(method.start, TSErrors.AbstractMethodHasImplementation, key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`);
                }
            }
            return method;
        }
        tsParseTypeParameterName() {
            const typeName = this.parseIdentifier();
            return typeName.name;
        }
        shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
        }
        parse() {
            if (this.shouldParseAsAmbientContext()) this.state.isAmbientContext = true;
            return super.parse();
        }
        getExpression() {
            if (this.shouldParseAsAmbientContext()) this.state.isAmbientContext = true;
            return super.getExpression();
        }
        parseExportSpecifier(node122, isString, isInTypeExport, isMaybeTypeOnly) {
            if (!isString && isMaybeTypeOnly) {
                this.parseTypeOnlyImportExportSpecifier(node122, false, isInTypeExport);
                return this.finishNode(node122, "ExportSpecifier");
            }
            node122.exportKind = "value";
            return super.parseExportSpecifier(node122, isString, isInTypeExport, isMaybeTypeOnly);
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly1) {
            if (!importedIsString && isMaybeTypeOnly1) {
                this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
                return this.finishNode(specifier, "ImportSpecifier");
            }
            specifier.importKind = "value";
            return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly1);
        }
        parseTypeOnlyImportExportSpecifier(node123, isImport, isInTypeOnlyImportExport) {
            const leftOfAsKey = isImport ? "imported" : "local";
            const rightOfAsKey = isImport ? "local" : "exported";
            let leftOfAs = node123[leftOfAsKey];
            let rightOfAs;
            let hasTypeSpecifier = false;
            let canParseAsKeyword = true;
            const pos = leftOfAs.start;
            if (this.isContextual(87)) {
                const firstAs = this.parseIdentifier();
                if (this.isContextual(87)) {
                    const secondAs = this.parseIdentifier();
                    if (tokenIsKeywordOrIdentifier(this.state.type)) {
                        hasTypeSpecifier = true;
                        leftOfAs = firstAs;
                        rightOfAs = this.parseIdentifier();
                        canParseAsKeyword = false;
                    } else {
                        rightOfAs = secondAs;
                        canParseAsKeyword = false;
                    }
                } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                    canParseAsKeyword = false;
                    rightOfAs = this.parseIdentifier();
                } else {
                    hasTypeSpecifier = true;
                    leftOfAs = firstAs;
                }
            } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                hasTypeSpecifier = true;
                leftOfAs = this.parseIdentifier();
            }
            if (hasTypeSpecifier && isInTypeOnlyImportExport) this.raise(pos, isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports);
            node123[leftOfAsKey] = leftOfAs;
            node123[rightOfAsKey] = rightOfAs;
            const kindKey = isImport ? "importKind" : "exportKind";
            node123[kindKey] = hasTypeSpecifier ? "type" : "value";
            if (canParseAsKeyword && this.eatContextual(87)) node123[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
            if (!node123[rightOfAsKey]) node123[rightOfAsKey] = cloneIdentifier(node123[leftOfAsKey]);
            if (isImport) this.checkLVal(node123[rightOfAsKey], "import specifier", BIND_LEXICAL);
        }
    }
;
const PlaceHolderErrors = makeErrorTemplates({
    ClassNameIsRequired: "A class name is required."
}, ErrorCodes.SyntaxError);
var placeholders = (superClass)=>class extends superClass {
        parsePlaceholder(expectedNode) {
            if (this.match(134)) {
                const node = this.startNode();
                this.next();
                this.assertNoSpace("Unexpected space in placeholder.");
                node.name = super.parseIdentifier(true);
                this.assertNoSpace("Unexpected space in placeholder.");
                this.expect(134);
                return this.finishPlaceholder(node, expectedNode);
            }
        }
        finishPlaceholder(node131, expectedNode1) {
            const isFinished = !!(node131.expectedNode && node131.type === "Placeholder");
            node131.expectedNode = expectedNode1;
            return isFinished ? node131 : this.finishNode(node131, "Placeholder");
        }
        getTokenFromCode(code) {
            if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) return this.finishOp(134, 2);
            return super.getTokenFromCode(...arguments);
        }
        parseExprAtom() {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
        }
        parseIdentifier() {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
        }
        checkReservedWord(word) {
            if (word !== undefined) super.checkReservedWord(...arguments);
        }
        parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
        }
        checkLVal(expr) {
            if (expr.type !== "Placeholder") super.checkLVal(...arguments);
        }
        toAssignable(node124) {
            if (node124 && node124.type === "Placeholder" && node124.expectedNode === "Expression") {
                node124.expectedNode = "Pattern";
                return node124;
            }
            return super.toAssignable(...arguments);
        }
        isLet(context) {
            if (super.isLet(context)) return true;
            if (!this.isContextual(93)) return false;
            if (context) return false;
            const nextToken = this.lookahead();
            if (nextToken.type === 134) return true;
            return false;
        }
        verifyBreakContinue(node125) {
            if (node125.label && node125.label.type === "Placeholder") return;
            super.verifyBreakContinue(...arguments);
        }
        parseExpressionStatement(node126, expr9) {
            if (expr9.type !== "Placeholder" || expr9.extra && expr9.extra.parenthesized) return super.parseExpressionStatement(...arguments);
            if (this.match(14)) {
                const stmt = node126;
                stmt.label = this.finishPlaceholder(expr9, "Identifier");
                this.next();
                stmt.body = this.parseStatement("label");
                return this.finishNode(stmt, "LabeledStatement");
            }
            this.semicolon();
            node126.name = expr9.name;
            return this.finishPlaceholder(node126, "Statement");
        }
        parseBlock() {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
        }
        parseFunctionId() {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
        }
        parseClass(node127, isStatement, optionalId) {
            const type = isStatement ? "ClassDeclaration" : "ClassExpression";
            this.next();
            this.takeDecorators(node127);
            const oldStrict = this.state.strict;
            const placeholder = this.parsePlaceholder("Identifier");
            if (placeholder) {
                if (this.match(75) || this.match(134) || this.match(5)) node127.id = placeholder;
                else if (optionalId || !isStatement) {
                    node127.id = null;
                    node127.body = this.finishPlaceholder(placeholder, "ClassBody");
                    return this.finishNode(node127, type);
                } else this.unexpected(null, PlaceHolderErrors.ClassNameIsRequired);
            } else this.parseClassId(node127, isStatement, optionalId);
            this.parseClassSuper(node127);
            node127.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node127.superClass, oldStrict);
            return this.finishNode(node127, type);
        }
        parseExport(node128) {
            const placeholder = this.parsePlaceholder("Identifier");
            if (!placeholder) return super.parseExport(...arguments);
            if (!this.isContextual(91) && !this.match(12)) {
                node128.specifiers = [];
                node128.source = null;
                node128.declaration = this.finishPlaceholder(placeholder, "Declaration");
                return this.finishNode(node128, "ExportNamedDeclaration");
            }
            this.expectPlugin("exportDefaultFrom");
            const specifier = this.startNode();
            specifier.exported = placeholder;
            node128.specifiers = [
                this.finishNode(specifier, "ExportDefaultSpecifier")
            ];
            return super.parseExport(node128);
        }
        isExportDefaultSpecifier() {
            if (this.match(59)) {
                const next = this.nextTokenStart();
                if (this.isUnparsedContextual(next, "from")) {
                    if (this.input.startsWith(tokenLabelName(134), this.nextTokenStartSince(next + 4))) return true;
                }
            }
            return super.isExportDefaultSpecifier();
        }
        maybeParseExportDefaultSpecifier(node129) {
            if (node129.specifiers && node129.specifiers.length > 0) return true;
            return super.maybeParseExportDefaultSpecifier(...arguments);
        }
        checkExport(node130) {
            const { specifiers  } = node130;
            if (specifiers != null && specifiers.length) node130.specifiers = specifiers.filter((node)=>node.exported.type === "Placeholder"
            );
            super.checkExport(node130);
            node130.specifiers = specifiers;
        }
        parseImport(node) {
            const placeholder = this.parsePlaceholder("Identifier");
            if (!placeholder) return super.parseImport(...arguments);
            node.specifiers = [];
            if (!this.isContextual(91) && !this.match(12)) {
                node.source = this.finishPlaceholder(placeholder, "StringLiteral");
                this.semicolon();
                return this.finishNode(node, "ImportDeclaration");
            }
            const specifier = this.startNodeAtNode(placeholder);
            specifier.local = placeholder;
            this.finishNode(specifier, "ImportDefaultSpecifier");
            node.specifiers.push(specifier);
            if (this.eat(12)) {
                const hasStarImport = this.maybeParseStarImportSpecifier(node);
                if (!hasStarImport) this.parseNamedImportSpecifiers(node);
            }
            this.expectContextual(91);
            node.source = this.parseImportSource();
            this.semicolon();
            return this.finishNode(node, "ImportDeclaration");
        }
        parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
        }
    }
;
var v8intrinsic = (superClass)=>class extends superClass {
        parseV8Intrinsic() {
            if (this.match(48)) {
                const v8IntrinsicStart = this.state.start;
                const node = this.startNode();
                this.next();
                if (tokenIsIdentifier(this.state.type)) {
                    const name = this.parseIdentifierName(this.state.start);
                    const identifier = this.createIdentifier(node, name);
                    identifier.type = "V8IntrinsicIdentifier";
                    if (this.match(10)) return identifier;
                }
                this.unexpected(v8IntrinsicStart);
            }
        }
        parseExprAtom() {
            return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
        }
    }
;
function hasPlugin(plugins, name) {
    return plugins.some((plugin)=>{
        if (Array.isArray(plugin)) return plugin[0] === name;
        else return plugin === name;
    });
}
function getPluginOption(plugins, name, option) {
    const plugin2 = plugins.find((plugin)=>{
        if (Array.isArray(plugin)) return plugin[0] === name;
        else return plugin === name;
    });
    if (plugin2 && Array.isArray(plugin2)) return plugin2[1][option];
    return null;
}
const PIPELINE_PROPOSALS = [
    "minimal",
    "fsharp",
    "hack",
    "smart"
];
const TOPIC_TOKENS = [
    "^",
    "%",
    "#"
];
const RECORD_AND_TUPLE_SYNTAX_TYPES = [
    "hash",
    "bar"
];
function validatePlugins(plugins) {
    if (hasPlugin(plugins, "decorators")) {
        if (hasPlugin(plugins, "decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
        if (decoratorsBeforeExport == null) throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
        else if (typeof decoratorsBeforeExport !== "boolean") throw new Error("'decoratorsBeforeExport' must be a boolean.");
    }
    if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) throw new Error("Cannot combine flow and typescript plugins.");
    if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (hasPlugin(plugins, "pipelineOperator")) {
        const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
        if (!PIPELINE_PROPOSALS.includes(proposal)) {
            const proposalList = PIPELINE_PROPOSALS.map((p)=>`"${p}"`
            ).join(", ");
            throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
        }
        const tupleSyntaxIsHash = hasPlugin(plugins, "recordAndTuple") && getPluginOption(plugins, "recordAndTuple", "syntaxType") === "hash";
        if (proposal === "hack") {
            if (hasPlugin(plugins, "placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
            if (hasPlugin(plugins, "v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
            const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
            if (!TOPIC_TOKENS.includes(topicToken)) {
                const tokenList = TOPIC_TOKENS.map((t)=>`"${t}"`
                ).join(", ");
                throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
            }
            if (topicToken === "#" && tupleSyntaxIsHash) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
        } else if (proposal === "smart" && tupleSyntaxIsHash) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
    if (hasPlugin(plugins, "moduleAttributes")) {
        if (hasPlugin(plugins, "importAssertions")) throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
        const moduleAttributesVerionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
        if (moduleAttributesVerionPluginOption !== "may-2020") throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p)=>`'${p}'`
    ).join(", "));
    if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
        const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        error.missingPlugins = "doExpressions";
        throw error;
    }
}
const mixinPlugins = {
    estree,
    jsx: jsx1,
    flow,
    typescript,
    v8intrinsic,
    placeholders
};
const mixinPluginNames = Object.keys(mixinPlugins);
const defaultOptions = {
    sourceType: "script",
    sourceFilename: undefined,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: false,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowSuperOutsideMethod: false,
    allowUndeclaredExports: false,
    plugins: [],
    strictMode: null,
    ranges: false,
    tokens: false,
    createParenthesizedExpressions: false,
    errorRecovery: false,
    attachComment: true
};
function getOptions(opts) {
    const options = {
    };
    for (const key of Object.keys(defaultOptions))options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
    return options;
}
const unwrapParenthesizedExpression = (node)=>{
    return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
};
class LValParser extends NodeUtils {
    toAssignable(node, isLHS = false) {
        var _node$extra, _node$extra3;
        let parenthesized = undefined;
        if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
            parenthesized = unwrapParenthesizedExpression(node);
            if (isLHS) {
                if (parenthesized.type === "Identifier") this.expressionScope.recordParenthesizedIdentifierError(node.start, ErrorMessages.InvalidParenthesizedAssignment);
                else if (parenthesized.type !== "MemberExpression") this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
            } else this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
        }
        switch(node.type){
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
                break;
            case "ObjectExpression":
                node.type = "ObjectPattern";
                for(let i = 0, length = node.properties.length, last = length - 1; i < length; i++){
                    var _node$extra2;
                    const prop = node.properties[i];
                    const isLast = i === last;
                    this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
                    if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingComma) this.raiseRestNotLast(node.extra.trailingComma);
                }
                break;
            case "ObjectProperty":
                this.toAssignable(node.value, isLHS);
                break;
            case "SpreadElement":
                {
                    this.checkToRestConversion(node);
                    node.type = "RestElement";
                    const arg = node.argument;
                    this.toAssignable(arg, isLHS);
                    break;
                }
            case "ArrayExpression":
                node.type = "ArrayPattern";
                this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma, isLHS);
                break;
            case "AssignmentExpression":
                if (node.operator !== "=") this.raise(node.left.end, ErrorMessages.MissingEqInAssignment);
                node.type = "AssignmentPattern";
                delete node.operator;
                this.toAssignable(node.left, isLHS);
                break;
            case "ParenthesizedExpression":
                this.toAssignable(parenthesized, isLHS);
                break;
        }
        return node;
    }
    toAssignableObjectExpressionProp(prop3, isLast, isLHS3) {
        if (prop3.type === "ObjectMethod") {
            const error = prop3.kind === "get" || prop3.kind === "set" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod;
            this.raise(prop3.key.start, error);
        } else if (prop3.type === "SpreadElement" && !isLast) this.raiseRestNotLast(prop3.start);
        else this.toAssignable(prop3, isLHS3);
    }
    toAssignableList(exprList, trailingCommaPos, isLHS4) {
        let end = exprList.length;
        if (end) {
            const last = exprList[end - 1];
            if ((last == null ? void 0 : last.type) === "RestElement") --end;
            else if ((last == null ? void 0 : last.type) === "SpreadElement") {
                last.type = "RestElement";
                let arg = last.argument;
                this.toAssignable(arg, isLHS4);
                arg = unwrapParenthesizedExpression(arg);
                if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") this.unexpected(arg.start);
                if (trailingCommaPos) this.raiseTrailingCommaAfterRest(trailingCommaPos);
                --end;
            }
        }
        for(let i = 0; i < end; i++){
            const elt = exprList[i];
            if (elt) {
                this.toAssignable(elt, isLHS4);
                if (elt.type === "RestElement") this.raiseRestNotLast(elt.start);
            }
        }
        return exprList;
    }
    isAssignable(node132, isBinding) {
        switch(node132.type){
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
                return true;
            case "ObjectExpression":
                {
                    const last = node132.properties.length - 1;
                    return node132.properties.every((prop, i)=>{
                        return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
                    });
                }
            case "ObjectProperty":
                return this.isAssignable(node132.value);
            case "SpreadElement":
                return this.isAssignable(node132.argument);
            case "ArrayExpression":
                return node132.elements.every((element)=>element === null || this.isAssignable(element)
                );
            case "AssignmentExpression":
                return node132.operator === "=";
            case "ParenthesizedExpression":
                return this.isAssignable(node132.expression);
            case "MemberExpression":
            case "OptionalMemberExpression":
                return !isBinding;
            default:
                return false;
        }
    }
    toReferencedList(exprList3, isParenthesizedExpr) {
        return exprList3;
    }
    toReferencedListDeep(exprList4, isParenthesizedExpr1) {
        this.toReferencedList(exprList4, isParenthesizedExpr1);
        for (const expr of exprList4)if ((expr == null ? void 0 : expr.type) === "ArrayExpression") this.toReferencedListDeep(expr.elements);
    }
    parseSpread(refExpressionErrors, refNeedsArrowPos) {
        const node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined, refNeedsArrowPos);
        return this.finishNode(node, "SpreadElement");
    }
    parseRestBinding() {
        const node = this.startNode();
        this.next();
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
    }
    parseBindingAtom() {
        switch(this.state.type){
            case 0:
                {
                    const node = this.startNode();
                    this.next();
                    node.elements = this.parseBindingList(3, 93, true);
                    return this.finishNode(node, "ArrayPattern");
                }
            case 5:
                return this.parseObjectLike(8, true);
        }
        return this.parseIdentifier();
    }
    parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
        const elts = [];
        let first = true;
        while(!this.eat(close)){
            if (first) first = false;
            else this.expect(12);
            if (allowEmpty && this.match(12)) elts.push(null);
            else if (this.eat(close)) break;
            else if (this.match(21)) {
                elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
                this.checkCommaAfterRest(closeCharCode);
                this.expect(close);
                break;
            } else {
                const decorators = [];
                if (this.match(24) && this.hasPlugin("decorators")) this.raise(this.state.start, ErrorMessages.UnsupportedParameterDecorator);
                while(this.match(24))decorators.push(this.parseDecorator());
                elts.push(this.parseAssignableListItem(allowModifiers, decorators));
            }
        }
        return elts;
    }
    parseAssignableListItem(allowModifiers2, decorators) {
        const left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left);
        const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
        if (decorators.length) left.decorators = decorators;
        return elt;
    }
    parseAssignableListItemTypes(param) {
        return param;
    }
    parseMaybeDefault(startPos, startLoc, left) {
        var _startLoc, _startPos, _left;
        startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
        startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
        left = (_left = left) != null ? _left : this.parseBindingAtom();
        if (!this.eat(27)) return left;
        const node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssignAllowIn();
        return this.finishNode(node, "AssignmentPattern");
    }
    checkLVal(expr, contextDescription, bindingType7 = BIND_NONE, checkClashes, disallowLetBinding, strictModeChanged1 = false) {
        switch(expr.type){
            case "Identifier":
                {
                    const { name  } = expr;
                    if (this.state.strict && (strictModeChanged1 ? isStrictBindReservedWord(name, this.inModule) : isStrictBindOnlyReservedWord(name))) this.raise(expr.start, bindingType7 === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, name);
                    if (checkClashes) {
                        if (checkClashes.has(name)) this.raise(expr.start, ErrorMessages.ParamDupe);
                        else checkClashes.add(name);
                    }
                    if (disallowLetBinding && name === "let") this.raise(expr.start, ErrorMessages.LetInLexicalBinding);
                    if (!(bindingType7 & BIND_NONE)) this.scope.declareName(name, bindingType7, expr.start);
                    break;
                }
            case "MemberExpression":
                if (bindingType7 !== BIND_NONE) this.raise(expr.start, ErrorMessages.InvalidPropertyBindingPattern);
                break;
            case "ObjectPattern":
                for (let prop of expr.properties){
                    if (this.isObjectProperty(prop)) prop = prop.value;
                    else if (this.isObjectMethod(prop)) continue;
                    this.checkLVal(prop, "object destructuring pattern", bindingType7, checkClashes, disallowLetBinding);
                }
                break;
            case "ArrayPattern":
                for (const elem of expr.elements)if (elem) this.checkLVal(elem, "array destructuring pattern", bindingType7, checkClashes, disallowLetBinding);
                break;
            case "AssignmentPattern":
                this.checkLVal(expr.left, "assignment pattern", bindingType7, checkClashes);
                break;
            case "RestElement":
                this.checkLVal(expr.argument, "rest element", bindingType7, checkClashes);
                break;
            case "ParenthesizedExpression":
                this.checkLVal(expr.expression, "parenthesized expression", bindingType7, checkClashes);
                break;
            default:
                this.raise(expr.start, bindingType7 === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, contextDescription);
        }
    }
    checkToRestConversion(node133) {
        if (node133.argument.type !== "Identifier" && node133.argument.type !== "MemberExpression") this.raise(node133.argument.start, ErrorMessages.InvalidRestAssignmentPattern);
    }
    checkCommaAfterRest(close1) {
        if (this.match(12)) {
            if (this.lookaheadCharCode() === close1) this.raiseTrailingCommaAfterRest(this.state.start);
            else this.raiseRestNotLast(this.state.start);
        }
    }
    raiseRestNotLast(pos) {
        throw this.raise(pos, ErrorMessages.ElementAfterRest);
    }
    raiseTrailingCommaAfterRest(pos34) {
        this.raise(pos34, ErrorMessages.RestTrailingComma);
    }
}
const invalidHackPipeBodies = new Map([
    [
        "ArrowFunctionExpression",
        "arrow function"
    ],
    [
        "AssignmentExpression",
        "assignment"
    ],
    [
        "ConditionalExpression",
        "conditional"
    ],
    [
        "YieldExpression",
        "yield"
    ]
]);
class ExpressionParser extends LValParser {
    checkProto(prop, isRecord, protoRef, refExpressionErrors6) {
        if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) return;
        const key = prop.key;
        const name = key.type === "Identifier" ? key.name : key.value;
        if (name === "__proto__") {
            if (isRecord) {
                this.raise(key.start, ErrorMessages.RecordNoProto);
                return;
            }
            if (protoRef.used) {
                if (refExpressionErrors6) {
                    if (refExpressionErrors6.doubleProto === -1) refExpressionErrors6.doubleProto = key.start;
                } else this.raise(key.start, ErrorMessages.DuplicateProto);
            }
            protoRef.used = true;
        }
    }
    shouldExitDescending(expr10, potentialArrowAt) {
        return expr10.type === "ArrowFunctionExpression" && expr10.start === potentialArrowAt;
    }
    getExpression() {
        this.enterInitialScopes();
        this.nextToken();
        const expr = this.parseExpression();
        if (!this.match(129)) this.unexpected();
        this.finalizeRemainingComments();
        expr.comments = this.state.comments;
        expr.errors = this.state.errors;
        if (this.options.tokens) expr.tokens = this.tokens;
        return expr;
    }
    parseExpression(disallowIn, refExpressionErrors7) {
        if (disallowIn) return this.disallowInAnd(()=>this.parseExpressionBase(refExpressionErrors7)
        );
        return this.allowInAnd(()=>this.parseExpressionBase(refExpressionErrors7)
        );
    }
    parseExpressionBase(refExpressionErrors8) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const expr = this.parseMaybeAssign(refExpressionErrors8);
        if (this.match(12)) {
            const node = this.startNodeAt(startPos, startLoc);
            node.expressions = [
                expr
            ];
            while(this.eat(12))node.expressions.push(this.parseMaybeAssign(refExpressionErrors8));
            this.toReferencedList(node.expressions);
            return this.finishNode(node, "SequenceExpression");
        }
        return expr;
    }
    parseMaybeAssignDisallowIn(refExpressionErrors9, afterLeftParse) {
        return this.disallowInAnd(()=>this.parseMaybeAssign(refExpressionErrors9, afterLeftParse)
        );
    }
    parseMaybeAssignAllowIn(refExpressionErrors10, afterLeftParse1) {
        return this.allowInAnd(()=>this.parseMaybeAssign(refExpressionErrors10, afterLeftParse1)
        );
    }
    setOptionalParametersError(refExpressionErrors11, resultError) {
        var _resultError$pos;
        refExpressionErrors11.optionalParameters = (_resultError$pos = resultError == null ? void 0 : resultError.pos) != null ? _resultError$pos : this.state.start;
    }
    parseMaybeAssign(refExpressionErrors12, afterLeftParse2) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        if (this.isContextual(99)) {
            if (this.prodParam.hasYield) {
                let left = this.parseYield();
                if (afterLeftParse2) left = afterLeftParse2.call(this, left, startPos, startLoc);
                return left;
            }
        }
        let ownExpressionErrors;
        if (refExpressionErrors12) ownExpressionErrors = false;
        else {
            refExpressionErrors12 = new ExpressionErrors();
            ownExpressionErrors = true;
        }
        const { type  } = this.state;
        if (type === 10 || tokenIsIdentifier(type)) this.state.potentialArrowAt = this.state.start;
        let left = this.parseMaybeConditional(refExpressionErrors12);
        if (afterLeftParse2) left = afterLeftParse2.call(this, left, startPos, startLoc);
        if (tokenIsAssignment(this.state.type)) {
            const node = this.startNodeAt(startPos, startLoc);
            const operator = this.state.value;
            node.operator = operator;
            if (this.match(27)) {
                node.left = this.toAssignable(left, true);
                refExpressionErrors12.doubleProto = -1;
            } else node.left = left;
            if (refExpressionErrors12.shorthandAssign >= node.left.start) refExpressionErrors12.shorthandAssign = -1;
            this.checkLVal(left, "assignment expression");
            this.next();
            node.right = this.parseMaybeAssign();
            return this.finishNode(node, "AssignmentExpression");
        } else if (ownExpressionErrors) this.checkExpressionErrors(refExpressionErrors12, true);
        return left;
    }
    parseMaybeConditional(refExpressionErrors13) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprOps(refExpressionErrors13);
        if (this.shouldExitDescending(expr, potentialArrowAt)) return expr;
        return this.parseConditional(expr, startPos, startLoc, refExpressionErrors13);
    }
    parseConditional(expr11, startPos16, startLoc19, refExpressionErrors14) {
        if (this.eat(17)) {
            const node = this.startNodeAt(startPos16, startLoc19);
            node.test = expr11;
            node.consequent = this.parseMaybeAssignAllowIn();
            this.expect(14);
            node.alternate = this.parseMaybeAssign();
            return this.finishNode(node, "ConditionalExpression");
        }
        return expr11;
    }
    parseMaybeUnaryOrPrivate(refExpressionErrors15) {
        return this.match(128) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors15);
    }
    parseExprOps(refExpressionErrors16) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors16);
        if (this.shouldExitDescending(expr, potentialArrowAt)) return expr;
        return this.parseExprOp(expr, startPos, startLoc, -1);
    }
    parseExprOp(left1, leftStartPos, leftStartLoc, minPrec) {
        if (this.isPrivateName(left1)) {
            const value = this.getPrivateNameSV(left1);
            const { start  } = left1;
            if (minPrec >= tokenOperatorPrecedence(52) || !this.prodParam.hasIn || !this.match(52)) this.raise(start, ErrorMessages.PrivateInExpectedIn, value);
            this.classScope.usePrivateName(value, start);
        }
        const op = this.state.type;
        if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(52))) {
            let prec = tokenOperatorPrecedence(op);
            if (prec > minPrec) {
                if (op === 35) {
                    this.expectPlugin("pipelineOperator");
                    if (this.state.inFSharpPipelineDirectBody) return left1;
                    this.checkPipelineAtInfixOperator(left1, leftStartPos);
                }
                const node = this.startNodeAt(leftStartPos, leftStartLoc);
                node.left = left1;
                node.operator = this.state.value;
                const logical = op === 37 || op === 38;
                const coalesce = op === 36;
                if (coalesce) prec = tokenOperatorPrecedence(38);
                this.next();
                if (op === 35 && this.getPluginOption("pipelineOperator", "proposal") === "minimal") {
                    if (this.state.type === 90 && this.prodParam.hasAwait) throw this.raise(this.state.start, ErrorMessages.UnexpectedAwaitAfterPipelineBody);
                }
                node.right = this.parseExprOpRightExpr(op, prec);
                this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
                const nextOp = this.state.type;
                if (coalesce && (nextOp === 37 || nextOp === 38) || logical && nextOp === 36) throw this.raise(this.state.start, ErrorMessages.MixingCoalesceWithLogical);
                return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
            }
        }
        return left1;
    }
    parseExprOpRightExpr(op, prec) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        switch(op){
            case 35:
                switch(this.getPluginOption("pipelineOperator", "proposal")){
                    case "hack":
                        return this.withTopicBindingContext(()=>{
                            return this.parseHackPipeBody();
                        });
                    case "smart":
                        return this.withTopicBindingContext(()=>{
                            if (this.prodParam.hasYield && this.isContextual(99)) throw this.raise(this.state.start, ErrorMessages.PipeBodyIsTighter, this.state.value);
                            return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);
                        });
                    case "fsharp":
                        return this.withSoloAwaitPermittingContext(()=>{
                            return this.parseFSharpPipelineBody(prec);
                        });
                }
            default:
                return this.parseExprOpBaseRightExpr(op, prec);
        }
    }
    parseExprOpBaseRightExpr(op1, prec1) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, tokenIsRightAssociative(op1) ? prec1 - 1 : prec1);
    }
    parseHackPipeBody() {
        var _body$extra;
        const { start  } = this.state;
        const body = this.parseMaybeAssign();
        if (invalidHackPipeBodies.has(body.type) && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) this.raise(start, ErrorMessages.PipeUnparenthesizedBody, invalidHackPipeBodies.get(body.type));
        if (!this.topicReferenceWasUsedInCurrentContext()) this.raise(start, ErrorMessages.PipeTopicUnused);
        return body;
    }
    checkExponentialAfterUnary(node134) {
        if (this.match(51)) this.raise(node134.argument.start, ErrorMessages.UnexpectedTokenUnaryExponentiation);
    }
    parseMaybeUnary(refExpressionErrors17, sawUnary) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const isAwait = this.isContextual(90);
        if (isAwait && this.isAwaitAllowed()) {
            this.next();
            const expr = this.parseAwait(startPos, startLoc);
            if (!sawUnary) this.checkExponentialAfterUnary(expr);
            return expr;
        }
        const update = this.match(32);
        const node = this.startNode();
        if (tokenIsPrefix(this.state.type)) {
            node.operator = this.state.value;
            node.prefix = true;
            if (this.match(66)) this.expectPlugin("throwExpressions");
            const isDelete = this.match(83);
            this.next();
            node.argument = this.parseMaybeUnary(null, true);
            this.checkExpressionErrors(refExpressionErrors17, true);
            if (this.state.strict && isDelete) {
                const arg = node.argument;
                if (arg.type === "Identifier") this.raise(node.start, ErrorMessages.StrictDelete);
                else if (this.hasPropertyAsPrivateName(arg)) this.raise(node.start, ErrorMessages.DeletePrivateField);
            }
            if (!update) {
                if (!sawUnary) this.checkExponentialAfterUnary(node);
                return this.finishNode(node, "UnaryExpression");
            }
        }
        const expr = this.parseUpdate(node, update, refExpressionErrors17);
        if (isAwait) {
            const { type  } = this.state;
            const startsExpr = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(48);
            if (startsExpr && !this.isAmbiguousAwait()) {
                this.raiseOverwrite(startPos, ErrorMessages.AwaitNotInAsyncContext);
                return this.parseAwait(startPos, startLoc);
            }
        }
        return expr;
    }
    parseUpdate(node135, update, refExpressionErrors18) {
        if (update) {
            this.checkLVal(node135.argument, "prefix operation");
            return this.finishNode(node135, "UpdateExpression");
        }
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let expr = this.parseExprSubscripts(refExpressionErrors18);
        if (this.checkExpressionErrors(refExpressionErrors18, false)) return expr;
        while(tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()){
            const node = this.startNodeAt(startPos, startLoc);
            node.operator = this.state.value;
            node.prefix = false;
            node.argument = expr;
            this.checkLVal(expr, "postfix operation");
            this.next();
            expr = this.finishNode(node, "UpdateExpression");
        }
        return expr;
    }
    parseExprSubscripts(refExpressionErrors19) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprAtom(refExpressionErrors19);
        if (this.shouldExitDescending(expr, potentialArrowAt)) return expr;
        return this.parseSubscripts(expr, startPos, startLoc);
    }
    parseSubscripts(base, startPos17, startLoc20, noCalls) {
        const state = {
            optionalChainMember: false,
            maybeAsyncArrow: this.atPossibleAsyncArrow(base),
            stop: false
        };
        do {
            base = this.parseSubscript(base, startPos17, startLoc20, noCalls, state);
            state.maybeAsyncArrow = false;
        }while (!state.stop)
        return base;
    }
    parseSubscript(base2, startPos18, startLoc21, noCalls2, state) {
        if (!noCalls2 && this.eat(15)) return this.parseBind(base2, startPos18, startLoc21, noCalls2, state);
        else if (this.match(22)) return this.parseTaggedTemplateExpression(base2, startPos18, startLoc21, state);
        let optional = false;
        if (this.match(18)) {
            if (noCalls2 && this.lookaheadCharCode() === 40) {
                state.stop = true;
                return base2;
            }
            state.optionalChainMember = optional = true;
            this.next();
        }
        if (!noCalls2 && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(base2, startPos18, startLoc21, state, optional);
        else {
            const computed = this.eat(0);
            if (computed || optional || this.eat(16)) return this.parseMember(base2, startPos18, startLoc21, state, computed, optional);
            else {
                state.stop = true;
                return base2;
            }
        }
    }
    parseMember(base3, startPos19, startLoc22, state5, computed, optional) {
        const node = this.startNodeAt(startPos19, startLoc22);
        node.object = base3;
        node.computed = computed;
        const privateName = !computed && this.match(128) && this.state.value;
        const property = computed ? this.parseExpression() : privateName ? this.parsePrivateName() : this.parseIdentifier(true);
        if (privateName !== false) {
            if (node.object.type === "Super") this.raise(startPos19, ErrorMessages.SuperPrivateField);
            this.classScope.usePrivateName(privateName, property.start);
        }
        node.property = property;
        if (computed) this.expect(3);
        if (state5.optionalChainMember) {
            node.optional = optional;
            return this.finishNode(node, "OptionalMemberExpression");
        } else return this.finishNode(node, "MemberExpression");
    }
    parseBind(base4, startPos20, startLoc23, noCalls3, state6) {
        const node = this.startNodeAt(startPos20, startLoc23);
        node.object = base4;
        node.callee = this.parseNoCallExpr();
        state6.stop = true;
        return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos20, startLoc23, noCalls3);
    }
    parseCoverCallAndAsyncArrowHead(base5, startPos21, startLoc24, state7, optional1) {
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        let refExpressionErrors = null;
        this.state.maybeInArrowParameters = true;
        this.next();
        let node = this.startNodeAt(startPos21, startLoc24);
        node.callee = base5;
        if (state7.maybeAsyncArrow) {
            this.expressionScope.enter(newAsyncArrowScope());
            refExpressionErrors = new ExpressionErrors();
        }
        if (state7.optionalChainMember) node.optional = optional1;
        if (optional1) node.arguments = this.parseCallExpressionArguments(11);
        else node.arguments = this.parseCallExpressionArguments(11, base5.type === "Import", base5.type !== "Super", node, refExpressionErrors);
        this.finishCallExpression(node, state7.optionalChainMember);
        if (state7.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional1) {
            state7.stop = true;
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos21, startLoc24), node);
        } else {
            if (state7.maybeAsyncArrow) {
                this.checkExpressionErrors(refExpressionErrors, true);
                this.expressionScope.exit();
            }
            this.toReferencedArguments(node);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return node;
    }
    toReferencedArguments(node136, isParenthesizedExpr2) {
        this.toReferencedListDeep(node136.arguments, isParenthesizedExpr2);
    }
    parseTaggedTemplateExpression(base6, startPos22, startLoc25, state8) {
        const node = this.startNodeAt(startPos22, startLoc25);
        node.tag = base6;
        node.quasi = this.parseTemplate(true);
        if (state8.optionalChainMember) this.raise(startPos22, ErrorMessages.OptionalChainingNoTemplate);
        return this.finishNode(node, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(base7) {
        return base7.type === "Identifier" && base7.name === "async" && this.state.lastTokEnd === base7.end && !this.canInsertSemicolon() && base7.end - base7.start === 5 && base7.start === this.state.potentialArrowAt;
    }
    finishCallExpression(node137, optional2) {
        if (node137.callee.type === "Import") {
            if (node137.arguments.length === 2) {
                if (!this.hasPlugin("moduleAttributes")) this.expectPlugin("importAssertions");
            }
            if (node137.arguments.length === 0 || node137.arguments.length > 2) this.raise(node137.start, ErrorMessages.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
            else {
                for (const arg of node137.arguments)if (arg.type === "SpreadElement") this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);
            }
        }
        return this.finishNode(node137, optional2 ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(close2, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors20) {
        const elts = [];
        let first = true;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        while(!this.eat(close2)){
            if (first) first = false;
            else {
                this.expect(12);
                if (this.match(close2)) {
                    if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) this.raise(this.state.lastTokStart, ErrorMessages.ImportCallArgumentTrailingComma);
                    if (nodeForExtra) this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
                    this.next();
                    break;
                }
            }
            elts.push(this.parseExprListItem(false, refExpressionErrors20, allowPlaceholder));
        }
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return elts;
    }
    shouldParseAsyncArrow() {
        return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(node138, call) {
        var _call$extra;
        this.resetPreviousNodeTrailingComments(call);
        this.expect(19);
        this.parseArrowExpression(node138, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);
        if (call.innerComments) setInnerComments(node138, call.innerComments);
        if (call.callee.trailingComments) setInnerComments(node138, call.callee.trailingComments);
        return node138;
    }
    parseNoCallExpr() {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    }
    parseExprAtom(refExpressionErrors21) {
        let node;
        const { type  } = this.state;
        switch(type){
            case 73:
                return this.parseSuper();
            case 77:
                node = this.startNode();
                this.next();
                if (this.match(16)) return this.parseImportMetaProperty(node);
                if (!this.match(10)) this.raise(this.state.lastTokStart, ErrorMessages.UnsupportedImport);
                return this.finishNode(node, "Import");
            case 72:
                node = this.startNode();
                this.next();
                return this.finishNode(node, "ThisExpression");
            case 84:
                return this.parseDo(this.startNode(), false);
            case 50:
            case 29:
                this.readRegexp();
                return this.parseRegExpLiteral(this.state.value);
            case 124:
                return this.parseNumericLiteral(this.state.value);
            case 125:
                return this.parseBigIntLiteral(this.state.value);
            case 126:
                return this.parseDecimalLiteral(this.state.value);
            case 123:
                return this.parseStringLiteral(this.state.value);
            case 78:
                return this.parseNullLiteral();
            case 79:
                return this.parseBooleanLiteral(true);
            case 80:
                return this.parseBooleanLiteral(false);
            case 10:
                {
                    const canBeArrow = this.state.potentialArrowAt === this.state.start;
                    return this.parseParenAndDistinguishExpression(canBeArrow);
                }
            case 2:
            case 1:
                return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true, refExpressionErrors21);
            case 0:
                return this.parseArrayLike(3, true, false, refExpressionErrors21);
            case 6:
            case 7:
                return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true, refExpressionErrors21);
            case 5:
                return this.parseObjectLike(8, false, false, refExpressionErrors21);
            case 62:
                return this.parseFunctionOrFunctionSent();
            case 24:
                this.parseDecorators();
            case 74:
                node = this.startNode();
                this.takeDecorators(node);
                return this.parseClass(node, false);
            case 71:
                return this.parseNewOrNewTarget();
            case 22:
                return this.parseTemplate(false);
            case 15:
                {
                    node = this.startNode();
                    this.next();
                    node.object = null;
                    const callee = node.callee = this.parseNoCallExpr();
                    if (callee.type === "MemberExpression") return this.finishNode(node, "BindExpression");
                    else throw this.raise(callee.start, ErrorMessages.UnsupportedBind);
                }
            case 128:
                this.raise(this.state.start, ErrorMessages.PrivateInExpectedIn, this.state.value);
                return this.parsePrivateName();
            case 31:
                return this.parseTopicReferenceThenEqualsSign(48, "%");
            case 30:
                return this.parseTopicReferenceThenEqualsSign(40, "^");
            case 40:
            case 48:
            case 25:
                {
                    const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
                    if (pipeProposal) return this.parseTopicReference(pipeProposal);
                    else throw this.unexpected();
                }
            case 43:
                {
                    const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
                    if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
                        this.expectOnePlugin([
                            "jsx",
                            "flow",
                            "typescript"
                        ]);
                        break;
                    } else throw this.unexpected();
                }
            default:
                if (tokenIsIdentifier(type)) {
                    if (this.isContextual(117) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) return this.parseModuleExpression();
                    const canBeArrow = this.state.potentialArrowAt === this.state.start;
                    const containsEsc = this.state.containsEsc;
                    const id = this.parseIdentifier();
                    if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                        const { type  } = this.state;
                        if (type === 62) {
                            this.resetPreviousNodeTrailingComments(id);
                            this.next();
                            return this.parseFunction(this.startNodeAtNode(id), undefined, true);
                        } else if (tokenIsIdentifier(type)) {
                            if (this.lookaheadCharCode() === 61) return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                            else return id;
                        } else if (type === 84) {
                            this.resetPreviousNodeTrailingComments(id);
                            return this.parseDo(this.startNodeAtNode(id), true);
                        }
                    }
                    if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                        this.next();
                        return this.parseArrowExpression(this.startNodeAtNode(id), [
                            id
                        ], false);
                    }
                    return id;
                } else throw this.unexpected();
        }
    }
    parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
        const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
        if (pipeProposal) {
            this.state.type = topicTokenType;
            this.state.value = topicTokenValue;
            this.state.pos--;
            this.state.end--;
            this.state.endLoc.column--;
            return this.parseTopicReference(pipeProposal);
        } else throw this.unexpected();
    }
    parseTopicReference(pipeProposal) {
        const node = this.startNode();
        const start = this.state.start;
        const tokenType = this.state.type;
        this.next();
        return this.finishTopicReference(node, start, pipeProposal, tokenType);
    }
    finishTopicReference(node139, start5, pipeProposal1, tokenType) {
        if (this.testTopicReferenceConfiguration(pipeProposal1, start5, tokenType)) {
            let nodeType;
            if (pipeProposal1 === "smart") nodeType = "PipelinePrimaryTopicReference";
            else nodeType = "TopicReference";
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
                if (pipeProposal1 === "smart") this.raise(start5, ErrorMessages.PrimaryTopicNotAllowed);
                else this.raise(start5, ErrorMessages.PipeTopicUnbound);
            }
            this.registerTopicReference();
            return this.finishNode(node139, nodeType);
        } else throw this.raise(start5, ErrorMessages.PipeTopicUnconfiguredToken, tokenLabelName(tokenType));
    }
    testTopicReferenceConfiguration(pipeProposal2, start4, tokenType1) {
        switch(pipeProposal2){
            case "hack":
                {
                    const pluginTopicToken = this.getPluginOption("pipelineOperator", "topicToken");
                    return tokenLabelName(tokenType1) === pluginTopicToken;
                }
            case "smart":
                return tokenType1 === 25;
            default:
                throw this.raise(start4, ErrorMessages.PipeTopicRequiresHackPipes);
        }
    }
    parseAsyncArrowUnaryFunction(node140) {
        this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
        const params = [
            this.parseIdentifier()
        ];
        this.prodParam.exit();
        if (this.hasPrecedingLineBreak()) this.raise(this.state.pos, ErrorMessages.LineTerminatorBeforeArrow);
        this.expect(19);
        this.parseArrowExpression(node140, params, true);
        return node140;
    }
    parseDo(node141, isAsync) {
        this.expectPlugin("doExpressions");
        if (isAsync) this.expectPlugin("asyncDoExpressions");
        node141.async = isAsync;
        this.next();
        const oldLabels = this.state.labels;
        this.state.labels = [];
        if (isAsync) {
            this.prodParam.enter(PARAM_AWAIT);
            node141.body = this.parseBlock();
            this.prodParam.exit();
        } else node141.body = this.parseBlock();
        this.state.labels = oldLabels;
        return this.finishNode(node141, "DoExpression");
    }
    parseSuper() {
        const node = this.startNode();
        this.next();
        if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) this.raise(node.start, ErrorMessages.SuperNotAllowed);
        else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) this.raise(node.start, ErrorMessages.UnexpectedSuper);
        if (!this.match(10) && !this.match(0) && !this.match(16)) this.raise(node.start, ErrorMessages.UnsupportedSuper);
        return this.finishNode(node, "Super");
    }
    parseMaybePrivateName(isPrivateNameAllowed) {
        const isPrivate = this.match(128);
        if (isPrivate) {
            if (!isPrivateNameAllowed) this.raise(this.state.start + 1, ErrorMessages.UnexpectedPrivateField);
            return this.parsePrivateName();
        } else return this.parseIdentifier(true);
    }
    parsePrivateName() {
        const node = this.startNode();
        const id = this.startNodeAt(this.state.start + 1, new Position(this.state.curLine, this.state.start + 1 - this.state.lineStart));
        const name = this.state.value;
        this.next();
        node.id = this.createIdentifier(id, name);
        return this.finishNode(node, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
        const node = this.startNode();
        this.next();
        if (this.prodParam.hasYield && this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
            this.next();
            if (this.match(96)) this.expectPlugin("functionSent");
            else if (!this.hasPlugin("functionSent")) this.unexpected();
            return this.parseMetaProperty(node, meta, "sent");
        }
        return this.parseFunction(node);
    }
    parseMetaProperty(node142, meta, propertyName) {
        node142.meta = meta;
        const containsEsc = this.state.containsEsc;
        node142.property = this.parseIdentifier(true);
        if (node142.property.name !== propertyName || containsEsc) this.raise(node142.property.start, ErrorMessages.UnsupportedMetaProperty, meta.name, propertyName);
        return this.finishNode(node142, "MetaProperty");
    }
    parseImportMetaProperty(node143) {
        const id = this.createIdentifier(this.startNodeAtNode(node143), "import");
        this.next();
        if (this.isContextual(94)) {
            if (!this.inModule) this.raise(id.start, SourceTypeModuleErrorMessages.ImportMetaOutsideModule);
            this.sawUnambiguousESM = true;
        }
        return this.parseMetaProperty(node143, id, "meta");
    }
    parseLiteralAtNode(value14, type20, node144) {
        this.addExtra(node144, "rawValue", value14);
        this.addExtra(node144, "raw", this.input.slice(node144.start, this.state.end));
        node144.value = value14;
        this.next();
        return this.finishNode(node144, type20);
    }
    parseLiteral(value7, type17) {
        const node = this.startNode();
        return this.parseLiteralAtNode(value7, type17, node);
    }
    parseStringLiteral(value8) {
        return this.parseLiteral(value8, "StringLiteral");
    }
    parseNumericLiteral(value9) {
        return this.parseLiteral(value9, "NumericLiteral");
    }
    parseBigIntLiteral(value10) {
        return this.parseLiteral(value10, "BigIntLiteral");
    }
    parseDecimalLiteral(value11) {
        return this.parseLiteral(value11, "DecimalLiteral");
    }
    parseRegExpLiteral(value12) {
        const node = this.parseLiteral(value12.value, "RegExpLiteral");
        node.pattern = value12.pattern;
        node.flags = value12.flags;
        return node;
    }
    parseBooleanLiteral(value13) {
        const node = this.startNode();
        node.value = value13;
        this.next();
        return this.finishNode(node, "BooleanLiteral");
    }
    parseNullLiteral() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "NullLiteral");
    }
    parseParenAndDistinguishExpression(canBeArrow) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let val;
        this.next();
        this.expressionScope.enter(newArrowHeadScope());
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.maybeInArrowParameters = true;
        this.state.inFSharpPipelineDirectBody = false;
        const innerStartPos = this.state.start;
        const innerStartLoc = this.state.startLoc;
        const exprList = [];
        const refExpressionErrors = new ExpressionErrors();
        let first = true;
        let spreadStart;
        let optionalCommaStart;
        while(!this.match(11)){
            if (first) first = false;
            else {
                this.expect(12, refExpressionErrors.optionalParameters === -1 ? null : refExpressionErrors.optionalParameters);
                if (this.match(11)) {
                    optionalCommaStart = this.state.start;
                    break;
                }
            }
            if (this.match(21)) {
                const spreadNodeStartPos = this.state.start;
                const spreadNodeStartLoc = this.state.startLoc;
                spreadStart = this.state.start;
                exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
                this.checkCommaAfterRest(41);
                break;
            } else exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
        }
        const innerEndPos = this.state.lastTokEnd;
        const innerEndLoc = this.state.lastTokEndLoc;
        this.expect(11);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let arrowNode = this.startNodeAt(startPos, startLoc);
        if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            this.parseArrowExpression(arrowNode, exprList, false);
            return arrowNode;
        }
        this.expressionScope.exit();
        if (!exprList.length) this.unexpected(this.state.lastTokStart);
        if (optionalCommaStart) this.unexpected(optionalCommaStart);
        if (spreadStart) this.unexpected(spreadStart);
        this.checkExpressionErrors(refExpressionErrors, true);
        this.toReferencedListDeep(exprList, true);
        if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNode(val, "SequenceExpression");
            this.resetEndLocation(val, innerEndPos, innerEndLoc);
        } else val = exprList[0];
        if (!this.options.createParenthesizedExpressions) {
            this.addExtra(val, "parenthesized", true);
            this.addExtra(val, "parenStart", startPos);
            this.takeSurroundingComments(val, startPos, this.state.lastTokEnd);
            return val;
        }
        const parenExpression = this.startNodeAt(startPos, startLoc);
        parenExpression.expression = val;
        this.finishNode(parenExpression, "ParenthesizedExpression");
        return parenExpression;
    }
    shouldParseArrow(params) {
        return !this.canInsertSemicolon();
    }
    parseArrow(node145) {
        if (this.eat(19)) return node145;
    }
    parseParenItem(node146, startPos23, startLoc26) {
        return node146;
    }
    parseNewOrNewTarget() {
        const node = this.startNode();
        this.next();
        if (this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
            this.next();
            const metaProp = this.parseMetaProperty(node, meta, "target");
            if (!this.scope.inNonArrowFunction && !this.scope.inClass) this.raise(metaProp.start, ErrorMessages.UnexpectedNewTarget);
            return metaProp;
        }
        return this.parseNew(node);
    }
    parseNew(node147) {
        node147.callee = this.parseNoCallExpr();
        if (node147.callee.type === "Import") this.raise(node147.callee.start, ErrorMessages.ImportCallNotNewExpression);
        else if (this.isOptionalChain(node147.callee)) this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew);
        else if (this.eat(18)) this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew);
        this.parseNewArguments(node147);
        return this.finishNode(node147, "NewExpression");
    }
    parseNewArguments(node148) {
        if (this.eat(10)) {
            const args = this.parseExprList(11);
            this.toReferencedList(args);
            node148.arguments = args;
        } else node148.arguments = [];
    }
    parseTemplateElement(isTagged) {
        const elem = this.startNode();
        if (this.state.value === null) {
            if (!isTagged) this.raise(this.state.start + 1, ErrorMessages.InvalidEscapeSequenceTemplate);
        }
        elem.value = {
            raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
            cooked: this.state.value
        };
        this.next();
        elem.tail = this.match(22);
        return this.finishNode(elem, "TemplateElement");
    }
    parseTemplate(isTagged1) {
        const node = this.startNode();
        this.next();
        node.expressions = [];
        let curElt = this.parseTemplateElement(isTagged1);
        node.quasis = [
            curElt
        ];
        while(!curElt.tail){
            this.expect(23);
            node.expressions.push(this.parseTemplateSubstitution());
            this.expect(8);
            node.quasis.push(curElt = this.parseTemplateElement(isTagged1));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
        return this.parseExpression();
    }
    parseObjectLike(close3, isPattern, isRecord1, refExpressionErrors22) {
        if (isRecord1) this.expectPlugin("recordAndTuple");
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const propHash = Object.create(null);
        let first = true;
        const node = this.startNode();
        node.properties = [];
        this.next();
        while(!this.match(close3)){
            if (first) first = false;
            else {
                this.expect(12);
                if (this.match(close3)) {
                    this.addExtra(node, "trailingComma", this.state.lastTokStart);
                    break;
                }
            }
            const prop = this.parsePropertyDefinition(isPattern, refExpressionErrors22);
            if (!isPattern) this.checkProto(prop, isRecord1, propHash, refExpressionErrors22);
            if (isRecord1 && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") this.raise(prop.start, ErrorMessages.InvalidRecordProperty);
            if (prop.shorthand) this.addExtra(prop, "shorthand", true);
            node.properties.push(prop);
        }
        this.next();
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let type = "ObjectExpression";
        if (isPattern) type = "ObjectPattern";
        else if (isRecord1) type = "RecordExpression";
        return this.finishNode(node, type);
    }
    maybeAsyncOrAccessorProp(prop4) {
        return !prop4.computed && prop4.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(49));
    }
    parsePropertyDefinition(isPattern2, refExpressionErrors23) {
        let decorators = [];
        if (this.match(24)) {
            if (this.hasPlugin("decorators")) this.raise(this.state.start, ErrorMessages.UnsupportedPropertyDecorator);
            while(this.match(24))decorators.push(this.parseDecorator());
        }
        const prop = this.startNode();
        let isGenerator = false;
        let isAsync = false;
        let isAccessor = false;
        let startPos;
        let startLoc;
        if (this.match(21)) {
            if (decorators.length) this.unexpected();
            if (isPattern2) {
                this.next();
                prop.argument = this.parseIdentifier();
                this.checkCommaAfterRest(125);
                return this.finishNode(prop, "RestElement");
            }
            return this.parseSpread();
        }
        if (decorators.length) {
            prop.decorators = decorators;
            decorators = [];
        }
        prop.method = false;
        if (isPattern2 || refExpressionErrors23) {
            startPos = this.state.start;
            startLoc = this.state.startLoc;
        }
        if (!isPattern2) isGenerator = this.eat(49);
        const containsEsc = this.state.containsEsc;
        const key = this.parsePropertyName(prop, false);
        if (!isPattern2 && !isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
            const keyName = key.name;
            if (keyName === "async" && !this.hasPrecedingLineBreak()) {
                isAsync = true;
                this.resetPreviousNodeTrailingComments(key);
                isGenerator = this.eat(49);
                this.parsePropertyName(prop, false);
            }
            if (keyName === "get" || keyName === "set") {
                isAccessor = true;
                this.resetPreviousNodeTrailingComments(key);
                prop.kind = keyName;
                if (this.match(49)) {
                    isGenerator = true;
                    this.raise(this.state.pos, ErrorMessages.AccessorIsGenerator, keyName);
                    this.next();
                }
                this.parsePropertyName(prop, false);
            }
        }
        this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern2, isAccessor, refExpressionErrors23);
        return prop;
    }
    getGetterSetterExpectedParamCount(method) {
        return method.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(method7) {
        return method7.params;
    }
    checkGetterSetterParams(method8) {
        var _params;
        const paramCount = this.getGetterSetterExpectedParamCount(method8);
        const params = this.getObjectOrClassMethodParams(method8);
        const start = method8.start;
        if (params.length !== paramCount) {
            if (method8.kind === "get") this.raise(start, ErrorMessages.BadGetterArity);
            else this.raise(start, ErrorMessages.BadSetterArity);
        }
        if (method8.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") this.raise(start, ErrorMessages.BadSetterRestParameter);
    }
    parseObjectMethod(prop5, isGenerator, isAsync7, isPattern3, isAccessor) {
        if (isAccessor) {
            this.parseMethod(prop5, isGenerator, false, false, false, "ObjectMethod");
            this.checkGetterSetterParams(prop5);
            return prop5;
        }
        if (isAsync7 || isGenerator || this.match(10)) {
            if (isPattern3) this.unexpected();
            prop5.kind = "method";
            prop5.method = true;
            return this.parseMethod(prop5, isGenerator, isAsync7, false, false, "ObjectMethod");
        }
    }
    parseObjectProperty(prop6, startPos24, startLoc27, isPattern4, refExpressionErrors24) {
        prop6.shorthand = false;
        if (this.eat(14)) {
            prop6.value = isPattern4 ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors24);
            return this.finishNode(prop6, "ObjectProperty");
        }
        if (!prop6.computed && prop6.key.type === "Identifier") {
            this.checkReservedWord(prop6.key.name, prop6.key.start, true, false);
            if (isPattern4) prop6.value = this.parseMaybeDefault(startPos24, startLoc27, cloneIdentifier(prop6.key));
            else if (this.match(27) && refExpressionErrors24) {
                if (refExpressionErrors24.shorthandAssign === -1) refExpressionErrors24.shorthandAssign = this.state.start;
                prop6.value = this.parseMaybeDefault(startPos24, startLoc27, cloneIdentifier(prop6.key));
            } else prop6.value = cloneIdentifier(prop6.key);
            prop6.shorthand = true;
            return this.finishNode(prop6, "ObjectProperty");
        }
    }
    parseObjPropValue(prop7, startPos25, startLoc28, isGenerator6, isAsync8, isPattern5, isAccessor1, refExpressionErrors25) {
        const node = this.parseObjectMethod(prop7, isGenerator6, isAsync8, isPattern5, isAccessor1) || this.parseObjectProperty(prop7, startPos25, startLoc28, isPattern5, refExpressionErrors25);
        if (!node) this.unexpected();
        return node;
    }
    parsePropertyName(prop8, isPrivateNameAllowed1) {
        if (this.eat(0)) {
            prop8.computed = true;
            prop8.key = this.parseMaybeAssignAllowIn();
            this.expect(3);
        } else {
            const type = this.state.type;
            prop8.key = type === 124 || type === 123 || type === 125 || type === 126 ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed1);
            if (type !== 128) prop8.computed = false;
        }
        return prop8.key;
    }
    initFunction(node149, isAsync9) {
        node149.id = null;
        node149.generator = false;
        node149.async = !!isAsync9;
    }
    parseMethod(node150, isGenerator7, isAsync10, isConstructor, allowDirectSuper, type18, inClassScope = false) {
        this.initFunction(node150, isAsync10);
        node150.generator = !!isGenerator7;
        const allowModifiers = isConstructor;
        this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.prodParam.enter(functionFlags(isAsync10, node150.generator));
        this.parseFunctionParams(node150, allowModifiers);
        this.parseFunctionBodyAndFinish(node150, type18, true);
        this.prodParam.exit();
        this.scope.exit();
        return node150;
    }
    parseArrayLike(close4, canBePattern, isTuple, refExpressionErrors26) {
        if (isTuple) this.expectPlugin("recordAndTuple");
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const node = this.startNode();
        this.next();
        node.elements = this.parseExprList(close4, !isTuple, refExpressionErrors26, node);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(node151, params6, isAsync11, trailingCommaPos1) {
        this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
        let flags = functionFlags(isAsync11, false);
        if (!this.match(0) && this.prodParam.hasIn) flags |= PARAM_IN;
        this.prodParam.enter(flags);
        this.initFunction(node151, isAsync11);
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        if (params6) {
            this.state.maybeInArrowParameters = true;
            this.setArrowFunctionParameters(node151, params6, trailingCommaPos1);
        }
        this.state.maybeInArrowParameters = false;
        this.parseFunctionBody(node151, true);
        this.prodParam.exit();
        this.scope.exit();
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node151, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(node152, params7, trailingCommaPos2) {
        node152.params = this.toAssignableList(params7, trailingCommaPos2, false);
    }
    parseFunctionBodyAndFinish(node153, type19, isMethod = false) {
        this.parseFunctionBody(node153, false, isMethod);
        this.finishNode(node153, type19);
    }
    parseFunctionBody(node154, allowExpression, isMethod2 = false) {
        const isExpression = allowExpression && !this.match(5);
        this.expressionScope.enter(newExpressionScope());
        if (isExpression) {
            node154.body = this.parseMaybeAssign();
            this.checkParams(node154, false, allowExpression, false);
        } else {
            const oldStrict = this.state.strict;
            const oldLabels = this.state.labels;
            this.state.labels = [];
            this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
            node154.body = this.parseBlock(true, false, (hasStrictModeDirective)=>{
                const nonSimple = !this.isSimpleParamList(node154.params);
                if (hasStrictModeDirective && nonSimple) {
                    const errorPos = (node154.kind === "method" || node154.kind === "constructor") && !!node154.key ? node154.key.end : node154.start;
                    this.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);
                }
                const strictModeChanged = !oldStrict && this.state.strict;
                this.checkParams(node154, !this.state.strict && !allowExpression && !isMethod2 && !nonSimple, allowExpression, strictModeChanged);
                if (this.state.strict && node154.id) this.checkLVal(node154.id, "function name", BIND_OUTSIDE, undefined, undefined, strictModeChanged);
            });
            this.prodParam.exit();
            this.state.labels = oldLabels;
        }
        this.expressionScope.exit();
    }
    isSimpleParamList(params8) {
        for(let i = 0, len = params8.length; i < len; i++){
            if (params8[i].type !== "Identifier") return false;
        }
        return true;
    }
    checkParams(node155, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        const checkClashes = new Set();
        for (const param of node155.params)this.checkLVal(param, "function parameter list", BIND_VAR, allowDuplicates ? null : checkClashes, undefined, strictModeChanged);
    }
    parseExprList(close5, allowEmpty1, refExpressionErrors27, nodeForExtra1) {
        const elts = [];
        let first = true;
        while(!this.eat(close5)){
            if (first) first = false;
            else {
                this.expect(12);
                if (this.match(close5)) {
                    if (nodeForExtra1) this.addExtra(nodeForExtra1, "trailingComma", this.state.lastTokStart);
                    this.next();
                    break;
                }
            }
            elts.push(this.parseExprListItem(allowEmpty1, refExpressionErrors27));
        }
        return elts;
    }
    parseExprListItem(allowEmpty2, refExpressionErrors28, allowPlaceholder1) {
        let elt;
        if (this.match(12)) {
            if (!allowEmpty2) this.raise(this.state.pos, ErrorMessages.UnexpectedToken, ",");
            elt = null;
        } else if (this.match(21)) {
            const spreadNodeStartPos = this.state.start;
            const spreadNodeStartLoc = this.state.startLoc;
            elt = this.parseParenItem(this.parseSpread(refExpressionErrors28), spreadNodeStartPos, spreadNodeStartLoc);
        } else if (this.match(17)) {
            this.expectPlugin("partialApplication");
            if (!allowPlaceholder1) this.raise(this.state.start, ErrorMessages.UnexpectedArgumentPlaceholder);
            const node = this.startNode();
            this.next();
            elt = this.finishNode(node, "ArgumentPlaceholder");
        } else elt = this.parseMaybeAssignAllowIn(refExpressionErrors28, this.parseParenItem);
        return elt;
    }
    parseIdentifier(liberal) {
        const node = this.startNode();
        const name = this.parseIdentifierName(node.start, liberal);
        return this.createIdentifier(node, name);
    }
    createIdentifier(node156, name17) {
        node156.name = name17;
        node156.loc.identifierName = name17;
        return this.finishNode(node156, "Identifier");
    }
    parseIdentifierName(pos35, liberal1) {
        let name;
        const { start , type  } = this.state;
        if (tokenIsKeywordOrIdentifier(type)) name = this.state.value;
        else throw this.unexpected();
        const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);
        if (liberal1) {
            if (tokenIsKeyword) this.replaceToken(122);
        } else this.checkReservedWord(name, start, tokenIsKeyword, false);
        this.next();
        return name;
    }
    checkReservedWord(word, startLoc29, checkKeywords, isBinding2) {
        if (word.length > 10) return;
        if (!canBeReservedWord(word)) return;
        if (word === "yield") {
            if (this.prodParam.hasYield) {
                this.raise(startLoc29, ErrorMessages.YieldBindingIdentifier);
                return;
            }
        } else if (word === "await") {
            if (this.prodParam.hasAwait) {
                this.raise(startLoc29, ErrorMessages.AwaitBindingIdentifier);
                return;
            } else if (this.scope.inStaticBlock) {
                this.raise(startLoc29, ErrorMessages.AwaitBindingIdentifierInStaticBlock);
                return;
            } else this.expressionScope.recordAsyncArrowParametersError(startLoc29, ErrorMessages.AwaitBindingIdentifier);
        } else if (word === "arguments") {
            if (this.scope.inClassAndNotInNonArrowFunction) {
                this.raise(startLoc29, ErrorMessages.ArgumentsInClass);
                return;
            }
        }
        if (checkKeywords && isKeyword(word)) {
            this.raise(startLoc29, ErrorMessages.UnexpectedKeyword, word);
            return;
        }
        const reservedTest = !this.state.strict ? isReservedWord : isBinding2 ? isStrictBindReservedWord : isStrictReservedWord;
        if (reservedTest(word, this.inModule)) this.raise(startLoc29, ErrorMessages.UnexpectedReservedWord, word);
    }
    isAwaitAllowed() {
        if (this.prodParam.hasAwait) return true;
        if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) return true;
        return false;
    }
    parseAwait(startPos26, startLoc30) {
        const node = this.startNodeAt(startPos26, startLoc30);
        this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.AwaitExpressionFormalParameter);
        if (this.eat(49)) this.raise(node.start, ErrorMessages.ObsoleteAwaitStar);
        if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
            if (this.isAmbiguousAwait()) this.ambiguousScriptDifferentAst = true;
            else this.sawUnambiguousESM = true;
        }
        if (!this.state.soloAwait) node.argument = this.parseMaybeUnary(null, true);
        return this.finishNode(node, "AwaitExpression");
    }
    isAmbiguousAwait() {
        return this.hasPrecedingLineBreak() || this.match(47) || this.match(10) || this.match(0) || this.match(22) || this.match(127) || this.match(50) || this.hasPlugin("v8intrinsic") && this.match(48);
    }
    parseYield() {
        const node = this.startNode();
        this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.YieldInParameter);
        this.next();
        let delegating = false;
        let argument = null;
        if (!this.hasPrecedingLineBreak()) {
            delegating = this.eat(49);
            switch(this.state.type){
                case 13:
                case 129:
                case 8:
                case 11:
                case 3:
                case 9:
                case 14:
                case 12:
                    if (!delegating) break;
                default:
                    argument = this.parseMaybeAssign();
            }
        }
        node.delegate = delegating;
        node.argument = argument;
        return this.finishNode(node, "YieldExpression");
    }
    checkPipelineAtInfixOperator(left2, leftStartPos1) {
        if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
            if (left2.type === "SequenceExpression") this.raise(leftStartPos1, ErrorMessages.PipelineHeadSequenceExpression);
        }
    }
    checkHackPipeBodyEarlyErrors(startPos27) {
        if (!this.topicReferenceWasUsedInCurrentContext()) this.raise(startPos27, ErrorMessages.PipeTopicUnused);
    }
    parseSmartPipelineBodyInStyle(childExpr, startPos28, startLoc31) {
        const bodyNode = this.startNodeAt(startPos28, startLoc31);
        if (this.isSimpleReference(childExpr)) {
            bodyNode.callee = childExpr;
            return this.finishNode(bodyNode, "PipelineBareFunction");
        } else {
            this.checkSmartPipeTopicBodyEarlyErrors(startPos28);
            bodyNode.expression = childExpr;
            return this.finishNode(bodyNode, "PipelineTopicExpression");
        }
    }
    isSimpleReference(expression) {
        switch(expression.type){
            case "MemberExpression":
                return !expression.computed && this.isSimpleReference(expression.object);
            case "Identifier":
                return true;
            default:
                return false;
        }
    }
    checkSmartPipeTopicBodyEarlyErrors(startPos29) {
        if (this.match(19)) throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);
        else if (!this.topicReferenceWasUsedInCurrentContext()) this.raise(startPos29, ErrorMessages.PipelineTopicUnused);
    }
    withTopicBindingContext(callback) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
            maxNumOfResolvableTopics: 1,
            maxTopicIndex: null
        };
        try {
            return callback();
        } finally{
            this.state.topicContext = outerContextTopicState;
        }
    }
    withSmartMixTopicForbiddingContext(callback1) {
        const proposal = this.getPluginOption("pipelineOperator", "proposal");
        if (proposal === "smart") {
            const outerContextTopicState = this.state.topicContext;
            this.state.topicContext = {
                maxNumOfResolvableTopics: 0,
                maxTopicIndex: null
            };
            try {
                return callback1();
            } finally{
                this.state.topicContext = outerContextTopicState;
            }
        } else return callback1();
    }
    withSoloAwaitPermittingContext(callback2) {
        const outerContextSoloAwaitState = this.state.soloAwait;
        this.state.soloAwait = true;
        try {
            return callback2();
        } finally{
            this.state.soloAwait = outerContextSoloAwaitState;
        }
    }
    allowInAnd(callback3) {
        const flags = this.prodParam.currentFlags();
        const prodParamToSet = PARAM_IN & ~flags;
        if (prodParamToSet) {
            this.prodParam.enter(flags | PARAM_IN);
            try {
                return callback3();
            } finally{
                this.prodParam.exit();
            }
        }
        return callback3();
    }
    disallowInAnd(callback4) {
        const flags = this.prodParam.currentFlags();
        const prodParamToClear = PARAM_IN & flags;
        if (prodParamToClear) {
            this.prodParam.enter(flags & ~PARAM_IN);
            try {
                return callback4();
            } finally{
                this.prodParam.exit();
            }
        }
        return callback4();
    }
    registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(prec2) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = true;
        const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, prec2);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return ret;
    }
    parseModuleExpression() {
        this.expectPlugin("moduleBlocks");
        const node = this.startNode();
        this.next();
        this.eat(5);
        const revertScopes = this.initializeScopes(true);
        this.enterInitialScopes();
        const program = this.startNode();
        try {
            node.body = this.parseProgram(program, 8, "module");
        } finally{
            revertScopes();
        }
        this.eat(8);
        return this.finishNode(node, "ModuleExpression");
    }
}
const loopLabel = {
    kind: "loop"
}, switchLabel = {
    kind: "switch"
};
const FUNC_NO_FLAGS = 0, FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
const loneSurrogate = /[\uD800-\uDFFF]/u;
const keywordRelationalOperator = /in(?:stanceof)?/y;
function babel7CompatTokens(tokens) {
    for(let i = 0; i < tokens.length; i++){
        const token = tokens[i];
        const { type  } = token;
        if (type === 128) {
            const { loc , start , value , end  } = token;
            const hashEndPos = start + 1;
            const hashEndLoc = new Position(loc.start.line, loc.start.column + 1);
            tokens.splice(i, 1, new Token({
                type: getExportedToken(25),
                value: "#",
                start: start,
                end: hashEndPos,
                startLoc: loc.start,
                endLoc: hashEndLoc
            }), new Token({
                type: getExportedToken(122),
                value: value,
                start: hashEndPos,
                end: end,
                startLoc: hashEndLoc,
                endLoc: loc.end
            }));
            i++;
            continue;
        }
        if (typeof type === "number") token.type = getExportedToken(type);
    }
    return tokens;
}
class StatementParser extends ExpressionParser {
    parseTopLevel(file, program) {
        file.program = this.parseProgram(program);
        file.comments = this.state.comments;
        if (this.options.tokens) file.tokens = babel7CompatTokens(this.tokens);
        return this.finishNode(file, "File");
    }
    parseProgram(program1, end = 129, sourceType1 = this.options.sourceType) {
        program1.sourceType = sourceType1;
        program1.interpreter = this.parseInterpreterDirective();
        this.parseBlockBody(program1, true, true, end);
        if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for (const [name] of Array.from(this.scope.undefinedExports)){
            const pos = this.scope.undefinedExports.get(name);
            this.raise(pos, ErrorMessages.ModuleExportUndefined, name);
        }
        return this.finishNode(program1, "Program");
    }
    stmtToDirective(stmt) {
        const directive = stmt;
        directive.type = "Directive";
        directive.value = directive.expression;
        delete directive.expression;
        const directiveLiteral = directive.value;
        const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
        const val = directiveLiteral.value = raw.slice(1, -1);
        this.addExtra(directiveLiteral, "raw", raw);
        this.addExtra(directiveLiteral, "rawValue", val);
        directiveLiteral.type = "DirectiveLiteral";
        return directive;
    }
    parseInterpreterDirective() {
        if (!this.match(26)) return null;
        const node = this.startNode();
        node.value = this.state.value;
        this.next();
        return this.finishNode(node, "InterpreterDirective");
    }
    isLet(context) {
        if (!this.isContextual(93)) return false;
        return this.isLetKeyword(context);
    }
    isLetKeyword(context2) {
        const next = this.nextTokenStart();
        const nextCh = this.codePointAtPos(next);
        if (nextCh === 92 || nextCh === 91) return true;
        if (context2) return false;
        if (nextCh === 123) return true;
        if (isIdentifierStart(nextCh)) {
            keywordRelationalOperator.lastIndex = next;
            if (keywordRelationalOperator.test(this.input)) {
                const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
                if (!isIdentifierChar(endCh) && endCh !== 92) return false;
            }
            return true;
        }
        return false;
    }
    parseStatement(context3, topLevel) {
        if (this.match(24)) this.parseDecorators(true);
        return this.parseStatementContent(context3, topLevel);
    }
    parseStatementContent(context4, topLevel1) {
        let starttype = this.state.type;
        const node = this.startNode();
        let kind;
        if (this.isLet(context4)) {
            starttype = 68;
            kind = "let";
        }
        switch(starttype){
            case 54:
                return this.parseBreakContinueStatement(node, true);
            case 57:
                return this.parseBreakContinueStatement(node, false);
            case 58:
                return this.parseDebuggerStatement(node);
            case 84:
                return this.parseDoStatement(node);
            case 85:
                return this.parseForStatement(node);
            case 62:
                if (this.lookaheadCharCode() === 46) break;
                if (context4) {
                    if (this.state.strict) this.raise(this.state.start, ErrorMessages.StrictFunction);
                    else if (context4 !== "if" && context4 !== "label") this.raise(this.state.start, ErrorMessages.SloppyFunction);
                }
                return this.parseFunctionStatement(node, false, !context4);
            case 74:
                if (context4) this.unexpected();
                return this.parseClass(node, true);
            case 63:
                return this.parseIfStatement(node);
            case 64:
                return this.parseReturnStatement(node);
            case 65:
                return this.parseSwitchStatement(node);
            case 66:
                return this.parseThrowStatement(node);
            case 67:
                return this.parseTryStatement(node);
            case 69:
            case 68:
                kind = kind || this.state.value;
                if (context4 && kind !== "var") this.raise(this.state.start, ErrorMessages.UnexpectedLexicalDeclaration);
                return this.parseVarStatement(node, kind);
            case 86:
                return this.parseWhileStatement(node);
            case 70:
                return this.parseWithStatement(node);
            case 5:
                return this.parseBlock();
            case 13:
                return this.parseEmptyStatement(node);
            case 77:
                {
                    const nextTokenCharCode = this.lookaheadCharCode();
                    if (nextTokenCharCode === 40 || nextTokenCharCode === 46) break;
                }
            case 76:
                {
                    if (!this.options.allowImportExportEverywhere && !topLevel1) this.raise(this.state.start, ErrorMessages.UnexpectedImportExport);
                    this.next();
                    let result;
                    if (starttype === 77) {
                        result = this.parseImport(node);
                        if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) this.sawUnambiguousESM = true;
                    } else {
                        result = this.parseExport(node);
                        if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") this.sawUnambiguousESM = true;
                    }
                    this.assertModuleNodeAllowed(node);
                    return result;
                }
            default:
                if (this.isAsyncFunction()) {
                    if (context4) this.raise(this.state.start, ErrorMessages.AsyncFunctionInSingleStatementContext);
                    this.next();
                    return this.parseFunctionStatement(node, true, !context4);
                }
        }
        const maybeName = this.state.value;
        const expr = this.parseExpression();
        if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) return this.parseLabeledStatement(node, maybeName, expr, context4);
        else return this.parseExpressionStatement(node, expr);
    }
    assertModuleNodeAllowed(node157) {
        if (!this.options.allowImportExportEverywhere && !this.inModule) this.raise(node157.start, SourceTypeModuleErrorMessages.ImportOutsideModule);
    }
    takeDecorators(node158) {
        const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
        if (decorators.length) {
            node158.decorators = decorators;
            this.resetStartLocationFromNode(node158, decorators[0]);
            this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
        }
    }
    canHaveLeadingDecorator() {
        return this.match(74);
    }
    parseDecorators(allowExport) {
        const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
        while(this.match(24)){
            const decorator = this.parseDecorator();
            currentContextDecorators.push(decorator);
        }
        if (this.match(76)) {
            if (!allowExport) this.unexpected();
            if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) this.raise(this.state.start, ErrorMessages.DecoratorExportClass);
        } else if (!this.canHaveLeadingDecorator()) throw this.raise(this.state.start, ErrorMessages.UnexpectedLeadingDecorator);
    }
    parseDecorator() {
        this.expectOnePlugin([
            "decorators-legacy",
            "decorators"
        ]);
        const node = this.startNode();
        this.next();
        if (this.hasPlugin("decorators")) {
            this.state.decoratorStack.push([]);
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            let expr;
            if (this.eat(10)) {
                expr = this.parseExpression();
                this.expect(11);
            } else {
                expr = this.parseIdentifier(false);
                while(this.eat(16)){
                    const node = this.startNodeAt(startPos, startLoc);
                    node.object = expr;
                    node.property = this.parseIdentifier(true);
                    node.computed = false;
                    expr = this.finishNode(node, "MemberExpression");
                }
            }
            node.expression = this.parseMaybeDecoratorArguments(expr);
            this.state.decoratorStack.pop();
        } else node.expression = this.parseExprSubscripts();
        return this.finishNode(node, "Decorator");
    }
    parseMaybeDecoratorArguments(expr12) {
        if (this.eat(10)) {
            const node = this.startNodeAtNode(expr12);
            node.callee = expr12;
            node.arguments = this.parseCallExpressionArguments(11, false);
            this.toReferencedList(node.arguments);
            return this.finishNode(node, "CallExpression");
        }
        return expr12;
    }
    parseBreakContinueStatement(node159, isBreak) {
        this.next();
        if (this.isLineTerminator()) node159.label = null;
        else {
            node159.label = this.parseIdentifier();
            this.semicolon();
        }
        this.verifyBreakContinue(node159, isBreak);
        return this.finishNode(node159, isBreak ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(node160, isBreak1) {
        let i;
        for(i = 0; i < this.state.labels.length; ++i){
            const lab = this.state.labels[i];
            if (node160.label == null || lab.name === node160.label.name) {
                if (lab.kind != null && (isBreak1 || lab.kind === "loop")) break;
                if (node160.label && isBreak1) break;
            }
        }
        if (i === this.state.labels.length) this.raise(node160.start, ErrorMessages.IllegalBreakContinue, isBreak1 ? "break" : "continue");
    }
    parseDebuggerStatement(node161) {
        this.next();
        this.semicolon();
        return this.finishNode(node161, "DebuggerStatement");
    }
    parseHeaderExpression() {
        this.expect(10);
        const val = this.parseExpression();
        this.expect(11);
        return val;
    }
    parseDoStatement(node162) {
        this.next();
        this.state.labels.push(loopLabel);
        node162.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement("do")
        );
        this.state.labels.pop();
        this.expect(86);
        node162.test = this.parseHeaderExpression();
        this.eat(13);
        return this.finishNode(node162, "DoWhileStatement");
    }
    parseForStatement(node163) {
        this.next();
        this.state.labels.push(loopLabel);
        let awaitAt = -1;
        if (this.isAwaitAllowed() && this.eatContextual(90)) awaitAt = this.state.lastTokStart;
        this.scope.enter(SCOPE_OTHER);
        this.expect(10);
        if (this.match(13)) {
            if (awaitAt > -1) this.unexpected(awaitAt);
            return this.parseFor(node163, null);
        }
        const startsWithLet = this.isContextual(93);
        const isLet = startsWithLet && this.isLetKeyword();
        if (this.match(68) || this.match(69) || isLet) {
            const init = this.startNode();
            const kind = isLet ? "let" : this.state.value;
            this.next();
            this.parseVar(init, true, kind);
            this.finishNode(init, "VariableDeclaration");
            if ((this.match(52) || this.isContextual(95)) && init.declarations.length === 1) return this.parseForIn(node163, init, awaitAt);
            if (awaitAt > -1) this.unexpected(awaitAt);
            return this.parseFor(node163, init);
        }
        const startsWithAsync = this.isContextual(89);
        const refExpressionErrors = new ExpressionErrors();
        const init = this.parseExpression(true, refExpressionErrors);
        const isForOf = this.isContextual(95);
        if (isForOf) {
            if (startsWithLet) this.raise(init.start, ErrorMessages.ForOfLet);
            else if (awaitAt === -1 && startsWithAsync && init.type === "Identifier") this.raise(init.start, ErrorMessages.ForOfAsync);
        }
        if (isForOf || this.match(52)) {
            this.toAssignable(init, true);
            const description = isForOf ? "for-of statement" : "for-in statement";
            this.checkLVal(init, description);
            return this.parseForIn(node163, init, awaitAt);
        } else this.checkExpressionErrors(refExpressionErrors, true);
        if (awaitAt > -1) this.unexpected(awaitAt);
        return this.parseFor(node163, init);
    }
    parseFunctionStatement(node164, isAsync12, declarationPosition) {
        this.next();
        return this.parseFunction(node164, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync12);
    }
    parseIfStatement(node165) {
        this.next();
        node165.test = this.parseHeaderExpression();
        node165.consequent = this.parseStatement("if");
        node165.alternate = this.eat(60) ? this.parseStatement("if") : null;
        return this.finishNode(node165, "IfStatement");
    }
    parseReturnStatement(node166) {
        if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) this.raise(this.state.start, ErrorMessages.IllegalReturn);
        this.next();
        if (this.isLineTerminator()) node166.argument = null;
        else {
            node166.argument = this.parseExpression();
            this.semicolon();
        }
        return this.finishNode(node166, "ReturnStatement");
    }
    parseSwitchStatement(node167) {
        this.next();
        node167.discriminant = this.parseHeaderExpression();
        const cases = node167.cases = [];
        this.expect(5);
        this.state.labels.push(switchLabel);
        this.scope.enter(SCOPE_OTHER);
        let cur;
        for(let sawDefault; !this.match(8);){
            if (this.match(55) || this.match(59)) {
                const isCase = this.match(55);
                if (cur) this.finishNode(cur, "SwitchCase");
                cases.push(cur = this.startNode());
                cur.consequent = [];
                this.next();
                if (isCase) cur.test = this.parseExpression();
                else {
                    if (sawDefault) this.raise(this.state.lastTokStart, ErrorMessages.MultipleDefaultsInSwitch);
                    sawDefault = true;
                    cur.test = null;
                }
                this.expect(14);
            } else if (cur) cur.consequent.push(this.parseStatement(null));
            else this.unexpected();
        }
        this.scope.exit();
        if (cur) this.finishNode(cur, "SwitchCase");
        this.next();
        this.state.labels.pop();
        return this.finishNode(node167, "SwitchStatement");
    }
    parseThrowStatement(node168) {
        this.next();
        if (this.hasPrecedingLineBreak()) this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow);
        node168.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node168, "ThrowStatement");
    }
    parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        const simple = param.type === "Identifier";
        this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLVal(param, "catch clause", BIND_LEXICAL);
        return param;
    }
    parseTryStatement(node169) {
        this.next();
        node169.block = this.parseBlock();
        node169.handler = null;
        if (this.match(56)) {
            const clause = this.startNode();
            this.next();
            if (this.match(10)) {
                this.expect(10);
                clause.param = this.parseCatchClauseParam();
                this.expect(11);
            } else {
                clause.param = null;
                this.scope.enter(SCOPE_OTHER);
            }
            clause.body = this.withSmartMixTopicForbiddingContext(()=>this.parseBlock(false, false)
            );
            this.scope.exit();
            node169.handler = this.finishNode(clause, "CatchClause");
        }
        node169.finalizer = this.eat(61) ? this.parseBlock() : null;
        if (!node169.handler && !node169.finalizer) this.raise(node169.start, ErrorMessages.NoCatchOrFinally);
        return this.finishNode(node169, "TryStatement");
    }
    parseVarStatement(node170, kind) {
        this.next();
        this.parseVar(node170, false, kind);
        this.semicolon();
        return this.finishNode(node170, "VariableDeclaration");
    }
    parseWhileStatement(node171) {
        this.next();
        node171.test = this.parseHeaderExpression();
        this.state.labels.push(loopLabel);
        node171.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement("while")
        );
        this.state.labels.pop();
        return this.finishNode(node171, "WhileStatement");
    }
    parseWithStatement(node172) {
        if (this.state.strict) this.raise(this.state.start, ErrorMessages.StrictWith);
        this.next();
        node172.object = this.parseHeaderExpression();
        node172.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement("with")
        );
        return this.finishNode(node172, "WithStatement");
    }
    parseEmptyStatement(node173) {
        this.next();
        return this.finishNode(node173, "EmptyStatement");
    }
    parseLabeledStatement(node174, maybeName, expr13, context5) {
        for (const label of this.state.labels)if (label.name === maybeName) this.raise(expr13.start, ErrorMessages.LabelRedeclaration, maybeName);
        const kind = tokenIsLoop(this.state.type) ? "loop" : this.match(65) ? "switch" : null;
        for(let i = this.state.labels.length - 1; i >= 0; i--){
            const label = this.state.labels[i];
            if (label.statementStart === node174.start) {
                label.statementStart = this.state.start;
                label.kind = kind;
            } else break;
        }
        this.state.labels.push({
            name: maybeName,
            kind: kind,
            statementStart: this.state.start
        });
        node174.body = this.parseStatement(context5 ? context5.indexOf("label") === -1 ? context5 + "label" : context5 : "label");
        this.state.labels.pop();
        node174.label = expr13;
        return this.finishNode(node174, "LabeledStatement");
    }
    parseExpressionStatement(node175, expr14) {
        node175.expression = expr14;
        this.semicolon();
        return this.finishNode(node175, "ExpressionStatement");
    }
    parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
        const node = this.startNode();
        if (allowDirectives) this.state.strictErrors.clear();
        this.expect(5);
        if (createNewLexicalScope) this.scope.enter(SCOPE_OTHER);
        this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
        if (createNewLexicalScope) this.scope.exit();
        return this.finishNode(node, "BlockStatement");
    }
    isValidDirective(stmt2) {
        return stmt2.type === "ExpressionStatement" && stmt2.expression.type === "StringLiteral" && !stmt2.expression.extra.parenthesized;
    }
    parseBlockBody(node176, allowDirectives1, topLevel2, end4, afterBlockParse1) {
        const body = node176.body = [];
        const directives = node176.directives = [];
        this.parseBlockOrModuleBlockBody(body, allowDirectives1 ? directives : undefined, topLevel2, end4, afterBlockParse1);
    }
    parseBlockOrModuleBlockBody(body, directives, topLevel3, end5, afterBlockParse2) {
        const oldStrict = this.state.strict;
        let hasStrictModeDirective = false;
        let parsedNonDirective = false;
        while(!this.match(end5)){
            const stmt = this.parseStatement(null, topLevel3);
            if (directives && !parsedNonDirective) {
                if (this.isValidDirective(stmt)) {
                    const directive = this.stmtToDirective(stmt);
                    directives.push(directive);
                    if (!hasStrictModeDirective && directive.value.value === "use strict") {
                        hasStrictModeDirective = true;
                        this.setStrict(true);
                    }
                    continue;
                }
                parsedNonDirective = true;
                this.state.strictErrors.clear();
            }
            body.push(stmt);
        }
        if (afterBlockParse2) afterBlockParse2.call(this, hasStrictModeDirective);
        if (!oldStrict) this.setStrict(false);
        this.next();
    }
    parseFor(node177, init) {
        node177.init = init;
        this.semicolon(false);
        node177.test = this.match(13) ? null : this.parseExpression();
        this.semicolon(false);
        node177.update = this.match(11) ? null : this.parseExpression();
        this.expect(11);
        node177.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement("for")
        );
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node177, "ForStatement");
    }
    parseForIn(node178, init1, awaitAt) {
        const isForIn = this.match(52);
        this.next();
        if (isForIn) {
            if (awaitAt > -1) this.unexpected(awaitAt);
        } else node178.await = awaitAt > -1;
        if (init1.type === "VariableDeclaration" && init1.declarations[0].init != null && (!isForIn || this.state.strict || init1.kind !== "var" || init1.declarations[0].id.type !== "Identifier")) this.raise(init1.start, ErrorMessages.ForInOfLoopInitializer, isForIn ? "for-in" : "for-of");
        else if (init1.type === "AssignmentPattern") this.raise(init1.start, ErrorMessages.InvalidLhs, "for-loop");
        node178.left = init1;
        node178.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
        this.expect(11);
        node178.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement("for")
        );
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node178, isForIn ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(node179, isFor, kind10) {
        const declarations = node179.declarations = [];
        const isTypescript = this.hasPlugin("typescript");
        node179.kind = kind10;
        for(;;){
            const decl = this.startNode();
            this.parseVarId(decl, kind10);
            if (this.eat(27)) decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
            else {
                if (kind10 === "const" && !(this.match(52) || this.isContextual(95))) {
                    if (!isTypescript) this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Const declarations");
                } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(52) || this.isContextual(95)))) this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Complex binding patterns");
                decl.init = null;
            }
            declarations.push(this.finishNode(decl, "VariableDeclarator"));
            if (!this.eat(12)) break;
        }
        return node179;
    }
    parseVarId(decl, kind11) {
        decl.id = this.parseBindingAtom();
        this.checkLVal(decl.id, "variable declaration", kind11 === "var" ? BIND_VAR : BIND_LEXICAL, undefined, kind11 !== "var");
    }
    parseFunction(node180, statement = FUNC_NO_FLAGS, isAsync13 = false) {
        const isStatement = statement & FUNC_STATEMENT;
        const isHangingStatement = statement & FUNC_HANGING_STATEMENT;
        const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
        this.initFunction(node180, isAsync13);
        if (this.match(49) && isHangingStatement) this.raise(this.state.start, ErrorMessages.GeneratorInSingleStatementContext);
        node180.generator = this.eat(49);
        if (isStatement) node180.id = this.parseFunctionId(requireId);
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = false;
        this.scope.enter(SCOPE_FUNCTION);
        this.prodParam.enter(functionFlags(isAsync13, node180.generator));
        if (!isStatement) node180.id = this.parseFunctionId();
        this.parseFunctionParams(node180, false);
        this.withSmartMixTopicForbiddingContext(()=>{
            this.parseFunctionBodyAndFinish(node180, isStatement ? "FunctionDeclaration" : "FunctionExpression");
        });
        this.prodParam.exit();
        this.scope.exit();
        if (isStatement && !isHangingStatement) this.registerFunctionStatementId(node180);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return node180;
    }
    parseFunctionId(requireId) {
        return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(node181, allowModifiers3) {
        this.expect(10);
        this.expressionScope.enter(newParameterDeclarationScope());
        node181.params = this.parseBindingList(11, 41, false, allowModifiers3);
        this.expressionScope.exit();
    }
    registerFunctionStatementId(node182) {
        if (!node182.id) return;
        this.scope.declareName(node182.id.name, this.state.strict || node182.generator || node182.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node182.id.start);
    }
    parseClass(node183, isStatement, optionalId) {
        this.next();
        this.takeDecorators(node183);
        const oldStrict = this.state.strict;
        this.state.strict = true;
        this.parseClassId(node183, isStatement, optionalId);
        this.parseClassSuper(node183);
        node183.body = this.parseClassBody(!!node183.superClass, oldStrict);
        return this.finishNode(node183, isStatement ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
        return this.match(27) || this.match(13) || this.match(8);
    }
    isClassMethod() {
        return this.match(10);
    }
    isNonstaticConstructor(method9) {
        return !method9.computed && !method9.static && (method9.key.name === "constructor" || method9.key.value === "constructor");
    }
    parseClassBody(hadSuperClass, oldStrict) {
        this.classScope.enter();
        const state = {
            hadConstructor: false,
            hadSuperClass
        };
        let decorators = [];
        const classBody = this.startNode();
        classBody.body = [];
        this.expect(5);
        this.withSmartMixTopicForbiddingContext(()=>{
            while(!this.match(8)){
                if (this.eat(13)) {
                    if (decorators.length > 0) throw this.raise(this.state.lastTokEnd, ErrorMessages.DecoratorSemicolon);
                    continue;
                }
                if (this.match(24)) {
                    decorators.push(this.parseDecorator());
                    continue;
                }
                const member = this.startNode();
                if (decorators.length) {
                    member.decorators = decorators;
                    this.resetStartLocationFromNode(member, decorators[0]);
                    decorators = [];
                }
                this.parseClassMember(classBody, member, state);
                if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) this.raise(member.start, ErrorMessages.DecoratorConstructor);
            }
        });
        this.state.strict = oldStrict;
        this.next();
        if (decorators.length) throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);
        this.classScope.exit();
        return this.finishNode(classBody, "ClassBody");
    }
    parseClassMemberFromModifier(classBody, member) {
        const key = this.parseIdentifier(true);
        if (this.isClassMethod()) {
            const method = member;
            method.kind = "method";
            method.computed = false;
            method.key = key;
            method.static = false;
            this.pushClassMethod(classBody, method, false, false, false, false);
            return true;
        } else if (this.isClassProperty()) {
            const prop = member;
            prop.computed = false;
            prop.key = key;
            prop.static = false;
            classBody.body.push(this.parseClassProperty(prop));
            return true;
        }
        this.resetPreviousNodeTrailingComments(key);
        return false;
    }
    parseClassMember(classBody6, member3, state9) {
        const isStatic = this.isContextual(98);
        if (isStatic) {
            if (this.parseClassMemberFromModifier(classBody6, member3)) return;
            if (this.eat(5)) {
                this.parseClassStaticBlock(classBody6, member3);
                return;
            }
        }
        this.parseClassMemberWithIsStatic(classBody6, member3, state9, isStatic);
    }
    parseClassMemberWithIsStatic(classBody7, member4, state10, isStatic) {
        const publicMethod = member4;
        const privateMethod = member4;
        const publicProp = member4;
        const privateProp = member4;
        const method = publicMethod;
        const publicMember = publicMethod;
        member4.static = isStatic;
        if (this.eat(49)) {
            method.kind = "method";
            const isPrivateName = this.match(128);
            this.parseClassElementName(method);
            if (isPrivateName) {
                this.pushClassPrivateMethod(classBody7, privateMethod, true, false);
                return;
            }
            if (this.isNonstaticConstructor(publicMethod)) this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsGenerator);
            this.pushClassMethod(classBody7, publicMethod, true, false, false, false);
            return;
        }
        const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
        const isPrivate = this.match(128);
        const key = this.parseClassElementName(member4);
        const maybeQuestionTokenStart = this.state.start;
        this.parsePostMemberNameModifiers(publicMember);
        if (this.isClassMethod()) {
            method.kind = "method";
            if (isPrivate) {
                this.pushClassPrivateMethod(classBody7, privateMethod, false, false);
                return;
            }
            const isConstructor = this.isNonstaticConstructor(publicMethod);
            let allowsDirectSuper = false;
            if (isConstructor) {
                publicMethod.kind = "constructor";
                if (state10.hadConstructor && !this.hasPlugin("typescript")) this.raise(key.start, ErrorMessages.DuplicateConstructor);
                if (isConstructor && this.hasPlugin("typescript") && member4.override) this.raise(key.start, ErrorMessages.OverrideOnConstructor);
                state10.hadConstructor = true;
                allowsDirectSuper = state10.hadSuperClass;
            }
            this.pushClassMethod(classBody7, publicMethod, false, false, isConstructor, allowsDirectSuper);
        } else if (this.isClassProperty()) {
            if (isPrivate) this.pushClassPrivateProperty(classBody7, privateProp);
            else this.pushClassProperty(classBody7, publicProp);
        } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
            this.resetPreviousNodeTrailingComments(key);
            const isGenerator = this.eat(49);
            if (publicMember.optional) this.unexpected(maybeQuestionTokenStart);
            method.kind = "method";
            const isPrivate = this.match(128);
            this.parseClassElementName(method);
            this.parsePostMemberNameModifiers(publicMember);
            if (isPrivate) this.pushClassPrivateMethod(classBody7, privateMethod, isGenerator, true);
            else {
                if (this.isNonstaticConstructor(publicMethod)) this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAsync);
                this.pushClassMethod(classBody7, publicMethod, isGenerator, true, false, false);
            }
        } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(49) && this.isLineTerminator())) {
            this.resetPreviousNodeTrailingComments(key);
            method.kind = key.name;
            const isPrivate = this.match(128);
            this.parseClassElementName(publicMethod);
            if (isPrivate) this.pushClassPrivateMethod(classBody7, privateMethod, false, false);
            else {
                if (this.isNonstaticConstructor(publicMethod)) this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAccessor);
                this.pushClassMethod(classBody7, publicMethod, false, false, false, false);
            }
            this.checkGetterSetterParams(publicMethod);
        } else if (this.isLineTerminator()) {
            if (isPrivate) this.pushClassPrivateProperty(classBody7, privateProp);
            else this.pushClassProperty(classBody7, publicProp);
        } else this.unexpected();
    }
    parseClassElementName(member5) {
        const { type , value , start  } = this.state;
        if ((type === 122 || type === 123) && member5.static && value === "prototype") this.raise(start, ErrorMessages.StaticPrototype);
        if (type === 128 && value === "constructor") this.raise(start, ErrorMessages.ConstructorClassPrivateField);
        return this.parsePropertyName(member5, true);
    }
    parseClassStaticBlock(classBody8, member6) {
        var _member$decorators;
        this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(PARAM);
        const body = member6.body = [];
        this.parseBlockOrModuleBlockBody(body, undefined, false, 8);
        this.prodParam.exit();
        this.scope.exit();
        this.state.labels = oldLabels;
        classBody8.body.push(this.finishNode(member6, "StaticBlock"));
        if ((_member$decorators = member6.decorators) != null && _member$decorators.length) this.raise(member6.start, ErrorMessages.DecoratorStaticBlock);
    }
    pushClassProperty(classBody9, prop9) {
        if (!prop9.computed && (prop9.key.name === "constructor" || prop9.key.value === "constructor")) this.raise(prop9.key.start, ErrorMessages.ConstructorClassField);
        classBody9.body.push(this.parseClassProperty(prop9));
    }
    pushClassPrivateProperty(classBody10, prop10) {
        const node = this.parseClassPrivateProperty(prop10);
        classBody10.body.push(node);
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.start);
    }
    pushClassMethod(classBody11, method10, isGenerator8, isAsync14, isConstructor2, allowsDirectSuper) {
        classBody11.body.push(this.parseMethod(method10, isGenerator8, isAsync14, isConstructor2, allowsDirectSuper, "ClassMethod", true));
    }
    pushClassPrivateMethod(classBody12, method11, isGenerator9, isAsync15) {
        const node = this.parseMethod(method11, isGenerator9, isAsync15, false, false, "ClassPrivateMethod", true);
        classBody12.body.push(node);
        const kind = node.kind === "get" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
        this.declareClassPrivateMethodInScope(node, kind);
    }
    declareClassPrivateMethodInScope(node184, kind12) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node184.key), kind12, node184.key.start);
    }
    parsePostMemberNameModifiers(methodOrProp) {
    }
    parseClassPrivateProperty(node185) {
        this.parseInitializer(node185);
        this.semicolon();
        return this.finishNode(node185, "ClassPrivateProperty");
    }
    parseClassProperty(node186) {
        this.parseInitializer(node186);
        this.semicolon();
        return this.finishNode(node186, "ClassProperty");
    }
    parseInitializer(node187) {
        this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
        this.expressionScope.enter(newExpressionScope());
        this.prodParam.enter(PARAM);
        node187.value = this.eat(27) ? this.parseMaybeAssignAllowIn() : null;
        this.expressionScope.exit();
        this.prodParam.exit();
        this.scope.exit();
    }
    parseClassId(node188, isStatement1, optionalId1, bindingType8 = BIND_CLASS) {
        if (tokenIsIdentifier(this.state.type)) {
            node188.id = this.parseIdentifier();
            if (isStatement1) this.checkLVal(node188.id, "class name", bindingType8);
        } else if (optionalId1 || !isStatement1) node188.id = null;
        else this.unexpected(null, ErrorMessages.MissingClassName);
    }
    parseClassSuper(node189) {
        node189.superClass = this.eat(75) ? this.parseExprSubscripts() : null;
    }
    parseExport(node190) {
        const hasDefault = this.maybeParseExportDefaultSpecifier(node190);
        const parseAfterDefault = !hasDefault || this.eat(12);
        const hasStar = parseAfterDefault && this.eatExportStar(node190);
        const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node190);
        const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
        const isFromRequired = hasDefault || hasStar;
        if (hasStar && !hasNamespace) {
            if (hasDefault) this.unexpected();
            this.parseExportFrom(node190, true);
            return this.finishNode(node190, "ExportAllDeclaration");
        }
        const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node190);
        if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) throw this.unexpected(null, 5);
        let hasDeclaration;
        if (isFromRequired || hasSpecifiers) {
            hasDeclaration = false;
            this.parseExportFrom(node190, isFromRequired);
        } else hasDeclaration = this.maybeParseExportDeclaration(node190);
        if (isFromRequired || hasSpecifiers || hasDeclaration) {
            this.checkExport(node190, true, false, !!node190.source);
            return this.finishNode(node190, "ExportNamedDeclaration");
        }
        if (this.eat(59)) {
            node190.declaration = this.parseExportDefaultExpression();
            this.checkExport(node190, true, true);
            return this.finishNode(node190, "ExportDefaultDeclaration");
        }
        throw this.unexpected(null, 5);
    }
    eatExportStar(node191) {
        return this.eat(49);
    }
    maybeParseExportDefaultSpecifier(node192) {
        if (this.isExportDefaultSpecifier()) {
            this.expectPlugin("exportDefaultFrom");
            const specifier = this.startNode();
            specifier.exported = this.parseIdentifier(true);
            node192.specifiers = [
                this.finishNode(specifier, "ExportDefaultSpecifier")
            ];
            return true;
        }
        return false;
    }
    maybeParseExportNamespaceSpecifier(node193) {
        if (this.isContextual(87)) {
            if (!node193.specifiers) node193.specifiers = [];
            const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
            this.next();
            specifier.exported = this.parseModuleExportName();
            node193.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
            return true;
        }
        return false;
    }
    maybeParseExportNamedSpecifiers(node194) {
        if (this.match(5)) {
            if (!node194.specifiers) node194.specifiers = [];
            const isTypeExport = node194.exportKind === "type";
            node194.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
            node194.source = null;
            node194.declaration = null;
            return true;
        }
        return false;
    }
    maybeParseExportDeclaration(node195) {
        if (this.shouldParseExportDeclaration()) {
            node195.specifiers = [];
            node195.source = null;
            node195.declaration = this.parseExportDeclaration(node195);
            return true;
        }
        return false;
    }
    isAsyncFunction() {
        if (!this.isContextual(89)) return false;
        const next = this.nextTokenStart();
        return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
    }
    parseExportDefaultExpression() {
        const expr = this.startNode();
        const isAsync = this.isAsyncFunction();
        if (this.match(62) || isAsync) {
            this.next();
            if (isAsync) this.next();
            return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
        } else if (this.match(74)) return this.parseClass(expr, true, true);
        else if (this.match(24)) {
            if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport);
            this.parseDecorators(false);
            return this.parseClass(expr, true, true);
        } else if (this.match(69) || this.match(68) || this.isLet()) throw this.raise(this.state.start, ErrorMessages.UnsupportedDefaultExport);
        else {
            const res = this.parseMaybeAssignAllowIn();
            this.semicolon();
            return res;
        }
    }
    parseExportDeclaration(node196) {
        return this.parseStatement(null);
    }
    isExportDefaultSpecifier() {
        const { type  } = this.state;
        if (tokenIsIdentifier(type)) {
            if (type === 89 && !this.state.containsEsc || type === 93) return false;
            if ((type === 120 || type === 119) && !this.state.containsEsc) {
                const { type: nextType  } = this.lookahead();
                if (tokenIsIdentifier(nextType) && nextType !== 91 || nextType === 5) {
                    this.expectOnePlugin([
                        "flow",
                        "typescript"
                    ]);
                    return false;
                }
            }
        } else if (!this.match(59)) return false;
        const next = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next, "from");
        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) return true;
        if (this.match(59) && hasFrom) {
            const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
            return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
    }
    parseExportFrom(node197, expect) {
        if (this.eatContextual(91)) {
            node197.source = this.parseImportSource();
            this.checkExport(node197);
            const assertions = this.maybeParseImportAssertions();
            if (assertions) node197.assertions = assertions;
        } else if (expect) this.unexpected();
        else node197.source = null;
        this.semicolon();
    }
    shouldParseExportDeclaration() {
        const { type  } = this.state;
        if (type === 24) {
            this.expectOnePlugin([
                "decorators",
                "decorators-legacy"
            ]);
            if (this.hasPlugin("decorators")) {
                if (this.getPluginOption("decorators", "decoratorsBeforeExport")) this.unexpected(this.state.start, ErrorMessages.DecoratorBeforeExport);
                else return true;
            }
        }
        return type === 68 || type === 69 || type === 62 || type === 74 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(node198, checkNames, isDefault, isFrom) {
        if (checkNames) {
            if (isDefault) {
                this.checkDuplicateExports(node198, "default");
                if (this.hasPlugin("exportDefaultFrom")) {
                    var _declaration$extra;
                    const declaration = node198.declaration;
                    if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) this.raise(declaration.start, ErrorMessages.ExportDefaultFromAsIdentifier);
                }
            } else if (node198.specifiers && node198.specifiers.length) for (const specifier of node198.specifiers){
                const { exported  } = specifier;
                const exportedName = exported.type === "Identifier" ? exported.name : exported.value;
                this.checkDuplicateExports(specifier, exportedName);
                if (!isFrom && specifier.local) {
                    const { local  } = specifier;
                    if (local.type !== "Identifier") this.raise(specifier.start, ErrorMessages.ExportBindingIsString, local.value, exportedName);
                    else {
                        this.checkReservedWord(local.name, local.start, true, false);
                        this.scope.checkLocalExport(local);
                    }
                }
            }
            else if (node198.declaration) {
                if (node198.declaration.type === "FunctionDeclaration" || node198.declaration.type === "ClassDeclaration") {
                    const id = node198.declaration.id;
                    if (!id) throw new Error("Assertion failure");
                    this.checkDuplicateExports(node198, id.name);
                } else if (node198.declaration.type === "VariableDeclaration") for (const declaration of node198.declaration.declarations)this.checkDeclaration(declaration.id);
            }
        }
        const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
        if (currentContextDecorators.length) throw this.raise(node198.start, ErrorMessages.UnsupportedDecoratorExport);
    }
    checkDeclaration(node199) {
        if (node199.type === "Identifier") this.checkDuplicateExports(node199, node199.name);
        else if (node199.type === "ObjectPattern") for (const prop of node199.properties)this.checkDeclaration(prop);
        else if (node199.type === "ArrayPattern") {
            for (const elem of node199.elements)if (elem) this.checkDeclaration(elem);
        } else if (node199.type === "ObjectProperty") this.checkDeclaration(node199.value);
        else if (node199.type === "RestElement") this.checkDeclaration(node199.argument);
        else if (node199.type === "AssignmentPattern") this.checkDeclaration(node199.left);
    }
    checkDuplicateExports(node200, name16) {
        if (this.exportedIdentifiers.has(name16)) this.raise(node200.start, name16 === "default" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, name16);
        this.exportedIdentifiers.add(name16);
    }
    parseExportSpecifiers(isInTypeExport) {
        const nodes = [];
        let first = true;
        this.expect(5);
        while(!this.eat(8)){
            if (first) first = false;
            else {
                this.expect(12);
                if (this.eat(8)) break;
            }
            const isMaybeTypeOnly = this.isContextual(120);
            const isString = this.match(123);
            const node = this.startNode();
            node.local = this.parseModuleExportName();
            nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
        }
        return nodes;
    }
    parseExportSpecifier(node201, isString, isInTypeExport1, isMaybeTypeOnly) {
        if (this.eatContextual(87)) node201.exported = this.parseModuleExportName();
        else if (isString) node201.exported = cloneStringLiteral(node201.local);
        else if (!node201.exported) node201.exported = cloneIdentifier(node201.local);
        return this.finishNode(node201, "ExportSpecifier");
    }
    parseModuleExportName() {
        if (this.match(123)) {
            const result = this.parseStringLiteral(this.state.value);
            const surrogate = result.value.match(loneSurrogate);
            if (surrogate) this.raise(result.start, ErrorMessages.ModuleExportNameHasLoneSurrogate, surrogate[0].charCodeAt(0).toString(16));
            return result;
        }
        return this.parseIdentifier(true);
    }
    parseImport(node202) {
        node202.specifiers = [];
        if (!this.match(123)) {
            const hasDefault = this.maybeParseDefaultImportSpecifier(node202);
            const parseNext = !hasDefault || this.eat(12);
            const hasStar = parseNext && this.maybeParseStarImportSpecifier(node202);
            if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node202);
            this.expectContextual(91);
        }
        node202.source = this.parseImportSource();
        const assertions = this.maybeParseImportAssertions();
        if (assertions) node202.assertions = assertions;
        else {
            const attributes = this.maybeParseModuleAttributes();
            if (attributes) node202.attributes = attributes;
        }
        this.semicolon();
        return this.finishNode(node202, "ImportDeclaration");
    }
    parseImportSource() {
        if (!this.match(123)) this.unexpected();
        return this.parseExprAtom();
    }
    shouldParseDefaultImport(node203) {
        return tokenIsIdentifier(this.state.type);
    }
    parseImportSpecifierLocal(node204, specifier, type, contextDescription1) {
        specifier.local = this.parseIdentifier();
        this.checkLVal(specifier.local, contextDescription1, BIND_LEXICAL);
        node204.specifiers.push(this.finishNode(specifier, type));
    }
    parseAssertEntries() {
        const attrs = [];
        const attrNames = new Set();
        do {
            if (this.match(8)) break;
            const node = this.startNode();
            const keyName = this.state.value;
            if (attrNames.has(keyName)) this.raise(this.state.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, keyName);
            attrNames.add(keyName);
            if (this.match(123)) node.key = this.parseStringLiteral(keyName);
            else node.key = this.parseIdentifier(true);
            this.expect(14);
            if (!this.match(123)) throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
            node.value = this.parseStringLiteral(this.state.value);
            this.finishNode(node, "ImportAttribute");
            attrs.push(node);
        }while (this.eat(12))
        return attrs;
    }
    maybeParseModuleAttributes() {
        if (this.match(70) && !this.hasPrecedingLineBreak()) {
            this.expectPlugin("moduleAttributes");
            this.next();
        } else {
            if (this.hasPlugin("moduleAttributes")) return [];
            return null;
        }
        const attrs = [];
        const attributes = new Set();
        do {
            const node = this.startNode();
            node.key = this.parseIdentifier(true);
            if (node.key.name !== "type") this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, node.key.name);
            if (attributes.has(node.key.name)) this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, node.key.name);
            attributes.add(node.key.name);
            this.expect(14);
            if (!this.match(123)) throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
            node.value = this.parseStringLiteral(this.state.value);
            this.finishNode(node, "ImportAttribute");
            attrs.push(node);
        }while (this.eat(12))
        return attrs;
    }
    maybeParseImportAssertions() {
        if (this.isContextual(88) && !this.hasPrecedingLineBreak()) {
            this.expectPlugin("importAssertions");
            this.next();
        } else {
            if (this.hasPlugin("importAssertions")) return [];
            return null;
        }
        this.eat(5);
        const attrs = this.parseAssertEntries();
        this.eat(8);
        return attrs;
    }
    maybeParseDefaultImportSpecifier(node205) {
        if (this.shouldParseDefaultImport(node205)) {
            this.parseImportSpecifierLocal(node205, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
            return true;
        }
        return false;
    }
    maybeParseStarImportSpecifier(node206) {
        if (this.match(49)) {
            const specifier = this.startNode();
            this.next();
            this.expectContextual(87);
            this.parseImportSpecifierLocal(node206, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
            return true;
        }
        return false;
    }
    parseNamedImportSpecifiers(node207) {
        let first = true;
        this.expect(5);
        while(!this.eat(8)){
            if (first) first = false;
            else {
                if (this.eat(14)) throw this.raise(this.state.start, ErrorMessages.DestructureNamedImport);
                this.expect(12);
                if (this.eat(8)) break;
            }
            const specifier = this.startNode();
            const importedIsString = this.match(123);
            const isMaybeTypeOnly = this.isContextual(120);
            specifier.imported = this.parseModuleExportName();
            const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node207.importKind === "type" || node207.importKind === "typeof", isMaybeTypeOnly);
            node207.specifiers.push(importSpecifier);
        }
    }
    parseImportSpecifier(specifier2, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly2) {
        if (this.eatContextual(87)) specifier2.local = this.parseIdentifier();
        else {
            const { imported  } = specifier2;
            if (importedIsString) throw this.raise(specifier2.start, ErrorMessages.ImportBindingIsString, imported.value);
            this.checkReservedWord(imported.name, specifier2.start, true, true);
            if (!specifier2.local) specifier2.local = cloneIdentifier(imported);
        }
        this.checkLVal(specifier2.local, "import specifier", BIND_LEXICAL);
        return this.finishNode(specifier2, "ImportSpecifier");
    }
    isThisParam(param1) {
        return param1.type === "Identifier" && param1.name === "this";
    }
}
class Parser extends StatementParser {
    constructor(options2, input1){
        options2 = getOptions(options2);
        super(options2, input1);
        this.options = options2;
        this.initializeScopes();
        this.plugins = pluginsMap(this.options.plugins);
        this.filename = options2.sourceFilename;
    }
    getScopeHandler() {
        return ScopeHandler;
    }
    parse() {
        this.enterInitialScopes();
        const file = this.startNode();
        const program = this.startNode();
        this.nextToken();
        file.errors = null;
        this.parseTopLevel(file, program);
        file.errors = this.state.errors;
        return file;
    }
}
function pluginsMap(plugins) {
    const pluginMap = new Map();
    for (const plugin of plugins){
        const [name, options] = Array.isArray(plugin) ? plugin : [
            plugin,
            {
            }
        ];
        if (!pluginMap.has(name)) pluginMap.set(name, options || {
        });
    }
    return pluginMap;
}
function parse1(input, options) {
    var _options;
    if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
        options = Object.assign({
        }, options);
        try {
            options.sourceType = "module";
            const parser = getParser(options, input);
            const ast = parser.parse();
            if (parser.sawUnambiguousESM) return ast;
            if (parser.ambiguousScriptDifferentAst) try {
                options.sourceType = "script";
                return getParser(options, input).parse();
            } catch (_unused) {
            }
            else ast.program.sourceType = "script";
            return ast;
        } catch (moduleError) {
            try {
                options.sourceType = "script";
                return getParser(options, input).parse();
            } catch (_unused2) {
            }
            throw moduleError;
        }
    } else return getParser(options, input).parse();
}
function parseExpression(input, options) {
    const parser = getParser(options, input);
    if (parser.options.strictMode) parser.state.strict = true;
    return parser.getExpression();
}
function generateExportedTokenTypes(internalTokenTypes) {
    const tokenTypes = {
    };
    for (const typeName of Object.keys(internalTokenTypes))tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);
    return tokenTypes;
}
const tokTypes = generateExportedTokenTypes(tt);
function getParser(options, input) {
    let cls = Parser;
    if (options != null && options.plugins) {
        validatePlugins(options.plugins);
        cls = getParserClass(options.plugins);
    }
    return new cls(options, input);
}
const parserClassCache = {
};
function getParserClass(pluginsFromOptions) {
    const pluginList = mixinPluginNames.filter((name)=>hasPlugin(pluginsFromOptions, name)
    );
    const key = pluginList.join("/");
    let cls = parserClassCache[key];
    if (!cls) {
        cls = Parser;
        for (const plugin of pluginList)cls = mixinPlugins[plugin](cls);
        parserClassCache[key] = cls;
    }
    return cls;
}
exports.parse = parse1;
exports.parseExpression = parseExpression;
exports.tokTypes = tokTypes;

},{}],"3rtBJ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _exportNames = {
    react: true,
    assertNode: true,
    createTypeAnnotationBasedOnTypeof: true,
    createUnionTypeAnnotation: true,
    createFlowUnionType: true,
    createTSUnionType: true,
    cloneNode: true,
    clone: true,
    cloneDeep: true,
    cloneDeepWithoutLoc: true,
    cloneWithoutLoc: true,
    addComment: true,
    addComments: true,
    inheritInnerComments: true,
    inheritLeadingComments: true,
    inheritsComments: true,
    inheritTrailingComments: true,
    removeComments: true,
    ensureBlock: true,
    toBindingIdentifierName: true,
    toBlock: true,
    toComputedKey: true,
    toExpression: true,
    toIdentifier: true,
    toKeyAlias: true,
    toSequenceExpression: true,
    toStatement: true,
    valueToNode: true,
    appendToMemberExpression: true,
    inherits: true,
    prependToMemberExpression: true,
    removeProperties: true,
    removePropertiesDeep: true,
    removeTypeDuplicates: true,
    getBindingIdentifiers: true,
    getOuterBindingIdentifiers: true,
    traverse: true,
    traverseFast: true,
    shallowEqual: true,
    is: true,
    isBinding: true,
    isBlockScoped: true,
    isImmutable: true,
    isLet: true,
    isNode: true,
    isNodesEquivalent: true,
    isPlaceholderType: true,
    isReferenced: true,
    isScope: true,
    isSpecifierDefault: true,
    isType: true,
    isValidES3Identifier: true,
    isValidIdentifier: true,
    isVar: true,
    matchesPattern: true,
    validate: true,
    buildMatchMemberExpression: true
};
Object.defineProperty(exports, "addComment", {
    enumerable: true,
    get: function() {
        return _addComment.default;
    }
});
Object.defineProperty(exports, "addComments", {
    enumerable: true,
    get: function() {
        return _addComments.default;
    }
});
Object.defineProperty(exports, "appendToMemberExpression", {
    enumerable: true,
    get: function() {
        return _appendToMemberExpression.default;
    }
});
Object.defineProperty(exports, "assertNode", {
    enumerable: true,
    get: function() {
        return _assertNode.default;
    }
});
Object.defineProperty(exports, "buildMatchMemberExpression", {
    enumerable: true,
    get: function() {
        return _buildMatchMemberExpression.default;
    }
});
Object.defineProperty(exports, "clone", {
    enumerable: true,
    get: function() {
        return _clone.default;
    }
});
Object.defineProperty(exports, "cloneDeep", {
    enumerable: true,
    get: function() {
        return _cloneDeep.default;
    }
});
Object.defineProperty(exports, "cloneDeepWithoutLoc", {
    enumerable: true,
    get: function() {
        return _cloneDeepWithoutLoc.default;
    }
});
Object.defineProperty(exports, "cloneNode", {
    enumerable: true,
    get: function() {
        return _cloneNode.default;
    }
});
Object.defineProperty(exports, "cloneWithoutLoc", {
    enumerable: true,
    get: function() {
        return _cloneWithoutLoc.default;
    }
});
Object.defineProperty(exports, "createFlowUnionType", {
    enumerable: true,
    get: function() {
        return _createFlowUnionType.default;
    }
});
Object.defineProperty(exports, "createTSUnionType", {
    enumerable: true,
    get: function() {
        return _createTSUnionType.default;
    }
});
Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
    enumerable: true,
    get: function() {
        return _createTypeAnnotationBasedOnTypeof.default;
    }
});
Object.defineProperty(exports, "createUnionTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _createFlowUnionType.default;
    }
});
Object.defineProperty(exports, "ensureBlock", {
    enumerable: true,
    get: function() {
        return _ensureBlock.default;
    }
});
Object.defineProperty(exports, "getBindingIdentifiers", {
    enumerable: true,
    get: function() {
        return _getBindingIdentifiers.default;
    }
});
Object.defineProperty(exports, "getOuterBindingIdentifiers", {
    enumerable: true,
    get: function() {
        return _getOuterBindingIdentifiers.default;
    }
});
Object.defineProperty(exports, "inheritInnerComments", {
    enumerable: true,
    get: function() {
        return _inheritInnerComments.default;
    }
});
Object.defineProperty(exports, "inheritLeadingComments", {
    enumerable: true,
    get: function() {
        return _inheritLeadingComments.default;
    }
});
Object.defineProperty(exports, "inheritTrailingComments", {
    enumerable: true,
    get: function() {
        return _inheritTrailingComments.default;
    }
});
Object.defineProperty(exports, "inherits", {
    enumerable: true,
    get: function() {
        return _inherits.default;
    }
});
Object.defineProperty(exports, "inheritsComments", {
    enumerable: true,
    get: function() {
        return _inheritsComments.default;
    }
});
Object.defineProperty(exports, "is", {
    enumerable: true,
    get: function() {
        return _is.default;
    }
});
Object.defineProperty(exports, "isBinding", {
    enumerable: true,
    get: function() {
        return _isBinding.default;
    }
});
Object.defineProperty(exports, "isBlockScoped", {
    enumerable: true,
    get: function() {
        return _isBlockScoped.default;
    }
});
Object.defineProperty(exports, "isImmutable", {
    enumerable: true,
    get: function() {
        return _isImmutable.default;
    }
});
Object.defineProperty(exports, "isLet", {
    enumerable: true,
    get: function() {
        return _isLet.default;
    }
});
Object.defineProperty(exports, "isNode", {
    enumerable: true,
    get: function() {
        return _isNode.default;
    }
});
Object.defineProperty(exports, "isNodesEquivalent", {
    enumerable: true,
    get: function() {
        return _isNodesEquivalent.default;
    }
});
Object.defineProperty(exports, "isPlaceholderType", {
    enumerable: true,
    get: function() {
        return _isPlaceholderType.default;
    }
});
Object.defineProperty(exports, "isReferenced", {
    enumerable: true,
    get: function() {
        return _isReferenced.default;
    }
});
Object.defineProperty(exports, "isScope", {
    enumerable: true,
    get: function() {
        return _isScope.default;
    }
});
Object.defineProperty(exports, "isSpecifierDefault", {
    enumerable: true,
    get: function() {
        return _isSpecifierDefault.default;
    }
});
Object.defineProperty(exports, "isType", {
    enumerable: true,
    get: function() {
        return _isType.default;
    }
});
Object.defineProperty(exports, "isValidES3Identifier", {
    enumerable: true,
    get: function() {
        return _isValidES3Identifier.default;
    }
});
Object.defineProperty(exports, "isValidIdentifier", {
    enumerable: true,
    get: function() {
        return _isValidIdentifier.default;
    }
});
Object.defineProperty(exports, "isVar", {
    enumerable: true,
    get: function() {
        return _isVar.default;
    }
});
Object.defineProperty(exports, "matchesPattern", {
    enumerable: true,
    get: function() {
        return _matchesPattern.default;
    }
});
Object.defineProperty(exports, "prependToMemberExpression", {
    enumerable: true,
    get: function() {
        return _prependToMemberExpression.default;
    }
});
exports.react = void 0;
Object.defineProperty(exports, "removeComments", {
    enumerable: true,
    get: function() {
        return _removeComments.default;
    }
});
Object.defineProperty(exports, "removeProperties", {
    enumerable: true,
    get: function() {
        return _removeProperties.default;
    }
});
Object.defineProperty(exports, "removePropertiesDeep", {
    enumerable: true,
    get: function() {
        return _removePropertiesDeep.default;
    }
});
Object.defineProperty(exports, "removeTypeDuplicates", {
    enumerable: true,
    get: function() {
        return _removeTypeDuplicates.default;
    }
});
Object.defineProperty(exports, "shallowEqual", {
    enumerable: true,
    get: function() {
        return _shallowEqual.default;
    }
});
Object.defineProperty(exports, "toBindingIdentifierName", {
    enumerable: true,
    get: function() {
        return _toBindingIdentifierName.default;
    }
});
Object.defineProperty(exports, "toBlock", {
    enumerable: true,
    get: function() {
        return _toBlock.default;
    }
});
Object.defineProperty(exports, "toComputedKey", {
    enumerable: true,
    get: function() {
        return _toComputedKey.default;
    }
});
Object.defineProperty(exports, "toExpression", {
    enumerable: true,
    get: function() {
        return _toExpression.default;
    }
});
Object.defineProperty(exports, "toIdentifier", {
    enumerable: true,
    get: function() {
        return _toIdentifier.default;
    }
});
Object.defineProperty(exports, "toKeyAlias", {
    enumerable: true,
    get: function() {
        return _toKeyAlias.default;
    }
});
Object.defineProperty(exports, "toSequenceExpression", {
    enumerable: true,
    get: function() {
        return _toSequenceExpression.default;
    }
});
Object.defineProperty(exports, "toStatement", {
    enumerable: true,
    get: function() {
        return _toStatement.default;
    }
});
Object.defineProperty(exports, "traverse", {
    enumerable: true,
    get: function() {
        return _traverse.default;
    }
});
Object.defineProperty(exports, "traverseFast", {
    enumerable: true,
    get: function() {
        return _traverseFast.default;
    }
});
Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
        return _validate.default;
    }
});
Object.defineProperty(exports, "valueToNode", {
    enumerable: true,
    get: function() {
        return _valueToNode.default;
    }
});
var _isReactComponent = require("./validators/react/isReactComponent");
var _isCompatTag = require("./validators/react/isCompatTag");
var _buildChildren = require("./builders/react/buildChildren");
var _assertNode = require("./asserts/assertNode");
var _generated = require("./asserts/generated");
Object.keys(_generated).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated[key];
        }
    });
});
var _createTypeAnnotationBasedOnTypeof = require("./builders/flow/createTypeAnnotationBasedOnTypeof");
var _createFlowUnionType = require("./builders/flow/createFlowUnionType");
var _createTSUnionType = require("./builders/typescript/createTSUnionType");
var _generated2 = require("./builders/generated");
Object.keys(_generated2).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated2[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated2[key];
        }
    });
});
var _uppercase = require("./builders/generated/uppercase");
Object.keys(_uppercase).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _uppercase[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _uppercase[key];
        }
    });
});
var _cloneNode = require("./clone/cloneNode");
var _clone = require("./clone/clone");
var _cloneDeep = require("./clone/cloneDeep");
var _cloneDeepWithoutLoc = require("./clone/cloneDeepWithoutLoc");
var _cloneWithoutLoc = require("./clone/cloneWithoutLoc");
var _addComment = require("./comments/addComment");
var _addComments = require("./comments/addComments");
var _inheritInnerComments = require("./comments/inheritInnerComments");
var _inheritLeadingComments = require("./comments/inheritLeadingComments");
var _inheritsComments = require("./comments/inheritsComments");
var _inheritTrailingComments = require("./comments/inheritTrailingComments");
var _removeComments = require("./comments/removeComments");
var _generated3 = require("./constants/generated");
Object.keys(_generated3).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated3[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated3[key];
        }
    });
});
var _constants = require("./constants");
Object.keys(_constants).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _constants[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _constants[key];
        }
    });
});
var _ensureBlock = require("./converters/ensureBlock");
var _toBindingIdentifierName = require("./converters/toBindingIdentifierName");
var _toBlock = require("./converters/toBlock");
var _toComputedKey = require("./converters/toComputedKey");
var _toExpression = require("./converters/toExpression");
var _toIdentifier = require("./converters/toIdentifier");
var _toKeyAlias = require("./converters/toKeyAlias");
var _toSequenceExpression = require("./converters/toSequenceExpression");
var _toStatement = require("./converters/toStatement");
var _valueToNode = require("./converters/valueToNode");
var _definitions = require("./definitions");
Object.keys(_definitions).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _definitions[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _definitions[key];
        }
    });
});
var _appendToMemberExpression = require("./modifications/appendToMemberExpression");
var _inherits = require("./modifications/inherits");
var _prependToMemberExpression = require("./modifications/prependToMemberExpression");
var _removeProperties = require("./modifications/removeProperties");
var _removePropertiesDeep = require("./modifications/removePropertiesDeep");
var _removeTypeDuplicates = require("./modifications/flow/removeTypeDuplicates");
var _getBindingIdentifiers = require("./retrievers/getBindingIdentifiers");
var _getOuterBindingIdentifiers = require("./retrievers/getOuterBindingIdentifiers");
var _traverse = require("./traverse/traverse");
Object.keys(_traverse).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _traverse[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _traverse[key];
        }
    });
});
var _traverseFast = require("./traverse/traverseFast");
var _shallowEqual = require("./utils/shallowEqual");
var _is = require("./validators/is");
var _isBinding = require("./validators/isBinding");
var _isBlockScoped = require("./validators/isBlockScoped");
var _isImmutable = require("./validators/isImmutable");
var _isLet = require("./validators/isLet");
var _isNode = require("./validators/isNode");
var _isNodesEquivalent = require("./validators/isNodesEquivalent");
var _isPlaceholderType = require("./validators/isPlaceholderType");
var _isReferenced = require("./validators/isReferenced");
var _isScope = require("./validators/isScope");
var _isSpecifierDefault = require("./validators/isSpecifierDefault");
var _isType = require("./validators/isType");
var _isValidES3Identifier = require("./validators/isValidES3Identifier");
var _isValidIdentifier = require("./validators/isValidIdentifier");
var _isVar = require("./validators/isVar");
var _matchesPattern = require("./validators/matchesPattern");
var _validate = require("./validators/validate");
var _buildMatchMemberExpression = require("./validators/buildMatchMemberExpression");
var _generated4 = require("./validators/generated");
Object.keys(_generated4).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated4[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated4[key];
        }
    });
});
var _generated5 = require("./ast-types/generated");
Object.keys(_generated5).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated5[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated5[key];
        }
    });
});
const react = {
    isReactComponent: _isReactComponent.default,
    isCompatTag: _isCompatTag.default,
    buildChildren: _buildChildren.default
};
exports.react = react;

},{"./validators/react/isReactComponent":"6EqVf","./validators/react/isCompatTag":"grP5R","./builders/react/buildChildren":"gWlhX","./asserts/assertNode":"g6xvm","./asserts/generated":"dh9Dr","./builders/flow/createTypeAnnotationBasedOnTypeof":"8aSMk","./builders/flow/createFlowUnionType":"5T1it","./builders/typescript/createTSUnionType":"5F1Xy","./builders/generated":"hCpMg","./builders/generated/uppercase":"btwPm","./clone/cloneNode":"drsCY","./clone/clone":"eaYGs","./clone/cloneDeep":"c8KjF","./clone/cloneDeepWithoutLoc":"Samcq","./clone/cloneWithoutLoc":"1akix","./comments/addComment":"i4fvF","./comments/addComments":"fYJ72","./comments/inheritInnerComments":"fKVCQ","./comments/inheritLeadingComments":"dw9pq","./comments/inheritsComments":"kEqtV","./comments/inheritTrailingComments":"anJMN","./comments/removeComments":"9zkYM","./constants/generated":"7tbeC","./constants":"b9TVI","./converters/ensureBlock":"80Ciq","./converters/toBindingIdentifierName":"ikqrZ","./converters/toBlock":"grhkK","./converters/toComputedKey":"6AJwm","./converters/toExpression":"eVb1C","./converters/toIdentifier":"7Gjjf","./converters/toKeyAlias":"dMc5N","./converters/toSequenceExpression":"6FiDO","./converters/toStatement":"a4mOK","./converters/valueToNode":"6CbNq","./definitions":"iA9Wj","./modifications/appendToMemberExpression":"9rhZT","./modifications/inherits":"iyQwr","./modifications/prependToMemberExpression":"k3tfB","./modifications/removeProperties":"iofQP","./modifications/removePropertiesDeep":"1fNiX","./modifications/flow/removeTypeDuplicates":"a8UyD","./retrievers/getBindingIdentifiers":"hcSqe","./retrievers/getOuterBindingIdentifiers":"3gUiO","./traverse/traverse":"jZKDK","./traverse/traverseFast":"4e3QR","./utils/shallowEqual":"89xXy","./validators/is":"bRiMB","./validators/isBinding":"lUdA1","./validators/isBlockScoped":"4yEks","./validators/isImmutable":"kFXB2","./validators/isLet":"d9OPw","./validators/isNode":"83tOM","./validators/isNodesEquivalent":"jO6jz","./validators/isPlaceholderType":"2ARSw","./validators/isReferenced":"abhPI","./validators/isScope":"gaHb8","./validators/isSpecifierDefault":"bSRM1","./validators/isType":"7Y6bU","./validators/isValidES3Identifier":"e9B0e","./validators/isValidIdentifier":"aPv9j","./validators/isVar":"d3p3m","./validators/matchesPattern":"eFG7p","./validators/validate":"5Y4H9","./validators/buildMatchMemberExpression":"ggy1e","./validators/generated":"4WRSt","./ast-types/generated":"cFoYG"}],"6EqVf":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _buildMatchMemberExpression = require("../buildMatchMemberExpression");
const isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
var _default = isReactComponent;
exports.default = _default;

},{"../buildMatchMemberExpression":"ggy1e"}],"ggy1e":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = buildMatchMemberExpression;
var _matchesPattern = require("./matchesPattern");
function buildMatchMemberExpression(match, allowPartial) {
    const parts = match.split(".");
    return (member)=>(0, _matchesPattern.default)(member, parts, allowPartial)
    ;
}

},{"./matchesPattern":"eFG7p"}],"eFG7p":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = matchesPattern;
var _generated = require("./generated");
function matchesPattern(member, match, allowPartial) {
    if (!(0, _generated.isMemberExpression)(member)) return false;
    const parts = Array.isArray(match) ? match : match.split(".");
    const nodes = [];
    let node;
    for(node = member; (0, _generated.isMemberExpression)(node); node = node.object)nodes.push(node.property);
    nodes.push(node);
    if (nodes.length < parts.length) return false;
    if (!allowPartial && nodes.length > parts.length) return false;
    for(let i = 0, j = nodes.length - 1; i < parts.length; i++, j--){
        const node = nodes[j];
        let value;
        if ((0, _generated.isIdentifier)(node)) value = node.name;
        else if ((0, _generated.isStringLiteral)(node)) value = node.value;
        else if ((0, _generated.isThisExpression)(node)) value = "this";
        else return false;
        if (parts[i] !== value) return false;
    }
    return true;
}

},{"./generated":"4WRSt"}],"4WRSt":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
exports.isArgumentPlaceholder = isArgumentPlaceholder;
exports.isArrayExpression = isArrayExpression;
exports.isArrayPattern = isArrayPattern;
exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
exports.isArrowFunctionExpression = isArrowFunctionExpression;
exports.isAssignmentExpression = isAssignmentExpression;
exports.isAssignmentPattern = isAssignmentPattern;
exports.isAwaitExpression = isAwaitExpression;
exports.isBigIntLiteral = isBigIntLiteral;
exports.isBinary = isBinary;
exports.isBinaryExpression = isBinaryExpression;
exports.isBindExpression = isBindExpression;
exports.isBlock = isBlock;
exports.isBlockParent = isBlockParent;
exports.isBlockStatement = isBlockStatement;
exports.isBooleanLiteral = isBooleanLiteral;
exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
exports.isBreakStatement = isBreakStatement;
exports.isCallExpression = isCallExpression;
exports.isCatchClause = isCatchClause;
exports.isClass = isClass;
exports.isClassBody = isClassBody;
exports.isClassDeclaration = isClassDeclaration;
exports.isClassExpression = isClassExpression;
exports.isClassImplements = isClassImplements;
exports.isClassMethod = isClassMethod;
exports.isClassPrivateMethod = isClassPrivateMethod;
exports.isClassPrivateProperty = isClassPrivateProperty;
exports.isClassProperty = isClassProperty;
exports.isCompletionStatement = isCompletionStatement;
exports.isConditional = isConditional;
exports.isConditionalExpression = isConditionalExpression;
exports.isContinueStatement = isContinueStatement;
exports.isDebuggerStatement = isDebuggerStatement;
exports.isDecimalLiteral = isDecimalLiteral;
exports.isDeclaration = isDeclaration;
exports.isDeclareClass = isDeclareClass;
exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
exports.isDeclareFunction = isDeclareFunction;
exports.isDeclareInterface = isDeclareInterface;
exports.isDeclareModule = isDeclareModule;
exports.isDeclareModuleExports = isDeclareModuleExports;
exports.isDeclareOpaqueType = isDeclareOpaqueType;
exports.isDeclareTypeAlias = isDeclareTypeAlias;
exports.isDeclareVariable = isDeclareVariable;
exports.isDeclaredPredicate = isDeclaredPredicate;
exports.isDecorator = isDecorator;
exports.isDirective = isDirective;
exports.isDirectiveLiteral = isDirectiveLiteral;
exports.isDoExpression = isDoExpression;
exports.isDoWhileStatement = isDoWhileStatement;
exports.isEmptyStatement = isEmptyStatement;
exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
exports.isEnumBody = isEnumBody;
exports.isEnumBooleanBody = isEnumBooleanBody;
exports.isEnumBooleanMember = isEnumBooleanMember;
exports.isEnumDeclaration = isEnumDeclaration;
exports.isEnumDefaultedMember = isEnumDefaultedMember;
exports.isEnumMember = isEnumMember;
exports.isEnumNumberBody = isEnumNumberBody;
exports.isEnumNumberMember = isEnumNumberMember;
exports.isEnumStringBody = isEnumStringBody;
exports.isEnumStringMember = isEnumStringMember;
exports.isEnumSymbolBody = isEnumSymbolBody;
exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
exports.isExportAllDeclaration = isExportAllDeclaration;
exports.isExportDeclaration = isExportDeclaration;
exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
exports.isExportNamedDeclaration = isExportNamedDeclaration;
exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
exports.isExportSpecifier = isExportSpecifier;
exports.isExpression = isExpression;
exports.isExpressionStatement = isExpressionStatement;
exports.isExpressionWrapper = isExpressionWrapper;
exports.isFile = isFile;
exports.isFlow = isFlow;
exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
exports.isFlowDeclaration = isFlowDeclaration;
exports.isFlowPredicate = isFlowPredicate;
exports.isFlowType = isFlowType;
exports.isFor = isFor;
exports.isForInStatement = isForInStatement;
exports.isForOfStatement = isForOfStatement;
exports.isForStatement = isForStatement;
exports.isForXStatement = isForXStatement;
exports.isFunction = isFunction;
exports.isFunctionDeclaration = isFunctionDeclaration;
exports.isFunctionExpression = isFunctionExpression;
exports.isFunctionParent = isFunctionParent;
exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
exports.isFunctionTypeParam = isFunctionTypeParam;
exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
exports.isIdentifier = isIdentifier;
exports.isIfStatement = isIfStatement;
exports.isImmutable = isImmutable;
exports.isImport = isImport;
exports.isImportAttribute = isImportAttribute;
exports.isImportDeclaration = isImportDeclaration;
exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
exports.isImportSpecifier = isImportSpecifier;
exports.isIndexedAccessType = isIndexedAccessType;
exports.isInferredPredicate = isInferredPredicate;
exports.isInterfaceDeclaration = isInterfaceDeclaration;
exports.isInterfaceExtends = isInterfaceExtends;
exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
exports.isInterpreterDirective = isInterpreterDirective;
exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
exports.isJSX = isJSX;
exports.isJSXAttribute = isJSXAttribute;
exports.isJSXClosingElement = isJSXClosingElement;
exports.isJSXClosingFragment = isJSXClosingFragment;
exports.isJSXElement = isJSXElement;
exports.isJSXEmptyExpression = isJSXEmptyExpression;
exports.isJSXExpressionContainer = isJSXExpressionContainer;
exports.isJSXFragment = isJSXFragment;
exports.isJSXIdentifier = isJSXIdentifier;
exports.isJSXMemberExpression = isJSXMemberExpression;
exports.isJSXNamespacedName = isJSXNamespacedName;
exports.isJSXOpeningElement = isJSXOpeningElement;
exports.isJSXOpeningFragment = isJSXOpeningFragment;
exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
exports.isJSXSpreadChild = isJSXSpreadChild;
exports.isJSXText = isJSXText;
exports.isLVal = isLVal;
exports.isLabeledStatement = isLabeledStatement;
exports.isLiteral = isLiteral;
exports.isLogicalExpression = isLogicalExpression;
exports.isLoop = isLoop;
exports.isMemberExpression = isMemberExpression;
exports.isMetaProperty = isMetaProperty;
exports.isMethod = isMethod;
exports.isMiscellaneous = isMiscellaneous;
exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
exports.isModuleDeclaration = isModuleDeclaration;
exports.isModuleExpression = isModuleExpression;
exports.isModuleSpecifier = isModuleSpecifier;
exports.isNewExpression = isNewExpression;
exports.isNoop = isNoop;
exports.isNullLiteral = isNullLiteral;
exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
exports.isNumberLiteral = isNumberLiteral;
exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
exports.isNumericLiteral = isNumericLiteral;
exports.isObjectExpression = isObjectExpression;
exports.isObjectMember = isObjectMember;
exports.isObjectMethod = isObjectMethod;
exports.isObjectPattern = isObjectPattern;
exports.isObjectProperty = isObjectProperty;
exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
exports.isObjectTypeIndexer = isObjectTypeIndexer;
exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
exports.isObjectTypeProperty = isObjectTypeProperty;
exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
exports.isOpaqueType = isOpaqueType;
exports.isOptionalCallExpression = isOptionalCallExpression;
exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
exports.isOptionalMemberExpression = isOptionalMemberExpression;
exports.isParenthesizedExpression = isParenthesizedExpression;
exports.isPattern = isPattern;
exports.isPatternLike = isPatternLike;
exports.isPipelineBareFunction = isPipelineBareFunction;
exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
exports.isPipelineTopicExpression = isPipelineTopicExpression;
exports.isPlaceholder = isPlaceholder;
exports.isPrivate = isPrivate;
exports.isPrivateName = isPrivateName;
exports.isProgram = isProgram;
exports.isProperty = isProperty;
exports.isPureish = isPureish;
exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
exports.isRecordExpression = isRecordExpression;
exports.isRegExpLiteral = isRegExpLiteral;
exports.isRegexLiteral = isRegexLiteral;
exports.isRestElement = isRestElement;
exports.isRestProperty = isRestProperty;
exports.isReturnStatement = isReturnStatement;
exports.isScopable = isScopable;
exports.isSequenceExpression = isSequenceExpression;
exports.isSpreadElement = isSpreadElement;
exports.isSpreadProperty = isSpreadProperty;
exports.isStandardized = isStandardized;
exports.isStatement = isStatement;
exports.isStaticBlock = isStaticBlock;
exports.isStringLiteral = isStringLiteral;
exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
exports.isStringTypeAnnotation = isStringTypeAnnotation;
exports.isSuper = isSuper;
exports.isSwitchCase = isSwitchCase;
exports.isSwitchStatement = isSwitchStatement;
exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
exports.isTSAnyKeyword = isTSAnyKeyword;
exports.isTSArrayType = isTSArrayType;
exports.isTSAsExpression = isTSAsExpression;
exports.isTSBaseType = isTSBaseType;
exports.isTSBigIntKeyword = isTSBigIntKeyword;
exports.isTSBooleanKeyword = isTSBooleanKeyword;
exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
exports.isTSConditionalType = isTSConditionalType;
exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
exports.isTSConstructorType = isTSConstructorType;
exports.isTSDeclareFunction = isTSDeclareFunction;
exports.isTSDeclareMethod = isTSDeclareMethod;
exports.isTSEntityName = isTSEntityName;
exports.isTSEnumDeclaration = isTSEnumDeclaration;
exports.isTSEnumMember = isTSEnumMember;
exports.isTSExportAssignment = isTSExportAssignment;
exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
exports.isTSExternalModuleReference = isTSExternalModuleReference;
exports.isTSFunctionType = isTSFunctionType;
exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
exports.isTSImportType = isTSImportType;
exports.isTSIndexSignature = isTSIndexSignature;
exports.isTSIndexedAccessType = isTSIndexedAccessType;
exports.isTSInferType = isTSInferType;
exports.isTSInterfaceBody = isTSInterfaceBody;
exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
exports.isTSIntersectionType = isTSIntersectionType;
exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
exports.isTSLiteralType = isTSLiteralType;
exports.isTSMappedType = isTSMappedType;
exports.isTSMethodSignature = isTSMethodSignature;
exports.isTSModuleBlock = isTSModuleBlock;
exports.isTSModuleDeclaration = isTSModuleDeclaration;
exports.isTSNamedTupleMember = isTSNamedTupleMember;
exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
exports.isTSNeverKeyword = isTSNeverKeyword;
exports.isTSNonNullExpression = isTSNonNullExpression;
exports.isTSNullKeyword = isTSNullKeyword;
exports.isTSNumberKeyword = isTSNumberKeyword;
exports.isTSObjectKeyword = isTSObjectKeyword;
exports.isTSOptionalType = isTSOptionalType;
exports.isTSParameterProperty = isTSParameterProperty;
exports.isTSParenthesizedType = isTSParenthesizedType;
exports.isTSPropertySignature = isTSPropertySignature;
exports.isTSQualifiedName = isTSQualifiedName;
exports.isTSRestType = isTSRestType;
exports.isTSStringKeyword = isTSStringKeyword;
exports.isTSSymbolKeyword = isTSSymbolKeyword;
exports.isTSThisType = isTSThisType;
exports.isTSTupleType = isTSTupleType;
exports.isTSType = isTSType;
exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
exports.isTSTypeAnnotation = isTSTypeAnnotation;
exports.isTSTypeAssertion = isTSTypeAssertion;
exports.isTSTypeElement = isTSTypeElement;
exports.isTSTypeLiteral = isTSTypeLiteral;
exports.isTSTypeOperator = isTSTypeOperator;
exports.isTSTypeParameter = isTSTypeParameter;
exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
exports.isTSTypePredicate = isTSTypePredicate;
exports.isTSTypeQuery = isTSTypeQuery;
exports.isTSTypeReference = isTSTypeReference;
exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
exports.isTSUnionType = isTSUnionType;
exports.isTSUnknownKeyword = isTSUnknownKeyword;
exports.isTSVoidKeyword = isTSVoidKeyword;
exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
exports.isTemplateElement = isTemplateElement;
exports.isTemplateLiteral = isTemplateLiteral;
exports.isTerminatorless = isTerminatorless;
exports.isThisExpression = isThisExpression;
exports.isThisTypeAnnotation = isThisTypeAnnotation;
exports.isThrowStatement = isThrowStatement;
exports.isTopicReference = isTopicReference;
exports.isTryStatement = isTryStatement;
exports.isTupleExpression = isTupleExpression;
exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
exports.isTypeAlias = isTypeAlias;
exports.isTypeAnnotation = isTypeAnnotation;
exports.isTypeCastExpression = isTypeCastExpression;
exports.isTypeParameter = isTypeParameter;
exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
exports.isTypeScript = isTypeScript;
exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
exports.isUnaryExpression = isUnaryExpression;
exports.isUnaryLike = isUnaryLike;
exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
exports.isUpdateExpression = isUpdateExpression;
exports.isUserWhitespacable = isUserWhitespacable;
exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
exports.isVariableDeclaration = isVariableDeclaration;
exports.isVariableDeclarator = isVariableDeclarator;
exports.isVariance = isVariance;
exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
exports.isWhile = isWhile;
exports.isWhileStatement = isWhileStatement;
exports.isWithStatement = isWithStatement;
exports.isYieldExpression = isYieldExpression;
var _shallowEqual = require("../../utils/shallowEqual");
function isArrayExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArrayExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isAssignmentExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "AssignmentExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBinaryExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BinaryExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isInterpreterDirective(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InterpreterDirective") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDirective(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Directive") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDirectiveLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DirectiveLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBlockStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BlockStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBreakStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BreakStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isCallExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "CallExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isCatchClause(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "CatchClause") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isConditionalExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ConditionalExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isContinueStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ContinueStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDebuggerStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DebuggerStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDoWhileStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DoWhileStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEmptyStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EmptyStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExpressionStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExpressionStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFile(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "File") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isForInStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ForInStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isForStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ForStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunctionDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "FunctionDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunctionExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "FunctionExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Identifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isIfStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "IfStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isLabeledStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "LabeledStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStringLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "StringLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNumericLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NumericLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNullLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NullLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBooleanLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BooleanLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isRegExpLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RegExpLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isLogicalExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "LogicalExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "MemberExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNewExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NewExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isProgram(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Program") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectMethod") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isRestElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RestElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isReturnStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ReturnStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSequenceExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SequenceExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isParenthesizedExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ParenthesizedExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSwitchCase(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SwitchCase") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSwitchStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SwitchStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isThisExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ThisExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isThrowStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ThrowStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTryStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TryStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isUnaryExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "UnaryExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isUpdateExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "UpdateExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isVariableDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "VariableDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isVariableDeclarator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "VariableDeclarator") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isWhileStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "WhileStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isWithStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "WithStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isAssignmentPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "AssignmentPattern") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isArrayPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArrayPattern") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isArrowFunctionExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArrowFunctionExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportAllDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportAllDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportDefaultDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportDefaultDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportNamedDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportNamedDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isForOfStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ForOfStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImportDefaultSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportDefaultSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportNamespaceSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImportSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isMetaProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "MetaProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassMethod") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectPattern") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSpreadElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SpreadElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSuper(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Super") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTaggedTemplateExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TaggedTemplateExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTemplateElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TemplateElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTemplateLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TemplateLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isYieldExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "YieldExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isAwaitExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "AwaitExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImport(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Import") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBigIntLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BigIntLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportNamespaceSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isOptionalMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "OptionalMemberExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isOptionalCallExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "OptionalCallExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassPrivateProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassPrivateProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassPrivateMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassPrivateMethod") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPrivateName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "PrivateName") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStaticBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "StaticBlock") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isAnyTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "AnyTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isArrayTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArrayTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBooleanTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BooleanTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBooleanLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BooleanLiteralTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNullLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NullLiteralTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassImplements(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassImplements") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareClass(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareClass") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareFunction") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareInterface(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareInterface") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareModule(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareModule") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareModuleExports(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareModuleExports") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareTypeAlias(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareTypeAlias") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareOpaqueType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareOpaqueType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareVariable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareVariable") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareExportDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareExportAllDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareExportAllDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclaredPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclaredPredicate") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExistsTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExistsTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunctionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "FunctionTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunctionTypeParam(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "FunctionTypeParam") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isGenericTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "GenericTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isInferredPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InferredPredicate") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isInterfaceExtends(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InterfaceExtends") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isInterfaceDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InterfaceDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isInterfaceTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InterfaceTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isIntersectionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "IntersectionTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isMixedTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "MixedTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEmptyTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EmptyTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNullableTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NullableTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNumberLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NumberLiteralTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNumberTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NumberTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeInternalSlot(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeInternalSlot") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeCallProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeCallProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeIndexer(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeIndexer") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeSpreadProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeSpreadProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isOpaqueType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "OpaqueType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isQualifiedTypeIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "QualifiedTypeIdentifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStringLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "StringLiteralTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStringTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "StringTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSymbolTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SymbolTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isThisTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ThisTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTupleTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TupleTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeofTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeofTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeAlias(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeAlias") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeCastExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeCastExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeParameter(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeParameter") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeParameterDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeParameterInstantiation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isUnionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "UnionTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isVariance(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Variance") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isVoidTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "VoidTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumBooleanBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumBooleanBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumNumberBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumNumberBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumStringBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumStringBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumSymbolBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumSymbolBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumBooleanMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumBooleanMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumNumberMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumNumberMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumStringMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumStringMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumDefaultedMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumDefaultedMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isIndexedAccessType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "IndexedAccessType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isOptionalIndexedAccessType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "OptionalIndexedAccessType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXAttribute") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXClosingElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXClosingElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXEmptyExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXEmptyExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXExpressionContainer(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXExpressionContainer") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXSpreadChild(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXSpreadChild") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXIdentifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXMemberExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXNamespacedName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXNamespacedName") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXOpeningElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXOpeningElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXSpreadAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXSpreadAttribute") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXText(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXText") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXFragment") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXOpeningFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXOpeningFragment") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXClosingFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXClosingFragment") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNoop(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Noop") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPlaceholder(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Placeholder") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isV8IntrinsicIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "V8IntrinsicIdentifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isArgumentPlaceholder(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArgumentPlaceholder") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBindExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BindExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImportAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportAttribute") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDecorator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Decorator") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDoExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DoExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportDefaultSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportDefaultSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isRecordExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RecordExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTupleExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TupleExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDecimalLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DecimalLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isModuleExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ModuleExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTopicReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TopicReference") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPipelineTopicExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "PipelineTopicExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPipelineBareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "PipelineBareFunction") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPipelinePrimaryTopicReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "PipelinePrimaryTopicReference") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSParameterProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSParameterProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSDeclareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSDeclareFunction") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSDeclareMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSDeclareMethod") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSQualifiedName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSQualifiedName") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSCallSignatureDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSCallSignatureDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSConstructSignatureDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSConstructSignatureDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSPropertySignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSPropertySignature") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSMethodSignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSMethodSignature") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSIndexSignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSIndexSignature") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSAnyKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSAnyKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSBooleanKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSBooleanKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSBigIntKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSBigIntKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSIntrinsicKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSIntrinsicKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNeverKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNeverKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNullKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNullKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNumberKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNumberKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSObjectKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSObjectKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSStringKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSStringKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSSymbolKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSSymbolKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSUndefinedKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSUndefinedKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSUnknownKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSUnknownKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSVoidKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSVoidKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSThisType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSThisType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSFunctionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSFunctionType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSConstructorType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSConstructorType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeReference") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypePredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypePredicate") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeQuery(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeQuery") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSArrayType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSArrayType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTupleType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTupleType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSOptionalType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSOptionalType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSRestType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSRestType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNamedTupleMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNamedTupleMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSUnionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSUnionType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSIntersectionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSIntersectionType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSConditionalType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSConditionalType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSInferType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSInferType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSParenthesizedType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSParenthesizedType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeOperator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeOperator") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSIndexedAccessType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSIndexedAccessType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSMappedType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSMappedType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSLiteralType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSLiteralType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSExpressionWithTypeArguments(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSExpressionWithTypeArguments") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSInterfaceDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSInterfaceDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSInterfaceBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSInterfaceBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeAliasDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeAliasDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSAsExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSAsExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeAssertion(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeAssertion") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSEnumDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSEnumDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSEnumMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSEnumMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSModuleDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSModuleDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSModuleBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSModuleBlock") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSImportType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSImportType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSImportEqualsDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSImportEqualsDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSExternalModuleReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSExternalModuleReference") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNonNullExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNonNullExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSExportAssignment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSExportAssignment") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNamespaceExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNamespaceExportDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeParameterInstantiation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeParameterDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeParameter(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeParameter") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStandardized(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "InterpreterDirective" === nodeType || "Directive" === nodeType || "DirectiveLiteral" === nodeType || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "CallExpression" === nodeType || "CatchClause" === nodeType || "ConditionalExpression" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "File" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "Program" === nodeType || "ObjectExpression" === nodeType || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "RestElement" === nodeType || "ReturnStatement" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "SwitchCase" === nodeType || "SwitchStatement" === nodeType || "ThisExpression" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "VariableDeclaration" === nodeType || "VariableDeclarator" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassBody" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ExportSpecifier" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "MetaProperty" === nodeType || "ClassMethod" === nodeType || "ObjectPattern" === nodeType || "SpreadElement" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateElement" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "ExportNamespaceSpecifier" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType || "StaticBlock" === nodeType || nodeType === "Placeholder" && ("Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode || "BlockStatement" === node.expectedNode || "ClassBody" === node.expectedNode)) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "BindExpression" === nodeType || "DoExpression" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "DecimalLiteral" === nodeType || "ModuleExpression" === nodeType || "TopicReference" === nodeType || "PipelineTopicExpression" === nodeType || "PipelineBareFunction" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBinary(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isScopable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBlockParent(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTerminatorless(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isCompletionStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isConditional(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isLoop(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isWhile(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExpressionWrapper(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFor(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isForXStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunctionParent(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPureish(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPatternLike(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isLVal(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSEntityName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImmutable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "BigIntLiteral" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXOpeningElement" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isUserWhitespacable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isUnaryLike(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClass(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isModuleDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isModuleSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPrivate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFlow(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType || "EnumDeclaration" === nodeType || "EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType || "EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFlowType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFlowBaseAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFlowDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFlowPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSX(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isMiscellaneous(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("Noop" === nodeType || "Placeholder" === nodeType || "V8IntrinsicIdentifier" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeScript(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("TSParameterProperty" === nodeType || "TSDeclareFunction" === nodeType || "TSDeclareMethod" === nodeType || "TSQualifiedName" === nodeType || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSNamedTupleMember" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSInterfaceBody" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSEnumDeclaration" === nodeType || "TSEnumMember" === nodeType || "TSModuleDeclaration" === nodeType || "TSModuleBlock" === nodeType || "TSImportType" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExternalModuleReference" === nodeType || "TSNonNullExpression" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || "TSTypeAnnotation" === nodeType || "TSTypeParameterInstantiation" === nodeType || "TSTypeParameterDeclaration" === nodeType || "TSTypeParameter" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSBaseType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNumberLiteral(node, opts) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NumberLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isRegexLiteral(node, opts) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RegexLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isRestProperty(node, opts) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RestProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSpreadProperty(node, opts) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SpreadProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}

},{"../../utils/shallowEqual":"89xXy"}],"89xXy":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = shallowEqual;
function shallowEqual(actual, expected) {
    const keys = Object.keys(expected);
    for (const key of keys){
        if (actual[key] !== expected[key]) return false;
    }
    return true;
}

},{}],"grP5R":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isCompatTag;
function isCompatTag(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
}

},{}],"gWlhX":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = buildChildren;
var _generated = require("../../validators/generated");
var _cleanJSXElementLiteralChild = require("../../utils/react/cleanJSXElementLiteralChild");
function buildChildren(node) {
    const elements = [];
    for(let i = 0; i < node.children.length; i++){
        let child = node.children[i];
        if ((0, _generated.isJSXText)(child)) {
            (0, _cleanJSXElementLiteralChild.default)(child, elements);
            continue;
        }
        if ((0, _generated.isJSXExpressionContainer)(child)) child = child.expression;
        if ((0, _generated.isJSXEmptyExpression)(child)) continue;
        elements.push(child);
    }
    return elements;
}

},{"../../validators/generated":"4WRSt","../../utils/react/cleanJSXElementLiteralChild":"4K3vX"}],"4K3vX":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cleanJSXElementLiteralChild;
var _generated = require("../../builders/generated");
function cleanJSXElementLiteralChild(child, args) {
    const lines = child.value.split(/\r\n|\n|\r/);
    let lastNonEmptyLine = 0;
    for(let i = 0; i < lines.length; i++)if (lines[i].match(/[^ \t]/)) lastNonEmptyLine = i;
    let str = "";
    for(let i1 = 0; i1 < lines.length; i1++){
        const line = lines[i1];
        const isFirstLine = i1 === 0;
        const isLastLine = i1 === lines.length - 1;
        const isLastNonEmptyLine = i1 === lastNonEmptyLine;
        let trimmedLine = line.replace(/\t/g, " ");
        if (!isFirstLine) trimmedLine = trimmedLine.replace(/^[ ]+/, "");
        if (!isLastLine) trimmedLine = trimmedLine.replace(/[ ]+$/, "");
        if (trimmedLine) {
            if (!isLastNonEmptyLine) trimmedLine += " ";
            str += trimmedLine;
        }
    }
    if (str) args.push((0, _generated.stringLiteral)(str));
}

},{"../../builders/generated":"hCpMg"}],"hCpMg":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.anyTypeAnnotation = anyTypeAnnotation;
exports.argumentPlaceholder = argumentPlaceholder;
exports.arrayExpression = arrayExpression;
exports.arrayPattern = arrayPattern;
exports.arrayTypeAnnotation = arrayTypeAnnotation;
exports.arrowFunctionExpression = arrowFunctionExpression;
exports.assignmentExpression = assignmentExpression;
exports.assignmentPattern = assignmentPattern;
exports.awaitExpression = awaitExpression;
exports.bigIntLiteral = bigIntLiteral;
exports.binaryExpression = binaryExpression;
exports.bindExpression = bindExpression;
exports.blockStatement = blockStatement;
exports.booleanLiteral = booleanLiteral;
exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
exports.booleanTypeAnnotation = booleanTypeAnnotation;
exports.breakStatement = breakStatement;
exports.callExpression = callExpression;
exports.catchClause = catchClause;
exports.classBody = classBody;
exports.classDeclaration = classDeclaration;
exports.classExpression = classExpression;
exports.classImplements = classImplements;
exports.classMethod = classMethod;
exports.classPrivateMethod = classPrivateMethod;
exports.classPrivateProperty = classPrivateProperty;
exports.classProperty = classProperty;
exports.conditionalExpression = conditionalExpression;
exports.continueStatement = continueStatement;
exports.debuggerStatement = debuggerStatement;
exports.decimalLiteral = decimalLiteral;
exports.declareClass = declareClass;
exports.declareExportAllDeclaration = declareExportAllDeclaration;
exports.declareExportDeclaration = declareExportDeclaration;
exports.declareFunction = declareFunction;
exports.declareInterface = declareInterface;
exports.declareModule = declareModule;
exports.declareModuleExports = declareModuleExports;
exports.declareOpaqueType = declareOpaqueType;
exports.declareTypeAlias = declareTypeAlias;
exports.declareVariable = declareVariable;
exports.declaredPredicate = declaredPredicate;
exports.decorator = decorator;
exports.directive = directive;
exports.directiveLiteral = directiveLiteral;
exports.doExpression = doExpression;
exports.doWhileStatement = doWhileStatement;
exports.emptyStatement = emptyStatement;
exports.emptyTypeAnnotation = emptyTypeAnnotation;
exports.enumBooleanBody = enumBooleanBody;
exports.enumBooleanMember = enumBooleanMember;
exports.enumDeclaration = enumDeclaration;
exports.enumDefaultedMember = enumDefaultedMember;
exports.enumNumberBody = enumNumberBody;
exports.enumNumberMember = enumNumberMember;
exports.enumStringBody = enumStringBody;
exports.enumStringMember = enumStringMember;
exports.enumSymbolBody = enumSymbolBody;
exports.existsTypeAnnotation = existsTypeAnnotation;
exports.exportAllDeclaration = exportAllDeclaration;
exports.exportDefaultDeclaration = exportDefaultDeclaration;
exports.exportDefaultSpecifier = exportDefaultSpecifier;
exports.exportNamedDeclaration = exportNamedDeclaration;
exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
exports.exportSpecifier = exportSpecifier;
exports.expressionStatement = expressionStatement;
exports.file = file;
exports.forInStatement = forInStatement;
exports.forOfStatement = forOfStatement;
exports.forStatement = forStatement;
exports.functionDeclaration = functionDeclaration;
exports.functionExpression = functionExpression;
exports.functionTypeAnnotation = functionTypeAnnotation;
exports.functionTypeParam = functionTypeParam;
exports.genericTypeAnnotation = genericTypeAnnotation;
exports.identifier = identifier;
exports.ifStatement = ifStatement;
exports.import = _import;
exports.importAttribute = importAttribute;
exports.importDeclaration = importDeclaration;
exports.importDefaultSpecifier = importDefaultSpecifier;
exports.importNamespaceSpecifier = importNamespaceSpecifier;
exports.importSpecifier = importSpecifier;
exports.indexedAccessType = indexedAccessType;
exports.inferredPredicate = inferredPredicate;
exports.interfaceDeclaration = interfaceDeclaration;
exports.interfaceExtends = interfaceExtends;
exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
exports.interpreterDirective = interpreterDirective;
exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
exports.jSXElement = exports.jsxElement = jsxElement;
exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
exports.jSXFragment = exports.jsxFragment = jsxFragment;
exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
exports.jSXText = exports.jsxText = jsxText;
exports.labeledStatement = labeledStatement;
exports.logicalExpression = logicalExpression;
exports.memberExpression = memberExpression;
exports.metaProperty = metaProperty;
exports.mixedTypeAnnotation = mixedTypeAnnotation;
exports.moduleExpression = moduleExpression;
exports.newExpression = newExpression;
exports.noop = noop;
exports.nullLiteral = nullLiteral;
exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
exports.nullableTypeAnnotation = nullableTypeAnnotation;
exports.numberLiteral = NumberLiteral;
exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
exports.numberTypeAnnotation = numberTypeAnnotation;
exports.numericLiteral = numericLiteral;
exports.objectExpression = objectExpression;
exports.objectMethod = objectMethod;
exports.objectPattern = objectPattern;
exports.objectProperty = objectProperty;
exports.objectTypeAnnotation = objectTypeAnnotation;
exports.objectTypeCallProperty = objectTypeCallProperty;
exports.objectTypeIndexer = objectTypeIndexer;
exports.objectTypeInternalSlot = objectTypeInternalSlot;
exports.objectTypeProperty = objectTypeProperty;
exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
exports.opaqueType = opaqueType;
exports.optionalCallExpression = optionalCallExpression;
exports.optionalIndexedAccessType = optionalIndexedAccessType;
exports.optionalMemberExpression = optionalMemberExpression;
exports.parenthesizedExpression = parenthesizedExpression;
exports.pipelineBareFunction = pipelineBareFunction;
exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
exports.pipelineTopicExpression = pipelineTopicExpression;
exports.placeholder = placeholder;
exports.privateName = privateName;
exports.program = program;
exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
exports.recordExpression = recordExpression;
exports.regExpLiteral = regExpLiteral;
exports.regexLiteral = RegexLiteral;
exports.restElement = restElement;
exports.restProperty = RestProperty;
exports.returnStatement = returnStatement;
exports.sequenceExpression = sequenceExpression;
exports.spreadElement = spreadElement;
exports.spreadProperty = SpreadProperty;
exports.staticBlock = staticBlock;
exports.stringLiteral = stringLiteral;
exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
exports.stringTypeAnnotation = stringTypeAnnotation;
exports.super = _super;
exports.switchCase = switchCase;
exports.switchStatement = switchStatement;
exports.symbolTypeAnnotation = symbolTypeAnnotation;
exports.taggedTemplateExpression = taggedTemplateExpression;
exports.templateElement = templateElement;
exports.templateLiteral = templateLiteral;
exports.thisExpression = thisExpression;
exports.thisTypeAnnotation = thisTypeAnnotation;
exports.throwStatement = throwStatement;
exports.topicReference = topicReference;
exports.tryStatement = tryStatement;
exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
exports.tSArrayType = exports.tsArrayType = tsArrayType;
exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
exports.tSImportType = exports.tsImportType = tsImportType;
exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
exports.tSInferType = exports.tsInferType = tsInferType;
exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
exports.tSMappedType = exports.tsMappedType = tsMappedType;
exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
exports.tSRestType = exports.tsRestType = tsRestType;
exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
exports.tSThisType = exports.tsThisType = tsThisType;
exports.tSTupleType = exports.tsTupleType = tsTupleType;
exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
exports.tSUnionType = exports.tsUnionType = tsUnionType;
exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
exports.tupleExpression = tupleExpression;
exports.tupleTypeAnnotation = tupleTypeAnnotation;
exports.typeAlias = typeAlias;
exports.typeAnnotation = typeAnnotation;
exports.typeCastExpression = typeCastExpression;
exports.typeParameter = typeParameter;
exports.typeParameterDeclaration = typeParameterDeclaration;
exports.typeParameterInstantiation = typeParameterInstantiation;
exports.typeofTypeAnnotation = typeofTypeAnnotation;
exports.unaryExpression = unaryExpression;
exports.unionTypeAnnotation = unionTypeAnnotation;
exports.updateExpression = updateExpression;
exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
exports.variableDeclaration = variableDeclaration;
exports.variableDeclarator = variableDeclarator;
exports.variance = variance;
exports.voidTypeAnnotation = voidTypeAnnotation;
exports.whileStatement = whileStatement;
exports.withStatement = withStatement;
exports.yieldExpression = yieldExpression;
var _builder = require("../builder");
function arrayExpression(elements) {
    return _builder.default.apply("ArrayExpression", arguments);
}
function assignmentExpression(operator, left, right) {
    return _builder.default.apply("AssignmentExpression", arguments);
}
function binaryExpression(operator, left, right) {
    return _builder.default.apply("BinaryExpression", arguments);
}
function interpreterDirective(value) {
    return _builder.default.apply("InterpreterDirective", arguments);
}
function directive(value) {
    return _builder.default.apply("Directive", arguments);
}
function directiveLiteral(value) {
    return _builder.default.apply("DirectiveLiteral", arguments);
}
function blockStatement(body, directives) {
    return _builder.default.apply("BlockStatement", arguments);
}
function breakStatement(label) {
    return _builder.default.apply("BreakStatement", arguments);
}
function callExpression(callee, _arguments) {
    return _builder.default.apply("CallExpression", arguments);
}
function catchClause(param, body) {
    return _builder.default.apply("CatchClause", arguments);
}
function conditionalExpression(test, consequent, alternate) {
    return _builder.default.apply("ConditionalExpression", arguments);
}
function continueStatement(label) {
    return _builder.default.apply("ContinueStatement", arguments);
}
function debuggerStatement() {
    return _builder.default.apply("DebuggerStatement", arguments);
}
function doWhileStatement(test, body) {
    return _builder.default.apply("DoWhileStatement", arguments);
}
function emptyStatement() {
    return _builder.default.apply("EmptyStatement", arguments);
}
function expressionStatement(expression) {
    return _builder.default.apply("ExpressionStatement", arguments);
}
function file(program, comments, tokens) {
    return _builder.default.apply("File", arguments);
}
function forInStatement(left, right, body) {
    return _builder.default.apply("ForInStatement", arguments);
}
function forStatement(init, test, update, body) {
    return _builder.default.apply("ForStatement", arguments);
}
function functionDeclaration(id, params, body, generator, async) {
    return _builder.default.apply("FunctionDeclaration", arguments);
}
function functionExpression(id, params, body, generator, async) {
    return _builder.default.apply("FunctionExpression", arguments);
}
function identifier(name) {
    return _builder.default.apply("Identifier", arguments);
}
function ifStatement(test, consequent, alternate) {
    return _builder.default.apply("IfStatement", arguments);
}
function labeledStatement(label, body) {
    return _builder.default.apply("LabeledStatement", arguments);
}
function stringLiteral(value) {
    return _builder.default.apply("StringLiteral", arguments);
}
function numericLiteral(value) {
    return _builder.default.apply("NumericLiteral", arguments);
}
function nullLiteral() {
    return _builder.default.apply("NullLiteral", arguments);
}
function booleanLiteral(value) {
    return _builder.default.apply("BooleanLiteral", arguments);
}
function regExpLiteral(pattern, flags) {
    return _builder.default.apply("RegExpLiteral", arguments);
}
function logicalExpression(operator, left, right) {
    return _builder.default.apply("LogicalExpression", arguments);
}
function memberExpression(object, property, computed, optional) {
    return _builder.default.apply("MemberExpression", arguments);
}
function newExpression(callee, _arguments) {
    return _builder.default.apply("NewExpression", arguments);
}
function program(body, directives, sourceType, interpreter) {
    return _builder.default.apply("Program", arguments);
}
function objectExpression(properties) {
    return _builder.default.apply("ObjectExpression", arguments);
}
function objectMethod(kind, key, params, body, computed, generator, async) {
    return _builder.default.apply("ObjectMethod", arguments);
}
function objectProperty(key, value, computed, shorthand, decorators) {
    return _builder.default.apply("ObjectProperty", arguments);
}
function restElement(argument) {
    return _builder.default.apply("RestElement", arguments);
}
function returnStatement(argument) {
    return _builder.default.apply("ReturnStatement", arguments);
}
function sequenceExpression(expressions) {
    return _builder.default.apply("SequenceExpression", arguments);
}
function parenthesizedExpression(expression) {
    return _builder.default.apply("ParenthesizedExpression", arguments);
}
function switchCase(test, consequent) {
    return _builder.default.apply("SwitchCase", arguments);
}
function switchStatement(discriminant, cases) {
    return _builder.default.apply("SwitchStatement", arguments);
}
function thisExpression() {
    return _builder.default.apply("ThisExpression", arguments);
}
function throwStatement(argument) {
    return _builder.default.apply("ThrowStatement", arguments);
}
function tryStatement(block, handler, finalizer) {
    return _builder.default.apply("TryStatement", arguments);
}
function unaryExpression(operator, argument, prefix) {
    return _builder.default.apply("UnaryExpression", arguments);
}
function updateExpression(operator, argument, prefix) {
    return _builder.default.apply("UpdateExpression", arguments);
}
function variableDeclaration(kind, declarations) {
    return _builder.default.apply("VariableDeclaration", arguments);
}
function variableDeclarator(id, init) {
    return _builder.default.apply("VariableDeclarator", arguments);
}
function whileStatement(test, body) {
    return _builder.default.apply("WhileStatement", arguments);
}
function withStatement(object, body) {
    return _builder.default.apply("WithStatement", arguments);
}
function assignmentPattern(left, right) {
    return _builder.default.apply("AssignmentPattern", arguments);
}
function arrayPattern(elements) {
    return _builder.default.apply("ArrayPattern", arguments);
}
function arrowFunctionExpression(params, body, async) {
    return _builder.default.apply("ArrowFunctionExpression", arguments);
}
function classBody(body) {
    return _builder.default.apply("ClassBody", arguments);
}
function classExpression(id, superClass, body, decorators) {
    return _builder.default.apply("ClassExpression", arguments);
}
function classDeclaration(id, superClass, body, decorators) {
    return _builder.default.apply("ClassDeclaration", arguments);
}
function exportAllDeclaration(source) {
    return _builder.default.apply("ExportAllDeclaration", arguments);
}
function exportDefaultDeclaration(declaration) {
    return _builder.default.apply("ExportDefaultDeclaration", arguments);
}
function exportNamedDeclaration(declaration, specifiers, source) {
    return _builder.default.apply("ExportNamedDeclaration", arguments);
}
function exportSpecifier(local, exported) {
    return _builder.default.apply("ExportSpecifier", arguments);
}
function forOfStatement(left, right, body, _await) {
    return _builder.default.apply("ForOfStatement", arguments);
}
function importDeclaration(specifiers, source) {
    return _builder.default.apply("ImportDeclaration", arguments);
}
function importDefaultSpecifier(local) {
    return _builder.default.apply("ImportDefaultSpecifier", arguments);
}
function importNamespaceSpecifier(local) {
    return _builder.default.apply("ImportNamespaceSpecifier", arguments);
}
function importSpecifier(local, imported) {
    return _builder.default.apply("ImportSpecifier", arguments);
}
function metaProperty(meta, property) {
    return _builder.default.apply("MetaProperty", arguments);
}
function classMethod(kind, key, params, body, computed, _static, generator, async) {
    return _builder.default.apply("ClassMethod", arguments);
}
function objectPattern(properties) {
    return _builder.default.apply("ObjectPattern", arguments);
}
function spreadElement(argument) {
    return _builder.default.apply("SpreadElement", arguments);
}
function _super() {
    return _builder.default.apply("Super", arguments);
}
function taggedTemplateExpression(tag, quasi) {
    return _builder.default.apply("TaggedTemplateExpression", arguments);
}
function templateElement(value, tail) {
    return _builder.default.apply("TemplateElement", arguments);
}
function templateLiteral(quasis, expressions) {
    return _builder.default.apply("TemplateLiteral", arguments);
}
function yieldExpression(argument, delegate) {
    return _builder.default.apply("YieldExpression", arguments);
}
function awaitExpression(argument) {
    return _builder.default.apply("AwaitExpression", arguments);
}
function _import() {
    return _builder.default.apply("Import", arguments);
}
function bigIntLiteral(value) {
    return _builder.default.apply("BigIntLiteral", arguments);
}
function exportNamespaceSpecifier(exported) {
    return _builder.default.apply("ExportNamespaceSpecifier", arguments);
}
function optionalMemberExpression(object, property, computed, optional) {
    return _builder.default.apply("OptionalMemberExpression", arguments);
}
function optionalCallExpression(callee, _arguments, optional) {
    return _builder.default.apply("OptionalCallExpression", arguments);
}
function classProperty(key, value, typeAnnotation, decorators, computed, _static) {
    return _builder.default.apply("ClassProperty", arguments);
}
function classPrivateProperty(key, value, decorators, _static) {
    return _builder.default.apply("ClassPrivateProperty", arguments);
}
function classPrivateMethod(kind, key, params, body, _static) {
    return _builder.default.apply("ClassPrivateMethod", arguments);
}
function privateName(id) {
    return _builder.default.apply("PrivateName", arguments);
}
function staticBlock(body) {
    return _builder.default.apply("StaticBlock", arguments);
}
function anyTypeAnnotation() {
    return _builder.default.apply("AnyTypeAnnotation", arguments);
}
function arrayTypeAnnotation(elementType) {
    return _builder.default.apply("ArrayTypeAnnotation", arguments);
}
function booleanTypeAnnotation() {
    return _builder.default.apply("BooleanTypeAnnotation", arguments);
}
function booleanLiteralTypeAnnotation(value) {
    return _builder.default.apply("BooleanLiteralTypeAnnotation", arguments);
}
function nullLiteralTypeAnnotation() {
    return _builder.default.apply("NullLiteralTypeAnnotation", arguments);
}
function classImplements(id, typeParameters) {
    return _builder.default.apply("ClassImplements", arguments);
}
function declareClass(id, typeParameters, _extends, body) {
    return _builder.default.apply("DeclareClass", arguments);
}
function declareFunction(id) {
    return _builder.default.apply("DeclareFunction", arguments);
}
function declareInterface(id, typeParameters, _extends, body) {
    return _builder.default.apply("DeclareInterface", arguments);
}
function declareModule(id, body, kind) {
    return _builder.default.apply("DeclareModule", arguments);
}
function declareModuleExports(typeAnnotation) {
    return _builder.default.apply("DeclareModuleExports", arguments);
}
function declareTypeAlias(id, typeParameters, right) {
    return _builder.default.apply("DeclareTypeAlias", arguments);
}
function declareOpaqueType(id, typeParameters, supertype) {
    return _builder.default.apply("DeclareOpaqueType", arguments);
}
function declareVariable(id) {
    return _builder.default.apply("DeclareVariable", arguments);
}
function declareExportDeclaration(declaration, specifiers, source) {
    return _builder.default.apply("DeclareExportDeclaration", arguments);
}
function declareExportAllDeclaration(source) {
    return _builder.default.apply("DeclareExportAllDeclaration", arguments);
}
function declaredPredicate(value) {
    return _builder.default.apply("DeclaredPredicate", arguments);
}
function existsTypeAnnotation() {
    return _builder.default.apply("ExistsTypeAnnotation", arguments);
}
function functionTypeAnnotation(typeParameters, params, rest, returnType) {
    return _builder.default.apply("FunctionTypeAnnotation", arguments);
}
function functionTypeParam(name, typeAnnotation) {
    return _builder.default.apply("FunctionTypeParam", arguments);
}
function genericTypeAnnotation(id, typeParameters) {
    return _builder.default.apply("GenericTypeAnnotation", arguments);
}
function inferredPredicate() {
    return _builder.default.apply("InferredPredicate", arguments);
}
function interfaceExtends(id, typeParameters) {
    return _builder.default.apply("InterfaceExtends", arguments);
}
function interfaceDeclaration(id, typeParameters, _extends, body) {
    return _builder.default.apply("InterfaceDeclaration", arguments);
}
function interfaceTypeAnnotation(_extends, body) {
    return _builder.default.apply("InterfaceTypeAnnotation", arguments);
}
function intersectionTypeAnnotation(types) {
    return _builder.default.apply("IntersectionTypeAnnotation", arguments);
}
function mixedTypeAnnotation() {
    return _builder.default.apply("MixedTypeAnnotation", arguments);
}
function emptyTypeAnnotation() {
    return _builder.default.apply("EmptyTypeAnnotation", arguments);
}
function nullableTypeAnnotation(typeAnnotation) {
    return _builder.default.apply("NullableTypeAnnotation", arguments);
}
function numberLiteralTypeAnnotation(value) {
    return _builder.default.apply("NumberLiteralTypeAnnotation", arguments);
}
function numberTypeAnnotation() {
    return _builder.default.apply("NumberTypeAnnotation", arguments);
}
function objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact) {
    return _builder.default.apply("ObjectTypeAnnotation", arguments);
}
function objectTypeInternalSlot(id, value, optional, _static, method) {
    return _builder.default.apply("ObjectTypeInternalSlot", arguments);
}
function objectTypeCallProperty(value) {
    return _builder.default.apply("ObjectTypeCallProperty", arguments);
}
function objectTypeIndexer(id, key, value, variance) {
    return _builder.default.apply("ObjectTypeIndexer", arguments);
}
function objectTypeProperty(key, value, variance) {
    return _builder.default.apply("ObjectTypeProperty", arguments);
}
function objectTypeSpreadProperty(argument) {
    return _builder.default.apply("ObjectTypeSpreadProperty", arguments);
}
function opaqueType(id, typeParameters, supertype, impltype) {
    return _builder.default.apply("OpaqueType", arguments);
}
function qualifiedTypeIdentifier(id, qualification) {
    return _builder.default.apply("QualifiedTypeIdentifier", arguments);
}
function stringLiteralTypeAnnotation(value) {
    return _builder.default.apply("StringLiteralTypeAnnotation", arguments);
}
function stringTypeAnnotation() {
    return _builder.default.apply("StringTypeAnnotation", arguments);
}
function symbolTypeAnnotation() {
    return _builder.default.apply("SymbolTypeAnnotation", arguments);
}
function thisTypeAnnotation() {
    return _builder.default.apply("ThisTypeAnnotation", arguments);
}
function tupleTypeAnnotation(types) {
    return _builder.default.apply("TupleTypeAnnotation", arguments);
}
function typeofTypeAnnotation(argument) {
    return _builder.default.apply("TypeofTypeAnnotation", arguments);
}
function typeAlias(id, typeParameters, right) {
    return _builder.default.apply("TypeAlias", arguments);
}
function typeAnnotation(typeAnnotation) {
    return _builder.default.apply("TypeAnnotation", arguments);
}
function typeCastExpression(expression, typeAnnotation) {
    return _builder.default.apply("TypeCastExpression", arguments);
}
function typeParameter(bound, _default, variance) {
    return _builder.default.apply("TypeParameter", arguments);
}
function typeParameterDeclaration(params) {
    return _builder.default.apply("TypeParameterDeclaration", arguments);
}
function typeParameterInstantiation(params) {
    return _builder.default.apply("TypeParameterInstantiation", arguments);
}
function unionTypeAnnotation(types) {
    return _builder.default.apply("UnionTypeAnnotation", arguments);
}
function variance(kind) {
    return _builder.default.apply("Variance", arguments);
}
function voidTypeAnnotation() {
    return _builder.default.apply("VoidTypeAnnotation", arguments);
}
function enumDeclaration(id, body) {
    return _builder.default.apply("EnumDeclaration", arguments);
}
function enumBooleanBody(members) {
    return _builder.default.apply("EnumBooleanBody", arguments);
}
function enumNumberBody(members) {
    return _builder.default.apply("EnumNumberBody", arguments);
}
function enumStringBody(members) {
    return _builder.default.apply("EnumStringBody", arguments);
}
function enumSymbolBody(members) {
    return _builder.default.apply("EnumSymbolBody", arguments);
}
function enumBooleanMember(id) {
    return _builder.default.apply("EnumBooleanMember", arguments);
}
function enumNumberMember(id, init) {
    return _builder.default.apply("EnumNumberMember", arguments);
}
function enumStringMember(id, init) {
    return _builder.default.apply("EnumStringMember", arguments);
}
function enumDefaultedMember(id) {
    return _builder.default.apply("EnumDefaultedMember", arguments);
}
function indexedAccessType(objectType, indexType) {
    return _builder.default.apply("IndexedAccessType", arguments);
}
function optionalIndexedAccessType(objectType, indexType) {
    return _builder.default.apply("OptionalIndexedAccessType", arguments);
}
function jsxAttribute(name, value) {
    return _builder.default.apply("JSXAttribute", arguments);
}
function jsxClosingElement(name) {
    return _builder.default.apply("JSXClosingElement", arguments);
}
function jsxElement(openingElement, closingElement, children, selfClosing) {
    return _builder.default.apply("JSXElement", arguments);
}
function jsxEmptyExpression() {
    return _builder.default.apply("JSXEmptyExpression", arguments);
}
function jsxExpressionContainer(expression) {
    return _builder.default.apply("JSXExpressionContainer", arguments);
}
function jsxSpreadChild(expression) {
    return _builder.default.apply("JSXSpreadChild", arguments);
}
function jsxIdentifier(name) {
    return _builder.default.apply("JSXIdentifier", arguments);
}
function jsxMemberExpression(object, property) {
    return _builder.default.apply("JSXMemberExpression", arguments);
}
function jsxNamespacedName(namespace, name) {
    return _builder.default.apply("JSXNamespacedName", arguments);
}
function jsxOpeningElement(name, attributes, selfClosing) {
    return _builder.default.apply("JSXOpeningElement", arguments);
}
function jsxSpreadAttribute(argument) {
    return _builder.default.apply("JSXSpreadAttribute", arguments);
}
function jsxText(value) {
    return _builder.default.apply("JSXText", arguments);
}
function jsxFragment(openingFragment, closingFragment, children) {
    return _builder.default.apply("JSXFragment", arguments);
}
function jsxOpeningFragment() {
    return _builder.default.apply("JSXOpeningFragment", arguments);
}
function jsxClosingFragment() {
    return _builder.default.apply("JSXClosingFragment", arguments);
}
function noop() {
    return _builder.default.apply("Noop", arguments);
}
function placeholder(expectedNode, name) {
    return _builder.default.apply("Placeholder", arguments);
}
function v8IntrinsicIdentifier(name) {
    return _builder.default.apply("V8IntrinsicIdentifier", arguments);
}
function argumentPlaceholder() {
    return _builder.default.apply("ArgumentPlaceholder", arguments);
}
function bindExpression(object, callee) {
    return _builder.default.apply("BindExpression", arguments);
}
function importAttribute(key, value) {
    return _builder.default.apply("ImportAttribute", arguments);
}
function decorator(expression) {
    return _builder.default.apply("Decorator", arguments);
}
function doExpression(body, async) {
    return _builder.default.apply("DoExpression", arguments);
}
function exportDefaultSpecifier(exported) {
    return _builder.default.apply("ExportDefaultSpecifier", arguments);
}
function recordExpression(properties) {
    return _builder.default.apply("RecordExpression", arguments);
}
function tupleExpression(elements) {
    return _builder.default.apply("TupleExpression", arguments);
}
function decimalLiteral(value) {
    return _builder.default.apply("DecimalLiteral", arguments);
}
function moduleExpression(body) {
    return _builder.default.apply("ModuleExpression", arguments);
}
function topicReference() {
    return _builder.default.apply("TopicReference", arguments);
}
function pipelineTopicExpression(expression) {
    return _builder.default.apply("PipelineTopicExpression", arguments);
}
function pipelineBareFunction(callee) {
    return _builder.default.apply("PipelineBareFunction", arguments);
}
function pipelinePrimaryTopicReference() {
    return _builder.default.apply("PipelinePrimaryTopicReference", arguments);
}
function tsParameterProperty(parameter) {
    return _builder.default.apply("TSParameterProperty", arguments);
}
function tsDeclareFunction(id, typeParameters, params, returnType) {
    return _builder.default.apply("TSDeclareFunction", arguments);
}
function tsDeclareMethod(decorators, key, typeParameters, params, returnType) {
    return _builder.default.apply("TSDeclareMethod", arguments);
}
function tsQualifiedName(left, right) {
    return _builder.default.apply("TSQualifiedName", arguments);
}
function tsCallSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    return _builder.default.apply("TSCallSignatureDeclaration", arguments);
}
function tsConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    return _builder.default.apply("TSConstructSignatureDeclaration", arguments);
}
function tsPropertySignature(key, typeAnnotation, initializer) {
    return _builder.default.apply("TSPropertySignature", arguments);
}
function tsMethodSignature(key, typeParameters, parameters, typeAnnotation) {
    return _builder.default.apply("TSMethodSignature", arguments);
}
function tsIndexSignature(parameters, typeAnnotation) {
    return _builder.default.apply("TSIndexSignature", arguments);
}
function tsAnyKeyword() {
    return _builder.default.apply("TSAnyKeyword", arguments);
}
function tsBooleanKeyword() {
    return _builder.default.apply("TSBooleanKeyword", arguments);
}
function tsBigIntKeyword() {
    return _builder.default.apply("TSBigIntKeyword", arguments);
}
function tsIntrinsicKeyword() {
    return _builder.default.apply("TSIntrinsicKeyword", arguments);
}
function tsNeverKeyword() {
    return _builder.default.apply("TSNeverKeyword", arguments);
}
function tsNullKeyword() {
    return _builder.default.apply("TSNullKeyword", arguments);
}
function tsNumberKeyword() {
    return _builder.default.apply("TSNumberKeyword", arguments);
}
function tsObjectKeyword() {
    return _builder.default.apply("TSObjectKeyword", arguments);
}
function tsStringKeyword() {
    return _builder.default.apply("TSStringKeyword", arguments);
}
function tsSymbolKeyword() {
    return _builder.default.apply("TSSymbolKeyword", arguments);
}
function tsUndefinedKeyword() {
    return _builder.default.apply("TSUndefinedKeyword", arguments);
}
function tsUnknownKeyword() {
    return _builder.default.apply("TSUnknownKeyword", arguments);
}
function tsVoidKeyword() {
    return _builder.default.apply("TSVoidKeyword", arguments);
}
function tsThisType() {
    return _builder.default.apply("TSThisType", arguments);
}
function tsFunctionType(typeParameters, parameters, typeAnnotation) {
    return _builder.default.apply("TSFunctionType", arguments);
}
function tsConstructorType(typeParameters, parameters, typeAnnotation) {
    return _builder.default.apply("TSConstructorType", arguments);
}
function tsTypeReference(typeName, typeParameters) {
    return _builder.default.apply("TSTypeReference", arguments);
}
function tsTypePredicate(parameterName, typeAnnotation, asserts) {
    return _builder.default.apply("TSTypePredicate", arguments);
}
function tsTypeQuery(exprName) {
    return _builder.default.apply("TSTypeQuery", arguments);
}
function tsTypeLiteral(members) {
    return _builder.default.apply("TSTypeLiteral", arguments);
}
function tsArrayType(elementType) {
    return _builder.default.apply("TSArrayType", arguments);
}
function tsTupleType(elementTypes) {
    return _builder.default.apply("TSTupleType", arguments);
}
function tsOptionalType(typeAnnotation) {
    return _builder.default.apply("TSOptionalType", arguments);
}
function tsRestType(typeAnnotation) {
    return _builder.default.apply("TSRestType", arguments);
}
function tsNamedTupleMember(label, elementType, optional) {
    return _builder.default.apply("TSNamedTupleMember", arguments);
}
function tsUnionType(types) {
    return _builder.default.apply("TSUnionType", arguments);
}
function tsIntersectionType(types) {
    return _builder.default.apply("TSIntersectionType", arguments);
}
function tsConditionalType(checkType, extendsType, trueType, falseType) {
    return _builder.default.apply("TSConditionalType", arguments);
}
function tsInferType(typeParameter) {
    return _builder.default.apply("TSInferType", arguments);
}
function tsParenthesizedType(typeAnnotation) {
    return _builder.default.apply("TSParenthesizedType", arguments);
}
function tsTypeOperator(typeAnnotation) {
    return _builder.default.apply("TSTypeOperator", arguments);
}
function tsIndexedAccessType(objectType, indexType) {
    return _builder.default.apply("TSIndexedAccessType", arguments);
}
function tsMappedType(typeParameter, typeAnnotation, nameType) {
    return _builder.default.apply("TSMappedType", arguments);
}
function tsLiteralType(literal) {
    return _builder.default.apply("TSLiteralType", arguments);
}
function tsExpressionWithTypeArguments(expression, typeParameters) {
    return _builder.default.apply("TSExpressionWithTypeArguments", arguments);
}
function tsInterfaceDeclaration(id, typeParameters, _extends, body) {
    return _builder.default.apply("TSInterfaceDeclaration", arguments);
}
function tsInterfaceBody(body) {
    return _builder.default.apply("TSInterfaceBody", arguments);
}
function tsTypeAliasDeclaration(id, typeParameters, typeAnnotation) {
    return _builder.default.apply("TSTypeAliasDeclaration", arguments);
}
function tsAsExpression(expression, typeAnnotation) {
    return _builder.default.apply("TSAsExpression", arguments);
}
function tsTypeAssertion(typeAnnotation, expression) {
    return _builder.default.apply("TSTypeAssertion", arguments);
}
function tsEnumDeclaration(id, members) {
    return _builder.default.apply("TSEnumDeclaration", arguments);
}
function tsEnumMember(id, initializer) {
    return _builder.default.apply("TSEnumMember", arguments);
}
function tsModuleDeclaration(id, body) {
    return _builder.default.apply("TSModuleDeclaration", arguments);
}
function tsModuleBlock(body) {
    return _builder.default.apply("TSModuleBlock", arguments);
}
function tsImportType(argument, qualifier, typeParameters) {
    return _builder.default.apply("TSImportType", arguments);
}
function tsImportEqualsDeclaration(id, moduleReference) {
    return _builder.default.apply("TSImportEqualsDeclaration", arguments);
}
function tsExternalModuleReference(expression) {
    return _builder.default.apply("TSExternalModuleReference", arguments);
}
function tsNonNullExpression(expression) {
    return _builder.default.apply("TSNonNullExpression", arguments);
}
function tsExportAssignment(expression) {
    return _builder.default.apply("TSExportAssignment", arguments);
}
function tsNamespaceExportDeclaration(id) {
    return _builder.default.apply("TSNamespaceExportDeclaration", arguments);
}
function tsTypeAnnotation(typeAnnotation) {
    return _builder.default.apply("TSTypeAnnotation", arguments);
}
function tsTypeParameterInstantiation(params) {
    return _builder.default.apply("TSTypeParameterInstantiation", arguments);
}
function tsTypeParameterDeclaration(params) {
    return _builder.default.apply("TSTypeParameterDeclaration", arguments);
}
function tsTypeParameter(constraint, _default, name) {
    return _builder.default.apply("TSTypeParameter", arguments);
}
function NumberLiteral(value) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    return _builder.default.apply("NumberLiteral", arguments);
}
function RegexLiteral(pattern, flags) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    return _builder.default.apply("RegexLiteral", arguments);
}
function RestProperty(argument) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    return _builder.default.apply("RestProperty", arguments);
}
function SpreadProperty(argument) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    return _builder.default.apply("SpreadProperty", arguments);
}

},{"../builder":"hapvy"}],"hapvy":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = builder;
var _definitions = require("../definitions");
var _validate = require("../validators/validate");
function builder() {
    const type = this;
    const keys = _definitions.BUILDER_KEYS[type];
    const countArgs = arguments.length;
    if (countArgs > keys.length) throw new Error(`${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${keys.length}`);
    const node = {
        type
    };
    for(let i = 0; i < keys.length; ++i){
        const key = keys[i];
        const field = _definitions.NODE_FIELDS[type][key];
        let arg;
        if (i < countArgs) arg = arguments[i];
        if (arg === undefined) arg = Array.isArray(field.default) ? [] : field.default;
        node[key] = arg;
    }
    for(const key in node)(0, _validate.default)(node, key, node[key]);
    return node;
}

},{"../definitions":"iA9Wj","../validators/validate":"5Y4H9"}],"iA9Wj":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ALIAS_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.ALIAS_KEYS;
    }
});
Object.defineProperty(exports, "BUILDER_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.BUILDER_KEYS;
    }
});
Object.defineProperty(exports, "DEPRECATED_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.DEPRECATED_KEYS;
    }
});
Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.FLIPPED_ALIAS_KEYS;
    }
});
Object.defineProperty(exports, "NODE_FIELDS", {
    enumerable: true,
    get: function() {
        return _utils.NODE_FIELDS;
    }
});
Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
    enumerable: true,
    get: function() {
        return _utils.NODE_PARENT_VALIDATIONS;
    }
});
Object.defineProperty(exports, "PLACEHOLDERS", {
    enumerable: true,
    get: function() {
        return _placeholders.PLACEHOLDERS;
    }
});
Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
    enumerable: true,
    get: function() {
        return _placeholders.PLACEHOLDERS_ALIAS;
    }
});
Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: true,
    get: function() {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
    }
});
exports.TYPES = void 0;
Object.defineProperty(exports, "VISITOR_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.VISITOR_KEYS;
    }
});
var _toFastProperties = require("to-fast-properties");
require("./core");
require("./flow");
require("./jsx");
require("./misc");
require("./experimental");
require("./typescript");
var _utils = require("./utils");
var _placeholders = require("./placeholders");
_toFastProperties(_utils.VISITOR_KEYS);
_toFastProperties(_utils.ALIAS_KEYS);
_toFastProperties(_utils.FLIPPED_ALIAS_KEYS);
_toFastProperties(_utils.NODE_FIELDS);
_toFastProperties(_utils.BUILDER_KEYS);
_toFastProperties(_utils.DEPRECATED_KEYS);
_toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);
_toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
const TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
exports.TYPES = TYPES;

},{"to-fast-properties":"ekC7H","./core":"bgLKg","./flow":"gYFNb","./jsx":"2J1j0","./misc":"2ZQkl","./experimental":"iyDjR","./typescript":"3LZfx","./utils":"biHkc","./placeholders":"7V2WV"}],"ekC7H":[function(require,module,exports) {
'use strict';
let fastProto = null;
// Creates an object with permanently fast properties in V8. See Toon Verwaest's
// post https://medium.com/@tverwaes/setting-up-prototypes-in-v8-ec9c9491dfe2#5f62
// for more details. Use %HasFastProperties(object) and the Node.js flag
// --allow-natives-syntax to check whether an object has fast properties.
function FastObject(o) {
    // A prototype object will have "fast properties" enabled once it is checked
    // against the inline property cache of a function, e.g. fastProto.property:
    // https://github.com/v8/v8/blob/6.0.122/test/mjsunit/fast-prototype.js#L48-L63
    if (fastProto !== null && typeof fastProto.property) {
        const result = fastProto;
        fastProto = FastObject.prototype = null;
        return result;
    }
    fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
    return new FastObject;
}
// Initialize the inline property cache of FastObject
FastObject();
module.exports = function toFastproperties(o) {
    return FastObject(o);
};

},{}],"bgLKg":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;
var _is = require("../validators/is");
var _isValidIdentifier = require("../validators/isValidIdentifier");
var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");
var _constants = require("../constants");
var _utils = require("./utils");
const defineType = (0, _utils.defineAliasedType)("Standardized");
defineType("ArrayExpression", {
    fields: {
        elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
            default: []
        }
    },
    visitor: [
        "elements"
    ],
    aliases: [
        "Expression"
    ]
});
defineType("AssignmentExpression", {
    fields: {
        operator: {
            validate: function() {
                var node, key, val;
                return (0, _utils.assertValueType)("string");
            }()
        },
        left: {
            validate: (0, _utils.assertNodeType)("LVal")
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    builder: [
        "operator",
        "left",
        "right"
    ],
    visitor: [
        "left",
        "right"
    ],
    aliases: [
        "Expression"
    ]
});
defineType("BinaryExpression", {
    builder: [
        "operator",
        "left",
        "right"
    ],
    fields: {
        operator: {
            validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
        },
        left: {
            validate: function() {
                const expression = (0, _utils.assertNodeType)("Expression");
                const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
                const validator1 = function(node, key, val) {
                    const validator = node.operator === "in" ? inOp : expression;
                    validator(node, key, val);
                };
                validator1.oneOfNodeTypes = [
                    "Expression",
                    "PrivateName"
                ];
                return validator1;
            }()
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    visitor: [
        "left",
        "right"
    ],
    aliases: [
        "Binary",
        "Expression"
    ]
});
defineType("InterpreterDirective", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});
defineType("Directive", {
    visitor: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertNodeType)("DirectiveLiteral")
        }
    }
});
defineType("DirectiveLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});
defineType("BlockStatement", {
    builder: [
        "body",
        "directives"
    ],
    visitor: [
        "directives",
        "body"
    ],
    fields: {
        directives: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
            default: []
        },
        body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
    },
    aliases: [
        "Scopable",
        "BlockParent",
        "Block",
        "Statement"
    ]
});
defineType("BreakStatement", {
    visitor: [
        "label"
    ],
    fields: {
        label: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
        }
    },
    aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
    ]
});
defineType("CallExpression", {
    visitor: [
        "callee",
        "arguments",
        "typeParameters",
        "typeArguments"
    ],
    builder: [
        "callee",
        "arguments"
    ],
    aliases: [
        "Expression"
    ],
    fields: Object.assign({
        callee: {
            validate: (0, _utils.assertNodeType)("Expression", "V8IntrinsicIdentifier")
        },
        arguments: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        }
    }, {
        optional: {
            validate: (0, _utils.assertOneOf)(true, false),
            optional: true
        }
    }, {
        typeArguments: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
            optional: true
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
            optional: true
        }
    })
});
defineType("CatchClause", {
    visitor: [
        "param",
        "body"
    ],
    fields: {
        param: {
            validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    },
    aliases: [
        "Scopable",
        "BlockParent"
    ]
});
defineType("ConditionalExpression", {
    visitor: [
        "test",
        "consequent",
        "alternate"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        alternate: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    aliases: [
        "Expression",
        "Conditional"
    ]
});
defineType("ContinueStatement", {
    visitor: [
        "label"
    ],
    fields: {
        label: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
        }
    },
    aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
    ]
});
defineType("DebuggerStatement", {
    aliases: [
        "Statement"
    ]
});
defineType("DoWhileStatement", {
    visitor: [
        "test",
        "body"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    },
    aliases: [
        "Statement",
        "BlockParent",
        "Loop",
        "While",
        "Scopable"
    ]
});
defineType("EmptyStatement", {
    aliases: [
        "Statement"
    ]
});
defineType("ExpressionStatement", {
    visitor: [
        "expression"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    aliases: [
        "Statement",
        "ExpressionWrapper"
    ]
});
defineType("File", {
    builder: [
        "program",
        "comments",
        "tokens"
    ],
    visitor: [
        "program"
    ],
    fields: {
        program: {
            validate: (0, _utils.assertNodeType)("Program")
        },
        comments: {
            validate: Object.assign(()=>{
            }, {
                each: {
                    oneOfNodeTypes: [
                        "CommentBlock",
                        "CommentLine"
                    ]
                }
            }),
            optional: true
        },
        tokens: {
            validate: (0, _utils.assertEach)(Object.assign(()=>{
            }, {
                type: "any"
            })),
            optional: true
        }
    }
});
defineType("ForInStatement", {
    visitor: [
        "left",
        "right",
        "body"
    ],
    aliases: [
        "Scopable",
        "Statement",
        "For",
        "BlockParent",
        "Loop",
        "ForXStatement"
    ],
    fields: {
        left: {
            validate: (0, _utils.assertNodeType)("VariableDeclaration", "LVal")
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("ForStatement", {
    visitor: [
        "init",
        "test",
        "update",
        "body"
    ],
    aliases: [
        "Scopable",
        "Statement",
        "For",
        "BlockParent",
        "Loop"
    ],
    fields: {
        init: {
            validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
            optional: true
        },
        test: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        update: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
const functionCommon = {
    params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
        default: false
    },
    async: {
        default: false
    }
};
exports.functionCommon = functionCommon;
const functionTypeAnnotationCommon = {
    returnType: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
    },
    typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
    }
};
exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
const functionDeclarationCommon = Object.assign({
}, functionCommon, {
    declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
    },
    id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
    }
});
exports.functionDeclarationCommon = functionDeclarationCommon;
defineType("FunctionDeclaration", {
    builder: [
        "id",
        "params",
        "body",
        "generator",
        "async"
    ],
    visitor: [
        "id",
        "params",
        "body",
        "returnType",
        "typeParameters"
    ],
    fields: Object.assign({
    }, functionDeclarationCommon, functionTypeAnnotationCommon, {
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    }),
    aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Statement",
        "Pureish",
        "Declaration"
    ],
    validate: function() {
        var parent, key, node;
        return ()=>{
        };
    }()
});
defineType("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Expression",
        "Pureish"
    ],
    fields: Object.assign({
    }, functionCommon, functionTypeAnnotationCommon, {
        id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    })
});
const patternLikeCommon = {
    typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
    },
    decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
    }
};
exports.patternLikeCommon = patternLikeCommon;
defineType("Identifier", {
    builder: [
        "name"
    ],
    visitor: [
        "typeAnnotation",
        "decorators"
    ],
    aliases: [
        "Expression",
        "PatternLike",
        "LVal",
        "TSEntityName"
    ],
    fields: Object.assign({
    }, patternLikeCommon, {
        name: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
                return;
            }, {
                type: "string"
            }))
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        }
    }),
    validate (parent, key, node) {
        return;
    }
});
defineType("IfStatement", {
    visitor: [
        "test",
        "consequent",
        "alternate"
    ],
    aliases: [
        "Statement",
        "Conditional"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
            validate: (0, _utils.assertNodeType)("Statement")
        },
        alternate: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("LabeledStatement", {
    visitor: [
        "label",
        "body"
    ],
    aliases: [
        "Statement"
    ],
    fields: {
        label: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("StringLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("NumericLiteral", {
    builder: [
        "value"
    ],
    deprecatedAlias: "NumberLiteral",
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("number")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("NullLiteral", {
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("BooleanLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("boolean")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("RegExpLiteral", {
    builder: [
        "pattern",
        "flags"
    ],
    deprecatedAlias: "RegexLiteral",
    aliases: [
        "Expression",
        "Pureish",
        "Literal"
    ],
    fields: {
        pattern: {
            validate: (0, _utils.assertValueType)("string")
        },
        flags: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
                return;
            }, {
                type: "string"
            })),
            default: ""
        }
    }
});
defineType("LogicalExpression", {
    builder: [
        "operator",
        "left",
        "right"
    ],
    visitor: [
        "left",
        "right"
    ],
    aliases: [
        "Binary",
        "Expression"
    ],
    fields: {
        operator: {
            validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
        },
        left: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("MemberExpression", {
    builder: [
        "object",
        "property",
        "computed",
        "optional"
    ],
    visitor: [
        "object",
        "property"
    ],
    aliases: [
        "Expression",
        "LVal"
    ],
    fields: Object.assign({
        object: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        property: {
            validate: function() {
                const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
                const computed = (0, _utils.assertNodeType)("Expression");
                const validator2 = function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
                validator2.oneOfNodeTypes = [
                    "Expression",
                    "Identifier",
                    "PrivateName"
                ];
                return validator2;
            }()
        },
        computed: {
            default: false
        }
    }, {
        optional: {
            validate: (0, _utils.assertOneOf)(true, false),
            optional: true
        }
    })
});
defineType("NewExpression", {
    inherits: "CallExpression"
});
defineType("Program", {
    visitor: [
        "directives",
        "body"
    ],
    builder: [
        "body",
        "directives",
        "sourceType",
        "interpreter"
    ],
    fields: {
        sourceFile: {
            validate: (0, _utils.assertValueType)("string")
        },
        sourceType: {
            validate: (0, _utils.assertOneOf)("script", "module"),
            default: "script"
        },
        interpreter: {
            validate: (0, _utils.assertNodeType)("InterpreterDirective"),
            default: null,
            optional: true
        },
        directives: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
            default: []
        },
        body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
    },
    aliases: [
        "Scopable",
        "BlockParent",
        "Block"
    ]
});
defineType("ObjectExpression", {
    visitor: [
        "properties"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
        }
    }
});
defineType("ObjectMethod", {
    builder: [
        "kind",
        "key",
        "params",
        "body",
        "computed",
        "generator",
        "async"
    ],
    fields: Object.assign({
    }, functionCommon, functionTypeAnnotationCommon, {
        kind: Object.assign({
            validate: (0, _utils.assertOneOf)("method", "get", "set")
        }, {
            default: "method"
        }),
        computed: {
            default: false
        },
        key: {
            validate: function() {
                const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
                const computed = (0, _utils.assertNodeType)("Expression");
                const validator3 = function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
                validator3.oneOfNodeTypes = [
                    "Expression",
                    "Identifier",
                    "StringLiteral",
                    "NumericLiteral"
                ];
                return validator3;
            }()
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    }),
    visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters"
    ],
    aliases: [
        "UserWhitespacable",
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method",
        "ObjectMember"
    ]
});
defineType("ObjectProperty", {
    builder: [
        "key",
        "value",
        "computed",
        "shorthand",
        "decorators"
    ],
    fields: {
        computed: {
            default: false
        },
        key: {
            validate: function() {
                const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
                const computed = (0, _utils.assertNodeType)("Expression");
                const validator4 = function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
                validator4.oneOfNodeTypes = [
                    "Expression",
                    "Identifier",
                    "StringLiteral",
                    "NumericLiteral"
                ];
                return validator4;
            }()
        },
        value: {
            validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
        },
        shorthand: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
                return;
            }, {
                type: "boolean"
            }), function(node, key, val) {
                return;
            }),
            default: false
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        }
    },
    visitor: [
        "key",
        "value",
        "decorators"
    ],
    aliases: [
        "UserWhitespacable",
        "Property",
        "ObjectMember"
    ],
    validate: function() {
        const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern");
        const expression = (0, _utils.assertNodeType)("Expression");
        return function(parent, key, node) {
            return;
        };
    }()
});
defineType("RestElement", {
    visitor: [
        "argument",
        "typeAnnotation"
    ],
    builder: [
        "argument"
    ],
    aliases: [
        "LVal",
        "PatternLike"
    ],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({
    }, patternLikeCommon, {
        argument: {
            validate: (0, _utils.assertNodeType)("LVal")
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        }
    }),
    validate (parent, key) {
        return;
    }
});
defineType("ReturnStatement", {
    visitor: [
        "argument"
    ],
    aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
    ],
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        }
    }
});
defineType("SequenceExpression", {
    visitor: [
        "expressions"
    ],
    fields: {
        expressions: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
        }
    },
    aliases: [
        "Expression"
    ]
});
defineType("ParenthesizedExpression", {
    visitor: [
        "expression"
    ],
    aliases: [
        "Expression",
        "ExpressionWrapper"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("SwitchCase", {
    visitor: [
        "test",
        "consequent"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        consequent: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
    }
});
defineType("SwitchStatement", {
    visitor: [
        "discriminant",
        "cases"
    ],
    aliases: [
        "Statement",
        "BlockParent",
        "Scopable"
    ],
    fields: {
        discriminant: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        cases: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
        }
    }
});
defineType("ThisExpression", {
    aliases: [
        "Expression"
    ]
});
defineType("ThrowStatement", {
    visitor: [
        "argument"
    ],
    aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
    ],
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("TryStatement", {
    visitor: [
        "block",
        "handler",
        "finalizer"
    ],
    aliases: [
        "Statement"
    ],
    fields: {
        block: {
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
                return;
            }, {
                oneOfNodeTypes: [
                    "BlockStatement"
                ]
            }))
        },
        handler: {
            optional: true,
            validate: (0, _utils.assertNodeType)("CatchClause")
        },
        finalizer: {
            optional: true,
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    }
});
defineType("UnaryExpression", {
    builder: [
        "operator",
        "argument",
        "prefix"
    ],
    fields: {
        prefix: {
            default: true
        },
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        operator: {
            validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
        }
    },
    visitor: [
        "argument"
    ],
    aliases: [
        "UnaryLike",
        "Expression"
    ]
});
defineType("UpdateExpression", {
    builder: [
        "operator",
        "argument",
        "prefix"
    ],
    fields: {
        prefix: {
            default: false
        },
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        operator: {
            validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
        }
    },
    visitor: [
        "argument"
    ],
    aliases: [
        "Expression"
    ]
});
defineType("VariableDeclaration", {
    builder: [
        "kind",
        "declarations"
    ],
    visitor: [
        "declarations"
    ],
    aliases: [
        "Statement",
        "Declaration"
    ],
    fields: {
        declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        kind: {
            validate: (0, _utils.assertOneOf)("var", "let", "const")
        },
        declarations: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
        }
    },
    validate (parent, key, node) {
        return;
    }
});
defineType("VariableDeclarator", {
    visitor: [
        "id",
        "init"
    ],
    fields: {
        id: {
            validate: function() {
                var node, key, val;
                return (0, _utils.assertNodeType)("LVal");
            }()
        },
        definite: {
            optional: true,
            validate: (0, _utils.assertValueType)("boolean")
        },
        init: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("WhileStatement", {
    visitor: [
        "test",
        "body"
    ],
    aliases: [
        "Statement",
        "BlockParent",
        "Loop",
        "While",
        "Scopable"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("WithStatement", {
    visitor: [
        "object",
        "body"
    ],
    aliases: [
        "Statement"
    ],
    fields: {
        object: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("AssignmentPattern", {
    visitor: [
        "left",
        "right",
        "decorators"
    ],
    builder: [
        "left",
        "right"
    ],
    aliases: [
        "Pattern",
        "PatternLike",
        "LVal"
    ],
    fields: Object.assign({
    }, patternLikeCommon, {
        left: {
            validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        }
    })
});
defineType("ArrayPattern", {
    visitor: [
        "elements",
        "typeAnnotation"
    ],
    builder: [
        "elements"
    ],
    aliases: [
        "Pattern",
        "PatternLike",
        "LVal"
    ],
    fields: Object.assign({
    }, patternLikeCommon, {
        elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike")))
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        }
    })
});
defineType("ArrowFunctionExpression", {
    builder: [
        "params",
        "body",
        "async"
    ],
    visitor: [
        "params",
        "body",
        "returnType",
        "typeParameters"
    ],
    aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Expression",
        "Pureish"
    ],
    fields: Object.assign({
    }, functionCommon, functionTypeAnnotationCommon, {
        expression: {
            validate: (0, _utils.assertValueType)("boolean")
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
        }
    })
});
defineType("ClassBody", {
    visitor: [
        "body"
    ],
    fields: {
        body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
        }
    }
});
defineType("ClassExpression", {
    builder: [
        "id",
        "superClass",
        "body",
        "decorators"
    ],
    visitor: [
        "id",
        "body",
        "superClass",
        "mixins",
        "typeParameters",
        "superTypeParameters",
        "implements",
        "decorators"
    ],
    aliases: [
        "Scopable",
        "Class",
        "Expression"
    ],
    fields: {
        id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
        },
        implements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        mixins: {
            validate: (0, _utils.assertNodeType)("InterfaceExtends"),
            optional: true
        }
    }
});
defineType("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: [
        "Scopable",
        "Class",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
        },
        implements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        mixins: {
            validate: (0, _utils.assertNodeType)("InterfaceExtends"),
            optional: true
        },
        declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        abstract: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        }
    },
    validate: function() {
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node) {
            return;
        };
    }()
});
defineType("ExportAllDeclaration", {
    visitor: [
        "source"
    ],
    aliases: [
        "Statement",
        "Declaration",
        "ModuleDeclaration",
        "ExportDeclaration"
    ],
    fields: {
        source: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")),
        assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        }
    }
});
defineType("ExportDefaultDeclaration", {
    visitor: [
        "declaration"
    ],
    aliases: [
        "Statement",
        "Declaration",
        "ModuleDeclaration",
        "ExportDeclaration"
    ],
    fields: {
        declaration: {
            validate: (0, _utils.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
    }
});
defineType("ExportNamedDeclaration", {
    visitor: [
        "declaration",
        "specifiers",
        "source"
    ],
    aliases: [
        "Statement",
        "Declaration",
        "ModuleDeclaration",
        "ExportDeclaration"
    ],
    fields: {
        declaration: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key, val) {
                return;
            }, {
                oneOfNodeTypes: [
                    "Declaration"
                ]
            }), function(node, key, val) {
                return;
            })
        },
        assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        specifiers: {
            default: [],
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function() {
                const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
                const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
                var node, key, val;
                return sourced;
            }()))
        },
        source: {
            validate: (0, _utils.assertNodeType)("StringLiteral"),
            optional: true
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }
});
defineType("ExportSpecifier", {
    visitor: [
        "local",
        "exported"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        local: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        exported: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        exportKind: {
            validate: (0, _utils.assertOneOf)("type", "value"),
            optional: true
        }
    }
});
defineType("ForOfStatement", {
    visitor: [
        "left",
        "right",
        "body"
    ],
    builder: [
        "left",
        "right",
        "body",
        "await"
    ],
    aliases: [
        "Scopable",
        "Statement",
        "For",
        "BlockParent",
        "Loop",
        "ForXStatement"
    ],
    fields: {
        left: {
            validate: function() {
                var node, key, val;
                return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
            }()
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        },
        await: {
            default: false
        }
    }
});
defineType("ImportDeclaration", {
    visitor: [
        "specifiers",
        "source"
    ],
    aliases: [
        "Statement",
        "Declaration",
        "ModuleDeclaration"
    ],
    fields: {
        assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        specifiers: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
        },
        source: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        importKind: {
            validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
            optional: true
        }
    }
});
defineType("ImportDefaultSpecifier", {
    visitor: [
        "local"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        local: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
defineType("ImportNamespaceSpecifier", {
    visitor: [
        "local"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        local: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
defineType("ImportSpecifier", {
    visitor: [
        "local",
        "imported"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        local: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        imported: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        importKind: {
            validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
            optional: true
        }
    }
});
defineType("MetaProperty", {
    visitor: [
        "meta",
        "property"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        meta: {
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key, val) {
                return;
            }, {
                oneOfNodeTypes: [
                    "Identifier"
                ]
            }))
        },
        property: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
const classMethodOrPropertyCommon = {
    abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
    },
    accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
    },
    static: {
        default: false
    },
    override: {
        default: false
    },
    computed: {
        default: false
    },
    optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
    },
    key: {
        validate: (0, _utils.chain)(function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
            const computed = (0, _utils.assertNodeType)("Expression");
            return function(node, key, val) {
                const validator = node.computed ? computed : normal;
                validator(node, key, val);
            };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
    }
};
exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
const classMethodOrDeclareMethodCommon = Object.assign({
}, functionCommon, classMethodOrPropertyCommon, {
    params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
    },
    kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
        default: "method"
    },
    access: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
        optional: true
    },
    decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
    }
});
exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
defineType("ClassMethod", {
    aliases: [
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method"
    ],
    builder: [
        "kind",
        "key",
        "params",
        "body",
        "computed",
        "static",
        "generator",
        "async"
    ],
    visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters"
    ],
    fields: Object.assign({
    }, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    })
});
defineType("ObjectPattern", {
    visitor: [
        "properties",
        "typeAnnotation",
        "decorators"
    ],
    builder: [
        "properties"
    ],
    aliases: [
        "Pattern",
        "PatternLike",
        "LVal"
    ],
    fields: Object.assign({
    }, patternLikeCommon, {
        properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
        }
    })
});
defineType("SpreadElement", {
    visitor: [
        "argument"
    ],
    aliases: [
        "UnaryLike"
    ],
    deprecatedAlias: "SpreadProperty",
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("Super", {
    aliases: [
        "Expression"
    ]
});
defineType("TaggedTemplateExpression", {
    visitor: [
        "tag",
        "quasi",
        "typeParameters"
    ],
    builder: [
        "tag",
        "quasi"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        tag: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        quasi: {
            validate: (0, _utils.assertNodeType)("TemplateLiteral")
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
        }
    }
});
defineType("TemplateElement", {
    builder: [
        "value",
        "tail"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertShape)({
                raw: {
                    validate: (0, _utils.assertValueType)("string")
                },
                cooked: {
                    validate: (0, _utils.assertValueType)("string"),
                    optional: true
                }
            })
        },
        tail: {
            default: false
        }
    }
});
defineType("TemplateLiteral", {
    visitor: [
        "quasis",
        "expressions"
    ],
    aliases: [
        "Expression",
        "Literal"
    ],
    fields: {
        quasis: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
        },
        expressions: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node, key, val) {
                if (node.quasis.length !== val.length + 1) throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);
            })
        }
    }
});
defineType("YieldExpression", {
    builder: [
        "argument",
        "delegate"
    ],
    visitor: [
        "argument"
    ],
    aliases: [
        "Expression",
        "Terminatorless"
    ],
    fields: {
        delegate: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
                return;
            }, {
                type: "boolean"
            })),
            default: false
        },
        argument: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("AwaitExpression", {
    builder: [
        "argument"
    ],
    visitor: [
        "argument"
    ],
    aliases: [
        "Expression",
        "Terminatorless"
    ],
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("Import", {
    aliases: [
        "Expression"
    ]
});
defineType("BigIntLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("ExportNamespaceSpecifier", {
    visitor: [
        "exported"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        exported: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
defineType("OptionalMemberExpression", {
    builder: [
        "object",
        "property",
        "computed",
        "optional"
    ],
    visitor: [
        "object",
        "property"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        object: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        property: {
            validate: function() {
                const normal = (0, _utils.assertNodeType)("Identifier");
                const computed = (0, _utils.assertNodeType)("Expression");
                const validator5 = function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
                validator5.oneOfNodeTypes = [
                    "Expression",
                    "Identifier"
                ];
                return validator5;
            }()
        },
        computed: {
            default: false
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean")
        }
    }
});
defineType("OptionalCallExpression", {
    visitor: [
        "callee",
        "arguments",
        "typeParameters",
        "typeArguments"
    ],
    builder: [
        "callee",
        "arguments",
        "optional"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        callee: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        arguments: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean")
        },
        typeArguments: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
            optional: true
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
            optional: true
        }
    }
});
defineType("ClassProperty", {
    visitor: [
        "key",
        "value",
        "typeAnnotation",
        "decorators"
    ],
    builder: [
        "key",
        "value",
        "typeAnnotation",
        "decorators",
        "computed",
        "static"
    ],
    aliases: [
        "Property"
    ],
    fields: Object.assign({
    }, classMethodOrPropertyCommon, {
        value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
        }
    })
});
defineType("ClassPrivateProperty", {
    visitor: [
        "key",
        "value",
        "decorators",
        "typeAnnotation"
    ],
    builder: [
        "key",
        "value",
        "decorators",
        "static"
    ],
    aliases: [
        "Property",
        "Private"
    ],
    fields: {
        key: {
            validate: (0, _utils.assertNodeType)("PrivateName")
        },
        value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
        }
    }
});
defineType("ClassPrivateMethod", {
    builder: [
        "kind",
        "key",
        "params",
        "body",
        "static"
    ],
    visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters"
    ],
    aliases: [
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method",
        "Private"
    ],
    fields: Object.assign({
    }, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
        key: {
            validate: (0, _utils.assertNodeType)("PrivateName")
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    })
});
defineType("PrivateName", {
    visitor: [
        "id"
    ],
    aliases: [
        "Private"
    ],
    fields: {
        id: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
defineType("StaticBlock", {
    visitor: [
        "body"
    ],
    fields: {
        body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
    },
    aliases: [
        "Scopable",
        "BlockParent",
        "FunctionParent"
    ]
});

},{"../validators/is":"bRiMB","../validators/isValidIdentifier":"aPv9j","@babel/helper-validator-identifier":"awkZV","../constants":"b9TVI","./utils":"biHkc"}],"bRiMB":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = is;
var _shallowEqual = require("../utils/shallowEqual");
var _isType = require("./isType");
var _isPlaceholderType = require("./isPlaceholderType");
var _definitions = require("../definitions");
function is(type, node, opts) {
    if (!node) return false;
    const matches = (0, _isType.default)(node.type, type);
    if (!matches) {
        if (!opts && node.type === "Placeholder" && type in _definitions.FLIPPED_ALIAS_KEYS) return (0, _isPlaceholderType.default)(node.expectedNode, type);
        return false;
    }
    if (typeof opts === "undefined") return true;
    else return (0, _shallowEqual.default)(node, opts);
}

},{"../utils/shallowEqual":"89xXy","./isType":"7Y6bU","./isPlaceholderType":"2ARSw","../definitions":"iA9Wj"}],"7Y6bU":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isType;
var _definitions = require("../definitions");
function isType(nodeType, targetType) {
    if (nodeType === targetType) return true;
    if (_definitions.ALIAS_KEYS[targetType]) return false;
    const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];
    if (aliases) {
        if (aliases[0] === nodeType) return true;
        for (const alias of aliases){
            if (nodeType === alias) return true;
        }
    }
    return false;
}

},{"../definitions":"iA9Wj"}],"2ARSw":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isPlaceholderType;
var _definitions = require("../definitions");
function isPlaceholderType(placeholderType, targetType) {
    if (placeholderType === targetType) return true;
    const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];
    if (aliases) for (const alias of aliases){
        if (targetType === alias) return true;
    }
    return false;
}

},{"../definitions":"iA9Wj"}],"aPv9j":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isValidIdentifier;
var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");
function isValidIdentifier(name, reserved = true) {
    if (typeof name !== "string") return false;
    if (reserved) {
        if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) return false;
    }
    return (0, _helperValidatorIdentifier.isIdentifierName)(name);
}

},{"@babel/helper-validator-identifier":"awkZV"}],"awkZV":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isIdentifierName", {
    enumerable: true,
    get: function() {
        return _identifier.isIdentifierName;
    }
});
Object.defineProperty(exports, "isIdentifierChar", {
    enumerable: true,
    get: function() {
        return _identifier.isIdentifierChar;
    }
});
Object.defineProperty(exports, "isIdentifierStart", {
    enumerable: true,
    get: function() {
        return _identifier.isIdentifierStart;
    }
});
Object.defineProperty(exports, "isReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isReservedWord;
    }
});
Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
    }
});
Object.defineProperty(exports, "isStrictBindReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isStrictBindReservedWord;
    }
});
Object.defineProperty(exports, "isStrictReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isStrictReservedWord;
    }
});
Object.defineProperty(exports, "isKeyword", {
    enumerable: true,
    get: function() {
        return _keyword.isKeyword;
    }
});
var _identifier = require("./identifier");
var _keyword = require("./keyword");

},{"./identifier":"3EdZ2","./keyword":"j8GzH"}],"3EdZ2":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isIdentifierStart = isIdentifierStart;
exports.isIdentifierChar = isIdentifierChar;
exports.isIdentifierName = isIdentifierName;
let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
let nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
const astralIdentifierStartCodes = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    13,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    2,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    68,
    310,
    10,
    21,
    11,
    7,
    25,
    5,
    2,
    41,
    2,
    8,
    70,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    349,
    41,
    7,
    1,
    79,
    28,
    11,
    0,
    9,
    21,
    43,
    17,
    47,
    20,
    28,
    22,
    13,
    52,
    58,
    1,
    3,
    0,
    14,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    85,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    159,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    38,
    6,
    186,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    19,
    72,
    264,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    328,
    18,
    190,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2637,
    96,
    16,
    1070,
    4050,
    582,
    8634,
    568,
    8,
    30,
    18,
    78,
    18,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    689,
    63,
    129,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    29,
    6135,
    9,
    1237,
    43,
    8,
    8936,
    3,
    2,
    6,
    2,
    1,
    2,
    290,
    46,
    2,
    18,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    1845,
    30,
    482,
    44,
    11,
    6,
    17,
    0,
    322,
    29,
    19,
    43,
    1269,
    6,
    2,
    3,
    2,
    1,
    2,
    14,
    2,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42719,
    33,
    4152,
    8,
    221,
    3,
    5761,
    15,
    7472,
    3104,
    541,
    1507,
    4938
];
const astralIdentifierCodes = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    370,
    1,
    154,
    10,
    50,
    3,
    123,
    2,
    54,
    14,
    32,
    10,
    3,
    1,
    11,
    3,
    46,
    10,
    8,
    0,
    46,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    161,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    193,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    84,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    406,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    330,
    3,
    19306,
    9,
    87,
    9,
    39,
    4,
    60,
    6,
    26,
    9,
    1014,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    4706,
    45,
    3,
    22,
    543,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    262,
    6,
    10,
    9,
    357,
    0,
    62,
    13,
    1495,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239
];
function isInAstralSet(code, set) {
    let pos = 65536;
    for(let i = 0, length = set.length; i < length; i += 2){
        pos += set[i];
        if (pos > code) return false;
        pos += set[i + 1];
        if (pos >= code) return true;
    }
    return false;
}
function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 65535) return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
    return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 65535) return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
function isIdentifierName(name) {
    let isFirst = true;
    for(let i = 0; i < name.length; i++){
        let cp = name.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
            const trail = name.charCodeAt(++i);
            if ((trail & 64512) === 56320) cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
        }
        if (isFirst) {
            isFirst = false;
            if (!isIdentifierStart(cp)) return false;
        } else if (!isIdentifierChar(cp)) return false;
    }
    return !isFirst;
}

},{}],"j8GzH":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isReservedWord = isReservedWord;
exports.isStrictReservedWord = isStrictReservedWord;
exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
exports.isStrictBindReservedWord = isStrictBindReservedWord;
exports.isKeyword = isKeyword;
const reservedWords = {
    keyword: [
        "break",
        "case",
        "catch",
        "continue",
        "debugger",
        "default",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "return",
        "switch",
        "throw",
        "try",
        "var",
        "const",
        "while",
        "with",
        "new",
        "this",
        "super",
        "class",
        "extends",
        "export",
        "import",
        "null",
        "true",
        "false",
        "in",
        "instanceof",
        "typeof",
        "void",
        "delete"
    ],
    strict: [
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "yield"
    ],
    strictBind: [
        "eval",
        "arguments"
    ]
};
const keywords = new Set(reservedWords.keyword);
const reservedWordsStrictSet = new Set(reservedWords.strict);
const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
}
function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}
function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
}
function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
}
function isKeyword(word) {
    return keywords.has(word);
}

},{}],"b9TVI":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.NOT_LOCAL_BINDING = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BLOCK_SCOPED_SYMBOL = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;
const STATEMENT_OR_BLOCK_KEYS = [
    "consequent",
    "body",
    "alternate"
];
exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
const FLATTENABLE_KEYS = [
    "body",
    "expressions"
];
exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
const FOR_INIT_KEYS = [
    "left",
    "init"
];
exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
const COMMENT_KEYS = [
    "leadingComments",
    "trailingComments",
    "innerComments"
];
exports.COMMENT_KEYS = COMMENT_KEYS;
const LOGICAL_OPERATORS = [
    "||",
    "&&",
    "??"
];
exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
const UPDATE_OPERATORS = [
    "++",
    "--"
];
exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
const BOOLEAN_NUMBER_BINARY_OPERATORS = [
    ">",
    "<",
    ">=",
    "<="
];
exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
const EQUALITY_BINARY_OPERATORS = [
    "==",
    "===",
    "!=",
    "!=="
];
exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
const COMPARISON_BINARY_OPERATORS = [
    ...EQUALITY_BINARY_OPERATORS,
    "in",
    "instanceof"
];
exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
const BOOLEAN_BINARY_OPERATORS = [
    ...COMPARISON_BINARY_OPERATORS,
    ...BOOLEAN_NUMBER_BINARY_OPERATORS
];
exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
const NUMBER_BINARY_OPERATORS = [
    "-",
    "/",
    "%",
    "*",
    "**",
    "&",
    "|",
    ">>",
    ">>>",
    "<<",
    "^"
];
exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
const BINARY_OPERATORS = [
    "+",
    ...NUMBER_BINARY_OPERATORS,
    ...BOOLEAN_BINARY_OPERATORS
];
exports.BINARY_OPERATORS = BINARY_OPERATORS;
const ASSIGNMENT_OPERATORS = [
    "=",
    "+=",
    ...NUMBER_BINARY_OPERATORS.map((op)=>op + "="
    ),
    ...LOGICAL_OPERATORS.map((op)=>op + "="
    )
];
exports.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
const BOOLEAN_UNARY_OPERATORS = [
    "delete",
    "!"
];
exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
const NUMBER_UNARY_OPERATORS = [
    "+",
    "-",
    "~"
];
exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
const STRING_UNARY_OPERATORS = [
    "typeof"
];
exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
const UNARY_OPERATORS = [
    "void",
    "throw",
    ...BOOLEAN_UNARY_OPERATORS,
    ...NUMBER_UNARY_OPERATORS,
    ...STRING_UNARY_OPERATORS
];
exports.UNARY_OPERATORS = UNARY_OPERATORS;
const INHERIT_KEYS = {
    optional: [
        "typeAnnotation",
        "typeParameters",
        "returnType"
    ],
    force: [
        "start",
        "loc",
        "end"
    ]
};
exports.INHERIT_KEYS = INHERIT_KEYS;
const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
const NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;

},{}],"biHkc":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;
exports.arrayOf = arrayOf;
exports.arrayOfType = arrayOfType;
exports.assertEach = assertEach;
exports.assertNodeOrValueType = assertNodeOrValueType;
exports.assertNodeType = assertNodeType;
exports.assertOneOf = assertOneOf;
exports.assertOptionalChainStart = assertOptionalChainStart;
exports.assertShape = assertShape;
exports.assertValueType = assertValueType;
exports.chain = chain;
exports.default = defineType;
exports.defineAliasedType = defineAliasedType;
exports.typeIs = typeIs;
exports.validate = validate1;
exports.validateArrayOfType = validateArrayOfType;
exports.validateOptional = validateOptional;
exports.validateOptionalType = validateOptionalType;
exports.validateType = validateType;
var _is = require("../validators/is");
var _validate = require("../validators/validate");
const VISITOR_KEYS = {
};
exports.VISITOR_KEYS = VISITOR_KEYS;
const ALIAS_KEYS = {
};
exports.ALIAS_KEYS = ALIAS_KEYS;
const FLIPPED_ALIAS_KEYS = {
};
exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
const NODE_FIELDS = {
};
exports.NODE_FIELDS = NODE_FIELDS;
const BUILDER_KEYS = {
};
exports.BUILDER_KEYS = BUILDER_KEYS;
const DEPRECATED_KEYS = {
};
exports.DEPRECATED_KEYS = DEPRECATED_KEYS;
const NODE_PARENT_VALIDATIONS = {
};
exports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
function getType(val) {
    if (Array.isArray(val)) return "array";
    else if (val === null) return "null";
    else return typeof val;
}
function validate1(validate) {
    return {
        validate
    };
}
function typeIs(typeName) {
    return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
}
function validateType(typeName) {
    return validate1(typeIs(typeName));
}
function validateOptional(validate) {
    return {
        validate,
        optional: true
    };
}
function validateOptionalType(typeName) {
    return {
        validate: typeIs(typeName),
        optional: true
    };
}
function arrayOf(elementType) {
    return chain(assertValueType("array"), assertEach(elementType));
}
function arrayOfType(typeName) {
    return arrayOf(typeIs(typeName));
}
function validateArrayOfType(typeName) {
    return validate1(arrayOfType(typeName));
}
function assertEach(callback) {
    function validator(node, key, val) {
        if (!Array.isArray(val)) return;
        for(let i = 0; i < val.length; i++){
            const subkey = `${key}[${i}]`;
            const v = val[i];
            callback(node, subkey, v);
        }
    }
    validator.each = callback;
    return validator;
}
function assertOneOf(...values) {
    function validate(node, key, val) {
        if (values.indexOf(val) < 0) throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
    }
    validate.oneOf = values;
    return validate;
}
function assertNodeType(...types) {
    function validate(node, key, val) {
        for (const type of types)if ((0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
    }
    validate.oneOfNodeTypes = types;
    return validate;
}
function assertNodeOrValueType(...types) {
    function validate(node, key, val) {
        for (const type of types)if (getType(val) === type || (0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
    }
    validate.oneOfNodeOrValueTypes = types;
    return validate;
}
function assertValueType(type) {
    function validate(node, key, val) {
        const valid = getType(val) === type;
        if (!valid) throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
    }
    validate.type = type;
    return validate;
}
function assertShape(shape) {
    function validate(node, key, val) {
        const errors = [];
        for (const property of Object.keys(shape))try {
            (0, _validate.validateField)(node, property, val[property], shape[property]);
        } catch (error) {
            if (error instanceof TypeError) {
                errors.push(error.message);
                continue;
            }
            throw error;
        }
        if (errors.length) throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\n${errors.join("\n")}`);
    }
    validate.shapeOf = shape;
    return validate;
}
function assertOptionalChainStart() {
    function validate(node) {
        var _current;
        let current = node;
        while(node){
            const { type  } = current;
            if (type === "OptionalCallExpression") {
                if (current.optional) return;
                current = current.callee;
                continue;
            }
            if (type === "OptionalMemberExpression") {
                if (current.optional) return;
                current = current.object;
                continue;
            }
            break;
        }
        throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
    }
    return validate;
}
function chain(...fns) {
    function validate(...args) {
        for (const fn of fns)fn(...args);
    }
    validate.chainOf = fns;
    if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
    return validate;
}
const validTypeOpts = [
    "aliases",
    "builder",
    "deprecatedAlias",
    "fields",
    "inherits",
    "visitor",
    "validate"
];
const validFieldKeys = [
    "default",
    "optional",
    "validate"
];
function defineAliasedType(...aliases) {
    return (type, opts = {
    })=>{
        let defined = opts.aliases;
        if (!defined) {
            var _store$opts$inherits$, _defined;
            if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
            (_defined = defined) != null || (defined = []);
            opts.aliases = defined;
        }
        const additional = aliases.filter((a)=>!defined.includes(a)
        );
        defined.unshift(...additional);
        return defineType(type, opts);
    };
}
function defineType(type, opts = {
}) {
    const inherits = opts.inherits && store[opts.inherits] || {
    };
    let fields = opts.fields;
    if (!fields) {
        fields = {
        };
        if (inherits.fields) {
            const keys = Object.getOwnPropertyNames(inherits.fields);
            for (const key of keys){
                const field = inherits.fields[key];
                const def = field.default;
                if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") throw new Error("field defaults can only be primitives or empty arrays currently");
                fields[key] = {
                    default: Array.isArray(def) ? [] : def,
                    optional: field.optional,
                    validate: field.validate
                };
            }
        }
    }
    const visitor = opts.visitor || inherits.visitor || [];
    const aliases = opts.aliases || inherits.aliases || [];
    const builder = opts.builder || inherits.builder || opts.visitor || [];
    for (const k of Object.keys(opts)){
        if (validTypeOpts.indexOf(k) === -1) throw new Error(`Unknown type option "${k}" on ${type}`);
    }
    if (opts.deprecatedAlias) DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    for (const key of visitor.concat(builder))fields[key] = fields[key] || {
    };
    for (const key1 of Object.keys(fields)){
        const field = fields[key1];
        if (field.default !== undefined && builder.indexOf(key1) === -1) field.optional = true;
        if (field.default === undefined) field.default = null;
        else if (!field.validate && field.default != null) field.validate = assertValueType(getType(field.default));
        for (const k of Object.keys(field)){
            if (validFieldKeys.indexOf(k) === -1) throw new Error(`Unknown field key "${k}" on ${type}.${key1}`);
        }
    }
    VISITOR_KEYS[type] = opts.visitor = visitor;
    BUILDER_KEYS[type] = opts.builder = builder;
    NODE_FIELDS[type] = opts.fields = fields;
    ALIAS_KEYS[type] = opts.aliases = aliases;
    aliases.forEach((alias)=>{
        FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
        FLIPPED_ALIAS_KEYS[alias].push(type);
    });
    if (opts.validate) NODE_PARENT_VALIDATIONS[type] = opts.validate;
    store[type] = opts;
}
const store = {
};

},{"../validators/is":"bRiMB","../validators/validate":"5Y4H9"}],"5Y4H9":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = validate1;
exports.validateChild = validateChild;
exports.validateField = validateField;
var _definitions = require("../definitions");
function validate1(node, key, val) {
    if (!node) return;
    const fields = _definitions.NODE_FIELDS[node.type];
    if (!fields) return;
    const field = fields[key];
    validateField(node, key, val, field);
    validateChild(node, key, val);
}
function validateField(node, key, val, field) {
    if (!(field != null && field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node, key, val);
}
function validateChild(node, key, val) {
    if (val == null) return;
    const validate = _definitions.NODE_PARENT_VALIDATIONS[val.type];
    if (!validate) return;
    validate(node, key, val);
}

},{"../definitions":"iA9Wj"}],"gYFNb":[function(require,module,exports) {
"use strict";
var _utils = require("./utils");
const defineType = (0, _utils.defineAliasedType)("Flow");
const defineInterfaceishType = (name, typeParameterType = "TypeParameterDeclaration")=>{
    defineType(name, {
        builder: [
            "id",
            "typeParameters",
            "extends",
            "body"
        ],
        visitor: [
            "id",
            "typeParameters",
            "extends",
            "mixins",
            "implements",
            "body"
        ],
        aliases: [
            "FlowDeclaration",
            "Statement",
            "Declaration"
        ],
        fields: {
            id: (0, _utils.validateType)("Identifier"),
            typeParameters: (0, _utils.validateOptionalType)(typeParameterType),
            extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
            mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
            implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")),
            body: (0, _utils.validateType)("ObjectTypeAnnotation")
        }
    });
};
defineType("AnyTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("ArrayTypeAnnotation", {
    visitor: [
        "elementType"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        elementType: (0, _utils.validateType)("FlowType")
    }
});
defineType("BooleanTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("BooleanLiteralTypeAnnotation", {
    builder: [
        "value"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("NullLiteralTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("ClassImplements", {
    visitor: [
        "id",
        "typeParameters"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
});
defineInterfaceishType("DeclareClass");
defineType("DeclareFunction", {
    visitor: [
        "id"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
    }
});
defineInterfaceishType("DeclareInterface");
defineType("DeclareModule", {
    builder: [
        "id",
        "body",
        "kind"
    ],
    visitor: [
        "id",
        "body"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)([
            "Identifier",
            "StringLiteral"
        ]),
        body: (0, _utils.validateType)("BlockStatement"),
        kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
    }
});
defineType("DeclareModuleExports", {
    visitor: [
        "typeAnnotation"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
});
defineType("DeclareTypeAlias", {
    visitor: [
        "id",
        "typeParameters",
        "right"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
    }
});
defineType("DeclareOpaqueType", {
    visitor: [
        "id",
        "typeParameters",
        "supertype"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateOptionalType)("FlowType")
    }
});
defineType("DeclareVariable", {
    visitor: [
        "id"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier")
    }
});
defineType("DeclareExportDeclaration", {
    visitor: [
        "declaration",
        "specifiers",
        "source"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        declaration: (0, _utils.validateOptionalType)("Flow"),
        specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)([
            "ExportSpecifier",
            "ExportNamespaceSpecifier"
        ])),
        source: (0, _utils.validateOptionalType)("StringLiteral"),
        default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("DeclareExportAllDeclaration", {
    visitor: [
        "source"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        source: (0, _utils.validateType)("StringLiteral"),
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }
});
defineType("DeclaredPredicate", {
    visitor: [
        "value"
    ],
    aliases: [
        "FlowPredicate"
    ],
    fields: {
        value: (0, _utils.validateType)("Flow")
    }
});
defineType("ExistsTypeAnnotation", {
    aliases: [
        "FlowType"
    ]
});
defineType("FunctionTypeAnnotation", {
    visitor: [
        "typeParameters",
        "params",
        "rest",
        "returnType"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
        rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        returnType: (0, _utils.validateType)("FlowType")
    }
});
defineType("FunctionTypeParam", {
    visitor: [
        "name",
        "typeAnnotation"
    ],
    fields: {
        name: (0, _utils.validateOptionalType)("Identifier"),
        typeAnnotation: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("GenericTypeAnnotation", {
    visitor: [
        "id",
        "typeParameters"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        id: (0, _utils.validateType)([
            "Identifier",
            "QualifiedTypeIdentifier"
        ]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
});
defineType("InferredPredicate", {
    aliases: [
        "FlowPredicate"
    ]
});
defineType("InterfaceExtends", {
    visitor: [
        "id",
        "typeParameters"
    ],
    fields: {
        id: (0, _utils.validateType)([
            "Identifier",
            "QualifiedTypeIdentifier"
        ]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
});
defineInterfaceishType("InterfaceDeclaration");
defineType("InterfaceTypeAnnotation", {
    visitor: [
        "extends",
        "body"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
    }
});
defineType("IntersectionTypeAnnotation", {
    visitor: [
        "types"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
});
defineType("MixedTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("EmptyTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("NullableTypeAnnotation", {
    visitor: [
        "typeAnnotation"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
    }
});
defineType("NumberLiteralTypeAnnotation", {
    builder: [
        "value"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
    }
});
defineType("NumberTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("ObjectTypeAnnotation", {
    visitor: [
        "properties",
        "indexers",
        "callProperties",
        "internalSlots"
    ],
    aliases: [
        "FlowType"
    ],
    builder: [
        "properties",
        "indexers",
        "callProperties",
        "internalSlots",
        "exact"
    ],
    fields: {
        properties: (0, _utils.validate)((0, _utils.arrayOfType)([
            "ObjectTypeProperty",
            "ObjectTypeSpreadProperty"
        ])),
        indexers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeIndexer")),
        callProperties: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeCallProperty")),
        internalSlots: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeInternalSlot")),
        exact: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
        },
        inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("ObjectTypeInternalSlot", {
    visitor: [
        "id",
        "value",
        "optional",
        "static",
        "method"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        value: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("ObjectTypeCallProperty", {
    visitor: [
        "value"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("ObjectTypeIndexer", {
    visitor: [
        "id",
        "key",
        "value",
        "variance"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        id: (0, _utils.validateOptionalType)("Identifier"),
        key: (0, _utils.validateType)("FlowType"),
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance")
    }
});
defineType("ObjectTypeProperty", {
    visitor: [
        "key",
        "value",
        "variance"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        key: (0, _utils.validateType)([
            "Identifier",
            "StringLiteral"
        ]),
        value: (0, _utils.validateType)("FlowType"),
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance"),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("ObjectTypeSpreadProperty", {
    visitor: [
        "argument"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        argument: (0, _utils.validateType)("FlowType")
    }
});
defineType("OpaqueType", {
    visitor: [
        "id",
        "typeParameters",
        "supertype",
        "impltype"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateType)("FlowType")
    }
});
defineType("QualifiedTypeIdentifier", {
    visitor: [
        "id",
        "qualification"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        qualification: (0, _utils.validateType)([
            "Identifier",
            "QualifiedTypeIdentifier"
        ])
    }
});
defineType("StringLiteralTypeAnnotation", {
    builder: [
        "value"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
    }
});
defineType("StringTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("SymbolTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("ThisTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("TupleTypeAnnotation", {
    visitor: [
        "types"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
});
defineType("TypeofTypeAnnotation", {
    visitor: [
        "argument"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        argument: (0, _utils.validateType)("FlowType")
    }
});
defineType("TypeAlias", {
    visitor: [
        "id",
        "typeParameters",
        "right"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
    }
});
defineType("TypeAnnotation", {
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
    }
});
defineType("TypeCastExpression", {
    visitor: [
        "expression",
        "typeAnnotation"
    ],
    aliases: [
        "ExpressionWrapper",
        "Expression"
    ],
    fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
});
defineType("TypeParameter", {
    visitor: [
        "bound",
        "default",
        "variance"
    ],
    fields: {
        name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
        default: (0, _utils.validateOptionalType)("FlowType"),
        variance: (0, _utils.validateOptionalType)("Variance")
    }
});
defineType("TypeParameterDeclaration", {
    visitor: [
        "params"
    ],
    fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
    }
});
defineType("TypeParameterInstantiation", {
    visitor: [
        "params"
    ],
    fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
});
defineType("UnionTypeAnnotation", {
    visitor: [
        "types"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
});
defineType("Variance", {
    builder: [
        "kind"
    ],
    fields: {
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
    }
});
defineType("VoidTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("EnumDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "body"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        body: (0, _utils.validateType)([
            "EnumBooleanBody",
            "EnumNumberBody",
            "EnumStringBody",
            "EnumSymbolBody"
        ])
    }
});
defineType("EnumBooleanBody", {
    aliases: [
        "EnumBody"
    ],
    visitor: [
        "members"
    ],
    fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("EnumNumberBody", {
    aliases: [
        "EnumBody"
    ],
    visitor: [
        "members"
    ],
    fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("EnumStringBody", {
    aliases: [
        "EnumBody"
    ],
    visitor: [
        "members"
    ],
    fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)([
            "EnumStringMember",
            "EnumDefaultedMember"
        ]),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("EnumSymbolBody", {
    aliases: [
        "EnumBody"
    ],
    visitor: [
        "members"
    ],
    fields: {
        members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("EnumBooleanMember", {
    aliases: [
        "EnumMember"
    ],
    visitor: [
        "id"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("BooleanLiteral")
    }
});
defineType("EnumNumberMember", {
    aliases: [
        "EnumMember"
    ],
    visitor: [
        "id",
        "init"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("NumericLiteral")
    }
});
defineType("EnumStringMember", {
    aliases: [
        "EnumMember"
    ],
    visitor: [
        "id",
        "init"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("StringLiteral")
    }
});
defineType("EnumDefaultedMember", {
    aliases: [
        "EnumMember"
    ],
    visitor: [
        "id"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier")
    }
});
defineType("IndexedAccessType", {
    visitor: [
        "objectType",
        "indexType"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType")
    }
});
defineType("OptionalIndexedAccessType", {
    visitor: [
        "objectType",
        "indexType"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});

},{"./utils":"biHkc"}],"2J1j0":[function(require,module,exports) {
"use strict";
var _utils = require("./utils");
const defineType = (0, _utils.defineAliasedType)("JSX");
defineType("JSXAttribute", {
    visitor: [
        "name",
        "value"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
        },
        value: {
            optional: true,
            validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
        }
    }
});
defineType("JSXClosingElement", {
    visitor: [
        "name"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        }
    }
});
defineType("JSXElement", {
    builder: [
        "openingElement",
        "closingElement",
        "children",
        "selfClosing"
    ],
    visitor: [
        "openingElement",
        "children",
        "closingElement"
    ],
    aliases: [
        "Immutable",
        "Expression"
    ],
    fields: {
        openingElement: {
            validate: (0, _utils.assertNodeType)("JSXOpeningElement")
        },
        closingElement: {
            optional: true,
            validate: (0, _utils.assertNodeType)("JSXClosingElement")
        },
        children: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        },
        selfClosing: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        }
    }
});
defineType("JSXEmptyExpression", {
});
defineType("JSXExpressionContainer", {
    visitor: [
        "expression"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
        }
    }
});
defineType("JSXSpreadChild", {
    visitor: [
        "expression"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("JSXIdentifier", {
    builder: [
        "name"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});
defineType("JSXMemberExpression", {
    visitor: [
        "object",
        "property"
    ],
    fields: {
        object: {
            validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
        },
        property: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
    }
});
defineType("JSXNamespacedName", {
    visitor: [
        "namespace",
        "name"
    ],
    fields: {
        namespace: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
        },
        name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
    }
});
defineType("JSXOpeningElement", {
    builder: [
        "name",
        "attributes",
        "selfClosing"
    ],
    visitor: [
        "name",
        "attributes"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        },
        selfClosing: {
            default: false
        },
        attributes: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
        }
    }
});
defineType("JSXSpreadAttribute", {
    visitor: [
        "argument"
    ],
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("JSXText", {
    aliases: [
        "Immutable"
    ],
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});
defineType("JSXFragment", {
    builder: [
        "openingFragment",
        "closingFragment",
        "children"
    ],
    visitor: [
        "openingFragment",
        "children",
        "closingFragment"
    ],
    aliases: [
        "Immutable",
        "Expression"
    ],
    fields: {
        openingFragment: {
            validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
        },
        closingFragment: {
            validate: (0, _utils.assertNodeType)("JSXClosingFragment")
        },
        children: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
    }
});
defineType("JSXOpeningFragment", {
    aliases: [
        "Immutable"
    ]
});
defineType("JSXClosingFragment", {
    aliases: [
        "Immutable"
    ]
});

},{"./utils":"biHkc"}],"2ZQkl":[function(require,module,exports) {
"use strict";
var _utils = require("./utils");
var _placeholders = require("./placeholders");
const defineType = (0, _utils.defineAliasedType)("Miscellaneous");
defineType("Noop", {
    visitor: []
});
defineType("Placeholder", {
    visitor: [],
    builder: [
        "expectedNode",
        "name"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        expectedNode: {
            validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
        }
    }
});
defineType("V8IntrinsicIdentifier", {
    builder: [
        "name"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});

},{"./utils":"biHkc","./placeholders":"7V2WV"}],"7V2WV":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;
var _utils = require("./utils");
const PLACEHOLDERS = [
    "Identifier",
    "StringLiteral",
    "Expression",
    "Statement",
    "Declaration",
    "BlockStatement",
    "ClassBody",
    "Pattern"
];
exports.PLACEHOLDERS = PLACEHOLDERS;
const PLACEHOLDERS_ALIAS = {
    Declaration: [
        "Statement"
    ],
    Pattern: [
        "PatternLike",
        "LVal"
    ]
};
exports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;
for (const type1 of PLACEHOLDERS){
    const alias = _utils.ALIAS_KEYS[type1];
    if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type1] = alias;
}
const PLACEHOLDERS_FLIPPED_ALIAS = {
};
exports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
Object.keys(PLACEHOLDERS_ALIAS).forEach((type)=>{
    PLACEHOLDERS_ALIAS[type].forEach((alias)=>{
        if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
        PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
    });
});

},{"./utils":"biHkc"}],"iyDjR":[function(require,module,exports) {
"use strict";
var _utils = require("./utils");
(0, _utils.default)("ArgumentPlaceholder", {
});
(0, _utils.default)("BindExpression", {
    visitor: [
        "object",
        "callee"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        object: {
            validate: Object.assign(()=>{
            }, {
                oneOfNodeTypes: [
                    "Expression"
                ]
            })
        },
        callee: {
            validate: Object.assign(()=>{
            }, {
                oneOfNodeTypes: [
                    "Expression"
                ]
            })
        }
    }
});
(0, _utils.default)("ImportAttribute", {
    visitor: [
        "key",
        "value"
    ],
    fields: {
        key: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        value: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
        }
    }
});
(0, _utils.default)("Decorator", {
    visitor: [
        "expression"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
(0, _utils.default)("DoExpression", {
    visitor: [
        "body"
    ],
    builder: [
        "body",
        "async"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        async: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
        }
    }
});
(0, _utils.default)("ExportDefaultSpecifier", {
    visitor: [
        "exported"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        exported: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
(0, _utils.default)("RecordExpression", {
    visitor: [
        "properties"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
        }
    }
});
(0, _utils.default)("TupleExpression", {
    fields: {
        elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),
            default: []
        }
    },
    visitor: [
        "elements"
    ],
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("DecimalLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
(0, _utils.default)("ModuleExpression", {
    visitor: [
        "body"
    ],
    fields: {
        body: {
            validate: (0, _utils.assertNodeType)("Program")
        }
    },
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("TopicReference", {
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("PipelineTopicExpression", {
    builder: [
        "expression"
    ],
    visitor: [
        "expression"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("PipelineBareFunction", {
    builder: [
        "callee"
    ],
    visitor: [
        "callee"
    ],
    fields: {
        callee: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("PipelinePrimaryTopicReference", {
    aliases: [
        "Expression"
    ]
});

},{"./utils":"biHkc"}],"3LZfx":[function(require,module,exports) {
"use strict";
var _utils = require("./utils");
var _core = require("./core");
var _is = require("../validators/is");
const defineType = (0, _utils.defineAliasedType)("TypeScript");
const bool = (0, _utils.assertValueType)("boolean");
const tSFunctionTypeAnnotationCommon = {
    returnType: {
        validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
        optional: true
    },
    typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
        optional: true
    }
};
defineType("TSParameterProperty", {
    aliases: [
        "LVal"
    ],
    visitor: [
        "parameter"
    ],
    fields: {
        accessibility: {
            validate: (0, _utils.assertOneOf)("public", "private", "protected"),
            optional: true
        },
        readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        parameter: {
            validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
        },
        override: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        }
    }
});
defineType("TSDeclareFunction", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "typeParameters",
        "params",
        "returnType"
    ],
    fields: Object.assign({
    }, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon)
});
defineType("TSDeclareMethod", {
    visitor: [
        "decorators",
        "key",
        "typeParameters",
        "params",
        "returnType"
    ],
    fields: Object.assign({
    }, _core.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)
});
defineType("TSQualifiedName", {
    aliases: [
        "TSEntityName"
    ],
    visitor: [
        "left",
        "right"
    ],
    fields: {
        left: (0, _utils.validateType)("TSEntityName"),
        right: (0, _utils.validateType)("Identifier")
    }
});
const signatureDeclarationCommon = {
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, _utils.validateArrayOfType)([
        "Identifier",
        "RestElement"
    ]),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
};
const callConstructSignatureDeclaration = {
    aliases: [
        "TSTypeElement"
    ],
    visitor: [
        "typeParameters",
        "parameters",
        "typeAnnotation"
    ],
    fields: signatureDeclarationCommon
};
defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
const namedTypeElementCommon = {
    key: (0, _utils.validateType)("Expression"),
    computed: (0, _utils.validate)(bool),
    optional: (0, _utils.validateOptional)(bool)
};
defineType("TSPropertySignature", {
    aliases: [
        "TSTypeElement"
    ],
    visitor: [
        "key",
        "typeAnnotation",
        "initializer"
    ],
    fields: Object.assign({
    }, namedTypeElementCommon, {
        readonly: (0, _utils.validateOptional)(bool),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        initializer: (0, _utils.validateOptionalType)("Expression"),
        kind: {
            validate: (0, _utils.assertOneOf)("get", "set")
        }
    })
});
defineType("TSMethodSignature", {
    aliases: [
        "TSTypeElement"
    ],
    visitor: [
        "key",
        "typeParameters",
        "parameters",
        "typeAnnotation"
    ],
    fields: Object.assign({
    }, signatureDeclarationCommon, namedTypeElementCommon, {
        kind: {
            validate: (0, _utils.assertOneOf)("method", "get", "set")
        }
    })
});
defineType("TSIndexSignature", {
    aliases: [
        "TSTypeElement"
    ],
    visitor: [
        "parameters",
        "typeAnnotation"
    ],
    fields: {
        readonly: (0, _utils.validateOptional)(bool),
        static: (0, _utils.validateOptional)(bool),
        parameters: (0, _utils.validateArrayOfType)("Identifier"),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    }
});
const tsKeywordTypes = [
    "TSAnyKeyword",
    "TSBooleanKeyword",
    "TSBigIntKeyword",
    "TSIntrinsicKeyword",
    "TSNeverKeyword",
    "TSNullKeyword",
    "TSNumberKeyword",
    "TSObjectKeyword",
    "TSStringKeyword",
    "TSSymbolKeyword",
    "TSUndefinedKeyword",
    "TSUnknownKeyword",
    "TSVoidKeyword"
];
for (const type of tsKeywordTypes)defineType(type, {
    aliases: [
        "TSType",
        "TSBaseType"
    ],
    visitor: [],
    fields: {
    }
});
defineType("TSThisType", {
    aliases: [
        "TSType",
        "TSBaseType"
    ],
    visitor: [],
    fields: {
    }
});
const fnOrCtrBase = {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeParameters",
        "parameters",
        "typeAnnotation"
    ]
};
defineType("TSFunctionType", Object.assign({
}, fnOrCtrBase, {
    fields: signatureDeclarationCommon
}));
defineType("TSConstructorType", Object.assign({
}, fnOrCtrBase, {
    fields: Object.assign({
    }, signatureDeclarationCommon, {
        abstract: (0, _utils.validateOptional)(bool)
    })
}));
defineType("TSTypeReference", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeName",
        "typeParameters"
    ],
    fields: {
        typeName: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
});
defineType("TSTypePredicate", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "parameterName",
        "typeAnnotation"
    ],
    builder: [
        "parameterName",
        "typeAnnotation",
        "asserts"
    ],
    fields: {
        parameterName: (0, _utils.validateType)([
            "Identifier",
            "TSThisType"
        ]),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        asserts: (0, _utils.validateOptional)(bool)
    }
});
defineType("TSTypeQuery", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "exprName"
    ],
    fields: {
        exprName: (0, _utils.validateType)([
            "TSEntityName",
            "TSImportType"
        ])
    }
});
defineType("TSTypeLiteral", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "members"
    ],
    fields: {
        members: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
});
defineType("TSArrayType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "elementType"
    ],
    fields: {
        elementType: (0, _utils.validateType)("TSType")
    }
});
defineType("TSTupleType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "elementTypes"
    ],
    fields: {
        elementTypes: (0, _utils.validateArrayOfType)([
            "TSType",
            "TSNamedTupleMember"
        ])
    }
});
defineType("TSOptionalType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSRestType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSNamedTupleMember", {
    visitor: [
        "label",
        "elementType"
    ],
    builder: [
        "label",
        "elementType",
        "optional"
    ],
    fields: {
        label: (0, _utils.validateType)("Identifier"),
        optional: {
            validate: bool,
            default: false
        },
        elementType: (0, _utils.validateType)("TSType")
    }
});
const unionOrIntersection = {
    aliases: [
        "TSType"
    ],
    visitor: [
        "types"
    ],
    fields: {
        types: (0, _utils.validateArrayOfType)("TSType")
    }
};
defineType("TSUnionType", unionOrIntersection);
defineType("TSIntersectionType", unionOrIntersection);
defineType("TSConditionalType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "checkType",
        "extendsType",
        "trueType",
        "falseType"
    ],
    fields: {
        checkType: (0, _utils.validateType)("TSType"),
        extendsType: (0, _utils.validateType)("TSType"),
        trueType: (0, _utils.validateType)("TSType"),
        falseType: (0, _utils.validateType)("TSType")
    }
});
defineType("TSInferType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeParameter"
    ],
    fields: {
        typeParameter: (0, _utils.validateType)("TSTypeParameter")
    }
});
defineType("TSParenthesizedType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSTypeOperator", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSIndexedAccessType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "objectType",
        "indexType"
    ],
    fields: {
        objectType: (0, _utils.validateType)("TSType"),
        indexType: (0, _utils.validateType)("TSType")
    }
});
defineType("TSMappedType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeParameter",
        "typeAnnotation",
        "nameType"
    ],
    fields: {
        readonly: (0, _utils.validateOptional)(bool),
        typeParameter: (0, _utils.validateType)("TSTypeParameter"),
        optional: (0, _utils.validateOptional)(bool),
        typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
        nameType: (0, _utils.validateOptionalType)("TSType")
    }
});
defineType("TSLiteralType", {
    aliases: [
        "TSType",
        "TSBaseType"
    ],
    visitor: [
        "literal"
    ],
    fields: {
        literal: {
            validate: function() {
                const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
                const unaryOperator = (0, _utils.assertOneOf)("-");
                const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral");
                function validator(parent, key, node) {
                    if ((0, _is.default)("UnaryExpression", node)) {
                        unaryOperator(node, "operator", node.operator);
                        unaryExpression(node, "argument", node.argument);
                    } else literal(parent, key, node);
                }
                validator.oneOfNodeTypes = [
                    "NumericLiteral",
                    "StringLiteral",
                    "BooleanLiteral",
                    "BigIntLiteral",
                    "UnaryExpression"
                ];
                return validator;
            }()
        }
    }
});
defineType("TSExpressionWithTypeArguments", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "expression",
        "typeParameters"
    ],
    fields: {
        expression: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
});
defineType("TSInterfaceDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "typeParameters",
        "extends",
        "body"
    ],
    fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
        body: (0, _utils.validateType)("TSInterfaceBody")
    }
});
defineType("TSInterfaceBody", {
    visitor: [
        "body"
    ],
    fields: {
        body: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
});
defineType("TSTypeAliasDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "typeParameters",
        "typeAnnotation"
    ],
    fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSAsExpression", {
    aliases: [
        "Expression"
    ],
    visitor: [
        "expression",
        "typeAnnotation"
    ],
    fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSTypeAssertion", {
    aliases: [
        "Expression"
    ],
    visitor: [
        "typeAnnotation",
        "expression"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TSType"),
        expression: (0, _utils.validateType)("Expression")
    }
});
defineType("TSEnumDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "members"
    ],
    fields: {
        declare: (0, _utils.validateOptional)(bool),
        const: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        members: (0, _utils.validateArrayOfType)("TSEnumMember"),
        initializer: (0, _utils.validateOptionalType)("Expression")
    }
});
defineType("TSEnumMember", {
    visitor: [
        "id",
        "initializer"
    ],
    fields: {
        id: (0, _utils.validateType)([
            "Identifier",
            "StringLiteral"
        ]),
        initializer: (0, _utils.validateOptionalType)("Expression")
    }
});
defineType("TSModuleDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "body"
    ],
    fields: {
        declare: (0, _utils.validateOptional)(bool),
        global: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)([
            "Identifier",
            "StringLiteral"
        ]),
        body: (0, _utils.validateType)([
            "TSModuleBlock",
            "TSModuleDeclaration"
        ])
    }
});
defineType("TSModuleBlock", {
    aliases: [
        "Scopable",
        "Block",
        "BlockParent"
    ],
    visitor: [
        "body"
    ],
    fields: {
        body: (0, _utils.validateArrayOfType)("Statement")
    }
});
defineType("TSImportType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "argument",
        "qualifier",
        "typeParameters"
    ],
    fields: {
        argument: (0, _utils.validateType)("StringLiteral"),
        qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
});
defineType("TSImportEqualsDeclaration", {
    aliases: [
        "Statement"
    ],
    visitor: [
        "id",
        "moduleReference"
    ],
    fields: {
        isExport: (0, _utils.validate)(bool),
        id: (0, _utils.validateType)("Identifier"),
        moduleReference: (0, _utils.validateType)([
            "TSEntityName",
            "TSExternalModuleReference"
        ]),
        importKind: {
            validate: (0, _utils.assertOneOf)("type", "value"),
            optional: true
        }
    }
});
defineType("TSExternalModuleReference", {
    visitor: [
        "expression"
    ],
    fields: {
        expression: (0, _utils.validateType)("StringLiteral")
    }
});
defineType("TSNonNullExpression", {
    aliases: [
        "Expression"
    ],
    visitor: [
        "expression"
    ],
    fields: {
        expression: (0, _utils.validateType)("Expression")
    }
});
defineType("TSExportAssignment", {
    aliases: [
        "Statement"
    ],
    visitor: [
        "expression"
    ],
    fields: {
        expression: (0, _utils.validateType)("Expression")
    }
});
defineType("TSNamespaceExportDeclaration", {
    aliases: [
        "Statement"
    ],
    visitor: [
        "id"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier")
    }
});
defineType("TSTypeAnnotation", {
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TSType")
        }
    }
});
defineType("TSTypeParameterInstantiation", {
    visitor: [
        "params"
    ],
    fields: {
        params: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
        }
    }
});
defineType("TSTypeParameterDeclaration", {
    visitor: [
        "params"
    ],
    fields: {
        params: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
        }
    }
});
defineType("TSTypeParameter", {
    builder: [
        "constraint",
        "default",
        "name"
    ],
    visitor: [
        "constraint",
        "default"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertValueType)("string")
        },
        constraint: {
            validate: (0, _utils.assertNodeType)("TSType"),
            optional: true
        },
        default: {
            validate: (0, _utils.assertNodeType)("TSType"),
            optional: true
        }
    }
});

},{"./utils":"biHkc","./core":"bgLKg","../validators/is":"bRiMB"}],"g6xvm":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = assertNode;
var _isNode = require("../validators/isNode");
function assertNode(node) {
    if (!(0, _isNode.default)(node)) {
        var _node$type;
        const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
        throw new TypeError(`Not a valid node of type "${type}"`);
    }
}

},{"../validators/isNode":"83tOM"}],"83tOM":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isNode;
var _definitions = require("../definitions");
function isNode(node) {
    return !!(node && _definitions.VISITOR_KEYS[node.type]);
}

},{"../definitions":"iA9Wj"}],"dh9Dr":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
exports.assertArrayExpression = assertArrayExpression;
exports.assertArrayPattern = assertArrayPattern;
exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
exports.assertAssignmentExpression = assertAssignmentExpression;
exports.assertAssignmentPattern = assertAssignmentPattern;
exports.assertAwaitExpression = assertAwaitExpression;
exports.assertBigIntLiteral = assertBigIntLiteral;
exports.assertBinary = assertBinary;
exports.assertBinaryExpression = assertBinaryExpression;
exports.assertBindExpression = assertBindExpression;
exports.assertBlock = assertBlock;
exports.assertBlockParent = assertBlockParent;
exports.assertBlockStatement = assertBlockStatement;
exports.assertBooleanLiteral = assertBooleanLiteral;
exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
exports.assertBreakStatement = assertBreakStatement;
exports.assertCallExpression = assertCallExpression;
exports.assertCatchClause = assertCatchClause;
exports.assertClass = assertClass;
exports.assertClassBody = assertClassBody;
exports.assertClassDeclaration = assertClassDeclaration;
exports.assertClassExpression = assertClassExpression;
exports.assertClassImplements = assertClassImplements;
exports.assertClassMethod = assertClassMethod;
exports.assertClassPrivateMethod = assertClassPrivateMethod;
exports.assertClassPrivateProperty = assertClassPrivateProperty;
exports.assertClassProperty = assertClassProperty;
exports.assertCompletionStatement = assertCompletionStatement;
exports.assertConditional = assertConditional;
exports.assertConditionalExpression = assertConditionalExpression;
exports.assertContinueStatement = assertContinueStatement;
exports.assertDebuggerStatement = assertDebuggerStatement;
exports.assertDecimalLiteral = assertDecimalLiteral;
exports.assertDeclaration = assertDeclaration;
exports.assertDeclareClass = assertDeclareClass;
exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
exports.assertDeclareFunction = assertDeclareFunction;
exports.assertDeclareInterface = assertDeclareInterface;
exports.assertDeclareModule = assertDeclareModule;
exports.assertDeclareModuleExports = assertDeclareModuleExports;
exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
exports.assertDeclareVariable = assertDeclareVariable;
exports.assertDeclaredPredicate = assertDeclaredPredicate;
exports.assertDecorator = assertDecorator;
exports.assertDirective = assertDirective;
exports.assertDirectiveLiteral = assertDirectiveLiteral;
exports.assertDoExpression = assertDoExpression;
exports.assertDoWhileStatement = assertDoWhileStatement;
exports.assertEmptyStatement = assertEmptyStatement;
exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
exports.assertEnumBody = assertEnumBody;
exports.assertEnumBooleanBody = assertEnumBooleanBody;
exports.assertEnumBooleanMember = assertEnumBooleanMember;
exports.assertEnumDeclaration = assertEnumDeclaration;
exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
exports.assertEnumMember = assertEnumMember;
exports.assertEnumNumberBody = assertEnumNumberBody;
exports.assertEnumNumberMember = assertEnumNumberMember;
exports.assertEnumStringBody = assertEnumStringBody;
exports.assertEnumStringMember = assertEnumStringMember;
exports.assertEnumSymbolBody = assertEnumSymbolBody;
exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
exports.assertExportAllDeclaration = assertExportAllDeclaration;
exports.assertExportDeclaration = assertExportDeclaration;
exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
exports.assertExportSpecifier = assertExportSpecifier;
exports.assertExpression = assertExpression;
exports.assertExpressionStatement = assertExpressionStatement;
exports.assertExpressionWrapper = assertExpressionWrapper;
exports.assertFile = assertFile;
exports.assertFlow = assertFlow;
exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
exports.assertFlowDeclaration = assertFlowDeclaration;
exports.assertFlowPredicate = assertFlowPredicate;
exports.assertFlowType = assertFlowType;
exports.assertFor = assertFor;
exports.assertForInStatement = assertForInStatement;
exports.assertForOfStatement = assertForOfStatement;
exports.assertForStatement = assertForStatement;
exports.assertForXStatement = assertForXStatement;
exports.assertFunction = assertFunction;
exports.assertFunctionDeclaration = assertFunctionDeclaration;
exports.assertFunctionExpression = assertFunctionExpression;
exports.assertFunctionParent = assertFunctionParent;
exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
exports.assertFunctionTypeParam = assertFunctionTypeParam;
exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
exports.assertIdentifier = assertIdentifier;
exports.assertIfStatement = assertIfStatement;
exports.assertImmutable = assertImmutable;
exports.assertImport = assertImport;
exports.assertImportAttribute = assertImportAttribute;
exports.assertImportDeclaration = assertImportDeclaration;
exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
exports.assertImportSpecifier = assertImportSpecifier;
exports.assertIndexedAccessType = assertIndexedAccessType;
exports.assertInferredPredicate = assertInferredPredicate;
exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
exports.assertInterfaceExtends = assertInterfaceExtends;
exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
exports.assertInterpreterDirective = assertInterpreterDirective;
exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
exports.assertJSX = assertJSX;
exports.assertJSXAttribute = assertJSXAttribute;
exports.assertJSXClosingElement = assertJSXClosingElement;
exports.assertJSXClosingFragment = assertJSXClosingFragment;
exports.assertJSXElement = assertJSXElement;
exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
exports.assertJSXFragment = assertJSXFragment;
exports.assertJSXIdentifier = assertJSXIdentifier;
exports.assertJSXMemberExpression = assertJSXMemberExpression;
exports.assertJSXNamespacedName = assertJSXNamespacedName;
exports.assertJSXOpeningElement = assertJSXOpeningElement;
exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
exports.assertJSXSpreadChild = assertJSXSpreadChild;
exports.assertJSXText = assertJSXText;
exports.assertLVal = assertLVal;
exports.assertLabeledStatement = assertLabeledStatement;
exports.assertLiteral = assertLiteral;
exports.assertLogicalExpression = assertLogicalExpression;
exports.assertLoop = assertLoop;
exports.assertMemberExpression = assertMemberExpression;
exports.assertMetaProperty = assertMetaProperty;
exports.assertMethod = assertMethod;
exports.assertMiscellaneous = assertMiscellaneous;
exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
exports.assertModuleDeclaration = assertModuleDeclaration;
exports.assertModuleExpression = assertModuleExpression;
exports.assertModuleSpecifier = assertModuleSpecifier;
exports.assertNewExpression = assertNewExpression;
exports.assertNoop = assertNoop;
exports.assertNullLiteral = assertNullLiteral;
exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
exports.assertNumberLiteral = assertNumberLiteral;
exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
exports.assertNumericLiteral = assertNumericLiteral;
exports.assertObjectExpression = assertObjectExpression;
exports.assertObjectMember = assertObjectMember;
exports.assertObjectMethod = assertObjectMethod;
exports.assertObjectPattern = assertObjectPattern;
exports.assertObjectProperty = assertObjectProperty;
exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
exports.assertObjectTypeProperty = assertObjectTypeProperty;
exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
exports.assertOpaqueType = assertOpaqueType;
exports.assertOptionalCallExpression = assertOptionalCallExpression;
exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
exports.assertParenthesizedExpression = assertParenthesizedExpression;
exports.assertPattern = assertPattern;
exports.assertPatternLike = assertPatternLike;
exports.assertPipelineBareFunction = assertPipelineBareFunction;
exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
exports.assertPlaceholder = assertPlaceholder;
exports.assertPrivate = assertPrivate;
exports.assertPrivateName = assertPrivateName;
exports.assertProgram = assertProgram;
exports.assertProperty = assertProperty;
exports.assertPureish = assertPureish;
exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
exports.assertRecordExpression = assertRecordExpression;
exports.assertRegExpLiteral = assertRegExpLiteral;
exports.assertRegexLiteral = assertRegexLiteral;
exports.assertRestElement = assertRestElement;
exports.assertRestProperty = assertRestProperty;
exports.assertReturnStatement = assertReturnStatement;
exports.assertScopable = assertScopable;
exports.assertSequenceExpression = assertSequenceExpression;
exports.assertSpreadElement = assertSpreadElement;
exports.assertSpreadProperty = assertSpreadProperty;
exports.assertStandardized = assertStandardized;
exports.assertStatement = assertStatement;
exports.assertStaticBlock = assertStaticBlock;
exports.assertStringLiteral = assertStringLiteral;
exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
exports.assertSuper = assertSuper;
exports.assertSwitchCase = assertSwitchCase;
exports.assertSwitchStatement = assertSwitchStatement;
exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
exports.assertTSAnyKeyword = assertTSAnyKeyword;
exports.assertTSArrayType = assertTSArrayType;
exports.assertTSAsExpression = assertTSAsExpression;
exports.assertTSBaseType = assertTSBaseType;
exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
exports.assertTSConditionalType = assertTSConditionalType;
exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
exports.assertTSConstructorType = assertTSConstructorType;
exports.assertTSDeclareFunction = assertTSDeclareFunction;
exports.assertTSDeclareMethod = assertTSDeclareMethod;
exports.assertTSEntityName = assertTSEntityName;
exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
exports.assertTSEnumMember = assertTSEnumMember;
exports.assertTSExportAssignment = assertTSExportAssignment;
exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
exports.assertTSFunctionType = assertTSFunctionType;
exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
exports.assertTSImportType = assertTSImportType;
exports.assertTSIndexSignature = assertTSIndexSignature;
exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
exports.assertTSInferType = assertTSInferType;
exports.assertTSInterfaceBody = assertTSInterfaceBody;
exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
exports.assertTSIntersectionType = assertTSIntersectionType;
exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
exports.assertTSLiteralType = assertTSLiteralType;
exports.assertTSMappedType = assertTSMappedType;
exports.assertTSMethodSignature = assertTSMethodSignature;
exports.assertTSModuleBlock = assertTSModuleBlock;
exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
exports.assertTSNeverKeyword = assertTSNeverKeyword;
exports.assertTSNonNullExpression = assertTSNonNullExpression;
exports.assertTSNullKeyword = assertTSNullKeyword;
exports.assertTSNumberKeyword = assertTSNumberKeyword;
exports.assertTSObjectKeyword = assertTSObjectKeyword;
exports.assertTSOptionalType = assertTSOptionalType;
exports.assertTSParameterProperty = assertTSParameterProperty;
exports.assertTSParenthesizedType = assertTSParenthesizedType;
exports.assertTSPropertySignature = assertTSPropertySignature;
exports.assertTSQualifiedName = assertTSQualifiedName;
exports.assertTSRestType = assertTSRestType;
exports.assertTSStringKeyword = assertTSStringKeyword;
exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
exports.assertTSThisType = assertTSThisType;
exports.assertTSTupleType = assertTSTupleType;
exports.assertTSType = assertTSType;
exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
exports.assertTSTypeAssertion = assertTSTypeAssertion;
exports.assertTSTypeElement = assertTSTypeElement;
exports.assertTSTypeLiteral = assertTSTypeLiteral;
exports.assertTSTypeOperator = assertTSTypeOperator;
exports.assertTSTypeParameter = assertTSTypeParameter;
exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
exports.assertTSTypePredicate = assertTSTypePredicate;
exports.assertTSTypeQuery = assertTSTypeQuery;
exports.assertTSTypeReference = assertTSTypeReference;
exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
exports.assertTSUnionType = assertTSUnionType;
exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
exports.assertTSVoidKeyword = assertTSVoidKeyword;
exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
exports.assertTemplateElement = assertTemplateElement;
exports.assertTemplateLiteral = assertTemplateLiteral;
exports.assertTerminatorless = assertTerminatorless;
exports.assertThisExpression = assertThisExpression;
exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
exports.assertThrowStatement = assertThrowStatement;
exports.assertTopicReference = assertTopicReference;
exports.assertTryStatement = assertTryStatement;
exports.assertTupleExpression = assertTupleExpression;
exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
exports.assertTypeAlias = assertTypeAlias;
exports.assertTypeAnnotation = assertTypeAnnotation;
exports.assertTypeCastExpression = assertTypeCastExpression;
exports.assertTypeParameter = assertTypeParameter;
exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
exports.assertTypeScript = assertTypeScript;
exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
exports.assertUnaryExpression = assertUnaryExpression;
exports.assertUnaryLike = assertUnaryLike;
exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
exports.assertUpdateExpression = assertUpdateExpression;
exports.assertUserWhitespacable = assertUserWhitespacable;
exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
exports.assertVariableDeclaration = assertVariableDeclaration;
exports.assertVariableDeclarator = assertVariableDeclarator;
exports.assertVariance = assertVariance;
exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
exports.assertWhile = assertWhile;
exports.assertWhileStatement = assertWhileStatement;
exports.assertWithStatement = assertWithStatement;
exports.assertYieldExpression = assertYieldExpression;
var _is = require("../../validators/is");
function assert(type, node, opts) {
    if (!(0, _is.default)(type, node, opts)) throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, ` + `but instead got "${node.type}".`);
}
function assertArrayExpression(node, opts) {
    assert("ArrayExpression", node, opts);
}
function assertAssignmentExpression(node, opts) {
    assert("AssignmentExpression", node, opts);
}
function assertBinaryExpression(node, opts) {
    assert("BinaryExpression", node, opts);
}
function assertInterpreterDirective(node, opts) {
    assert("InterpreterDirective", node, opts);
}
function assertDirective(node, opts) {
    assert("Directive", node, opts);
}
function assertDirectiveLiteral(node, opts) {
    assert("DirectiveLiteral", node, opts);
}
function assertBlockStatement(node, opts) {
    assert("BlockStatement", node, opts);
}
function assertBreakStatement(node, opts) {
    assert("BreakStatement", node, opts);
}
function assertCallExpression(node, opts) {
    assert("CallExpression", node, opts);
}
function assertCatchClause(node, opts) {
    assert("CatchClause", node, opts);
}
function assertConditionalExpression(node, opts) {
    assert("ConditionalExpression", node, opts);
}
function assertContinueStatement(node, opts) {
    assert("ContinueStatement", node, opts);
}
function assertDebuggerStatement(node, opts) {
    assert("DebuggerStatement", node, opts);
}
function assertDoWhileStatement(node, opts) {
    assert("DoWhileStatement", node, opts);
}
function assertEmptyStatement(node, opts) {
    assert("EmptyStatement", node, opts);
}
function assertExpressionStatement(node, opts) {
    assert("ExpressionStatement", node, opts);
}
function assertFile(node, opts) {
    assert("File", node, opts);
}
function assertForInStatement(node, opts) {
    assert("ForInStatement", node, opts);
}
function assertForStatement(node, opts) {
    assert("ForStatement", node, opts);
}
function assertFunctionDeclaration(node, opts) {
    assert("FunctionDeclaration", node, opts);
}
function assertFunctionExpression(node, opts) {
    assert("FunctionExpression", node, opts);
}
function assertIdentifier(node, opts) {
    assert("Identifier", node, opts);
}
function assertIfStatement(node, opts) {
    assert("IfStatement", node, opts);
}
function assertLabeledStatement(node, opts) {
    assert("LabeledStatement", node, opts);
}
function assertStringLiteral(node, opts) {
    assert("StringLiteral", node, opts);
}
function assertNumericLiteral(node, opts) {
    assert("NumericLiteral", node, opts);
}
function assertNullLiteral(node, opts) {
    assert("NullLiteral", node, opts);
}
function assertBooleanLiteral(node, opts) {
    assert("BooleanLiteral", node, opts);
}
function assertRegExpLiteral(node, opts) {
    assert("RegExpLiteral", node, opts);
}
function assertLogicalExpression(node, opts) {
    assert("LogicalExpression", node, opts);
}
function assertMemberExpression(node, opts) {
    assert("MemberExpression", node, opts);
}
function assertNewExpression(node, opts) {
    assert("NewExpression", node, opts);
}
function assertProgram(node, opts) {
    assert("Program", node, opts);
}
function assertObjectExpression(node, opts) {
    assert("ObjectExpression", node, opts);
}
function assertObjectMethod(node, opts) {
    assert("ObjectMethod", node, opts);
}
function assertObjectProperty(node, opts) {
    assert("ObjectProperty", node, opts);
}
function assertRestElement(node, opts) {
    assert("RestElement", node, opts);
}
function assertReturnStatement(node, opts) {
    assert("ReturnStatement", node, opts);
}
function assertSequenceExpression(node, opts) {
    assert("SequenceExpression", node, opts);
}
function assertParenthesizedExpression(node, opts) {
    assert("ParenthesizedExpression", node, opts);
}
function assertSwitchCase(node, opts) {
    assert("SwitchCase", node, opts);
}
function assertSwitchStatement(node, opts) {
    assert("SwitchStatement", node, opts);
}
function assertThisExpression(node, opts) {
    assert("ThisExpression", node, opts);
}
function assertThrowStatement(node, opts) {
    assert("ThrowStatement", node, opts);
}
function assertTryStatement(node, opts) {
    assert("TryStatement", node, opts);
}
function assertUnaryExpression(node, opts) {
    assert("UnaryExpression", node, opts);
}
function assertUpdateExpression(node, opts) {
    assert("UpdateExpression", node, opts);
}
function assertVariableDeclaration(node, opts) {
    assert("VariableDeclaration", node, opts);
}
function assertVariableDeclarator(node, opts) {
    assert("VariableDeclarator", node, opts);
}
function assertWhileStatement(node, opts) {
    assert("WhileStatement", node, opts);
}
function assertWithStatement(node, opts) {
    assert("WithStatement", node, opts);
}
function assertAssignmentPattern(node, opts) {
    assert("AssignmentPattern", node, opts);
}
function assertArrayPattern(node, opts) {
    assert("ArrayPattern", node, opts);
}
function assertArrowFunctionExpression(node, opts) {
    assert("ArrowFunctionExpression", node, opts);
}
function assertClassBody(node, opts) {
    assert("ClassBody", node, opts);
}
function assertClassExpression(node, opts) {
    assert("ClassExpression", node, opts);
}
function assertClassDeclaration(node, opts) {
    assert("ClassDeclaration", node, opts);
}
function assertExportAllDeclaration(node, opts) {
    assert("ExportAllDeclaration", node, opts);
}
function assertExportDefaultDeclaration(node, opts) {
    assert("ExportDefaultDeclaration", node, opts);
}
function assertExportNamedDeclaration(node, opts) {
    assert("ExportNamedDeclaration", node, opts);
}
function assertExportSpecifier(node, opts) {
    assert("ExportSpecifier", node, opts);
}
function assertForOfStatement(node, opts) {
    assert("ForOfStatement", node, opts);
}
function assertImportDeclaration(node, opts) {
    assert("ImportDeclaration", node, opts);
}
function assertImportDefaultSpecifier(node, opts) {
    assert("ImportDefaultSpecifier", node, opts);
}
function assertImportNamespaceSpecifier(node, opts) {
    assert("ImportNamespaceSpecifier", node, opts);
}
function assertImportSpecifier(node, opts) {
    assert("ImportSpecifier", node, opts);
}
function assertMetaProperty(node, opts) {
    assert("MetaProperty", node, opts);
}
function assertClassMethod(node, opts) {
    assert("ClassMethod", node, opts);
}
function assertObjectPattern(node, opts) {
    assert("ObjectPattern", node, opts);
}
function assertSpreadElement(node, opts) {
    assert("SpreadElement", node, opts);
}
function assertSuper(node, opts) {
    assert("Super", node, opts);
}
function assertTaggedTemplateExpression(node, opts) {
    assert("TaggedTemplateExpression", node, opts);
}
function assertTemplateElement(node, opts) {
    assert("TemplateElement", node, opts);
}
function assertTemplateLiteral(node, opts) {
    assert("TemplateLiteral", node, opts);
}
function assertYieldExpression(node, opts) {
    assert("YieldExpression", node, opts);
}
function assertAwaitExpression(node, opts) {
    assert("AwaitExpression", node, opts);
}
function assertImport(node, opts) {
    assert("Import", node, opts);
}
function assertBigIntLiteral(node, opts) {
    assert("BigIntLiteral", node, opts);
}
function assertExportNamespaceSpecifier(node, opts) {
    assert("ExportNamespaceSpecifier", node, opts);
}
function assertOptionalMemberExpression(node, opts) {
    assert("OptionalMemberExpression", node, opts);
}
function assertOptionalCallExpression(node, opts) {
    assert("OptionalCallExpression", node, opts);
}
function assertClassProperty(node, opts) {
    assert("ClassProperty", node, opts);
}
function assertClassPrivateProperty(node, opts) {
    assert("ClassPrivateProperty", node, opts);
}
function assertClassPrivateMethod(node, opts) {
    assert("ClassPrivateMethod", node, opts);
}
function assertPrivateName(node, opts) {
    assert("PrivateName", node, opts);
}
function assertStaticBlock(node, opts) {
    assert("StaticBlock", node, opts);
}
function assertAnyTypeAnnotation(node, opts) {
    assert("AnyTypeAnnotation", node, opts);
}
function assertArrayTypeAnnotation(node, opts) {
    assert("ArrayTypeAnnotation", node, opts);
}
function assertBooleanTypeAnnotation(node, opts) {
    assert("BooleanTypeAnnotation", node, opts);
}
function assertBooleanLiteralTypeAnnotation(node, opts) {
    assert("BooleanLiteralTypeAnnotation", node, opts);
}
function assertNullLiteralTypeAnnotation(node, opts) {
    assert("NullLiteralTypeAnnotation", node, opts);
}
function assertClassImplements(node, opts) {
    assert("ClassImplements", node, opts);
}
function assertDeclareClass(node, opts) {
    assert("DeclareClass", node, opts);
}
function assertDeclareFunction(node, opts) {
    assert("DeclareFunction", node, opts);
}
function assertDeclareInterface(node, opts) {
    assert("DeclareInterface", node, opts);
}
function assertDeclareModule(node, opts) {
    assert("DeclareModule", node, opts);
}
function assertDeclareModuleExports(node, opts) {
    assert("DeclareModuleExports", node, opts);
}
function assertDeclareTypeAlias(node, opts) {
    assert("DeclareTypeAlias", node, opts);
}
function assertDeclareOpaqueType(node, opts) {
    assert("DeclareOpaqueType", node, opts);
}
function assertDeclareVariable(node, opts) {
    assert("DeclareVariable", node, opts);
}
function assertDeclareExportDeclaration(node, opts) {
    assert("DeclareExportDeclaration", node, opts);
}
function assertDeclareExportAllDeclaration(node, opts) {
    assert("DeclareExportAllDeclaration", node, opts);
}
function assertDeclaredPredicate(node, opts) {
    assert("DeclaredPredicate", node, opts);
}
function assertExistsTypeAnnotation(node, opts) {
    assert("ExistsTypeAnnotation", node, opts);
}
function assertFunctionTypeAnnotation(node, opts) {
    assert("FunctionTypeAnnotation", node, opts);
}
function assertFunctionTypeParam(node, opts) {
    assert("FunctionTypeParam", node, opts);
}
function assertGenericTypeAnnotation(node, opts) {
    assert("GenericTypeAnnotation", node, opts);
}
function assertInferredPredicate(node, opts) {
    assert("InferredPredicate", node, opts);
}
function assertInterfaceExtends(node, opts) {
    assert("InterfaceExtends", node, opts);
}
function assertInterfaceDeclaration(node, opts) {
    assert("InterfaceDeclaration", node, opts);
}
function assertInterfaceTypeAnnotation(node, opts) {
    assert("InterfaceTypeAnnotation", node, opts);
}
function assertIntersectionTypeAnnotation(node, opts) {
    assert("IntersectionTypeAnnotation", node, opts);
}
function assertMixedTypeAnnotation(node, opts) {
    assert("MixedTypeAnnotation", node, opts);
}
function assertEmptyTypeAnnotation(node, opts) {
    assert("EmptyTypeAnnotation", node, opts);
}
function assertNullableTypeAnnotation(node, opts) {
    assert("NullableTypeAnnotation", node, opts);
}
function assertNumberLiteralTypeAnnotation(node, opts) {
    assert("NumberLiteralTypeAnnotation", node, opts);
}
function assertNumberTypeAnnotation(node, opts) {
    assert("NumberTypeAnnotation", node, opts);
}
function assertObjectTypeAnnotation(node, opts) {
    assert("ObjectTypeAnnotation", node, opts);
}
function assertObjectTypeInternalSlot(node, opts) {
    assert("ObjectTypeInternalSlot", node, opts);
}
function assertObjectTypeCallProperty(node, opts) {
    assert("ObjectTypeCallProperty", node, opts);
}
function assertObjectTypeIndexer(node, opts) {
    assert("ObjectTypeIndexer", node, opts);
}
function assertObjectTypeProperty(node, opts) {
    assert("ObjectTypeProperty", node, opts);
}
function assertObjectTypeSpreadProperty(node, opts) {
    assert("ObjectTypeSpreadProperty", node, opts);
}
function assertOpaqueType(node, opts) {
    assert("OpaqueType", node, opts);
}
function assertQualifiedTypeIdentifier(node, opts) {
    assert("QualifiedTypeIdentifier", node, opts);
}
function assertStringLiteralTypeAnnotation(node, opts) {
    assert("StringLiteralTypeAnnotation", node, opts);
}
function assertStringTypeAnnotation(node, opts) {
    assert("StringTypeAnnotation", node, opts);
}
function assertSymbolTypeAnnotation(node, opts) {
    assert("SymbolTypeAnnotation", node, opts);
}
function assertThisTypeAnnotation(node, opts) {
    assert("ThisTypeAnnotation", node, opts);
}
function assertTupleTypeAnnotation(node, opts) {
    assert("TupleTypeAnnotation", node, opts);
}
function assertTypeofTypeAnnotation(node, opts) {
    assert("TypeofTypeAnnotation", node, opts);
}
function assertTypeAlias(node, opts) {
    assert("TypeAlias", node, opts);
}
function assertTypeAnnotation(node, opts) {
    assert("TypeAnnotation", node, opts);
}
function assertTypeCastExpression(node, opts) {
    assert("TypeCastExpression", node, opts);
}
function assertTypeParameter(node, opts) {
    assert("TypeParameter", node, opts);
}
function assertTypeParameterDeclaration(node, opts) {
    assert("TypeParameterDeclaration", node, opts);
}
function assertTypeParameterInstantiation(node, opts) {
    assert("TypeParameterInstantiation", node, opts);
}
function assertUnionTypeAnnotation(node, opts) {
    assert("UnionTypeAnnotation", node, opts);
}
function assertVariance(node, opts) {
    assert("Variance", node, opts);
}
function assertVoidTypeAnnotation(node, opts) {
    assert("VoidTypeAnnotation", node, opts);
}
function assertEnumDeclaration(node, opts) {
    assert("EnumDeclaration", node, opts);
}
function assertEnumBooleanBody(node, opts) {
    assert("EnumBooleanBody", node, opts);
}
function assertEnumNumberBody(node, opts) {
    assert("EnumNumberBody", node, opts);
}
function assertEnumStringBody(node, opts) {
    assert("EnumStringBody", node, opts);
}
function assertEnumSymbolBody(node, opts) {
    assert("EnumSymbolBody", node, opts);
}
function assertEnumBooleanMember(node, opts) {
    assert("EnumBooleanMember", node, opts);
}
function assertEnumNumberMember(node, opts) {
    assert("EnumNumberMember", node, opts);
}
function assertEnumStringMember(node, opts) {
    assert("EnumStringMember", node, opts);
}
function assertEnumDefaultedMember(node, opts) {
    assert("EnumDefaultedMember", node, opts);
}
function assertIndexedAccessType(node, opts) {
    assert("IndexedAccessType", node, opts);
}
function assertOptionalIndexedAccessType(node, opts) {
    assert("OptionalIndexedAccessType", node, opts);
}
function assertJSXAttribute(node, opts) {
    assert("JSXAttribute", node, opts);
}
function assertJSXClosingElement(node, opts) {
    assert("JSXClosingElement", node, opts);
}
function assertJSXElement(node, opts) {
    assert("JSXElement", node, opts);
}
function assertJSXEmptyExpression(node, opts) {
    assert("JSXEmptyExpression", node, opts);
}
function assertJSXExpressionContainer(node, opts) {
    assert("JSXExpressionContainer", node, opts);
}
function assertJSXSpreadChild(node, opts) {
    assert("JSXSpreadChild", node, opts);
}
function assertJSXIdentifier(node, opts) {
    assert("JSXIdentifier", node, opts);
}
function assertJSXMemberExpression(node, opts) {
    assert("JSXMemberExpression", node, opts);
}
function assertJSXNamespacedName(node, opts) {
    assert("JSXNamespacedName", node, opts);
}
function assertJSXOpeningElement(node, opts) {
    assert("JSXOpeningElement", node, opts);
}
function assertJSXSpreadAttribute(node, opts) {
    assert("JSXSpreadAttribute", node, opts);
}
function assertJSXText(node, opts) {
    assert("JSXText", node, opts);
}
function assertJSXFragment(node, opts) {
    assert("JSXFragment", node, opts);
}
function assertJSXOpeningFragment(node, opts) {
    assert("JSXOpeningFragment", node, opts);
}
function assertJSXClosingFragment(node, opts) {
    assert("JSXClosingFragment", node, opts);
}
function assertNoop(node, opts) {
    assert("Noop", node, opts);
}
function assertPlaceholder(node, opts) {
    assert("Placeholder", node, opts);
}
function assertV8IntrinsicIdentifier(node, opts) {
    assert("V8IntrinsicIdentifier", node, opts);
}
function assertArgumentPlaceholder(node, opts) {
    assert("ArgumentPlaceholder", node, opts);
}
function assertBindExpression(node, opts) {
    assert("BindExpression", node, opts);
}
function assertImportAttribute(node, opts) {
    assert("ImportAttribute", node, opts);
}
function assertDecorator(node, opts) {
    assert("Decorator", node, opts);
}
function assertDoExpression(node, opts) {
    assert("DoExpression", node, opts);
}
function assertExportDefaultSpecifier(node, opts) {
    assert("ExportDefaultSpecifier", node, opts);
}
function assertRecordExpression(node, opts) {
    assert("RecordExpression", node, opts);
}
function assertTupleExpression(node, opts) {
    assert("TupleExpression", node, opts);
}
function assertDecimalLiteral(node, opts) {
    assert("DecimalLiteral", node, opts);
}
function assertModuleExpression(node, opts) {
    assert("ModuleExpression", node, opts);
}
function assertTopicReference(node, opts) {
    assert("TopicReference", node, opts);
}
function assertPipelineTopicExpression(node, opts) {
    assert("PipelineTopicExpression", node, opts);
}
function assertPipelineBareFunction(node, opts) {
    assert("PipelineBareFunction", node, opts);
}
function assertPipelinePrimaryTopicReference(node, opts) {
    assert("PipelinePrimaryTopicReference", node, opts);
}
function assertTSParameterProperty(node, opts) {
    assert("TSParameterProperty", node, opts);
}
function assertTSDeclareFunction(node, opts) {
    assert("TSDeclareFunction", node, opts);
}
function assertTSDeclareMethod(node, opts) {
    assert("TSDeclareMethod", node, opts);
}
function assertTSQualifiedName(node, opts) {
    assert("TSQualifiedName", node, opts);
}
function assertTSCallSignatureDeclaration(node, opts) {
    assert("TSCallSignatureDeclaration", node, opts);
}
function assertTSConstructSignatureDeclaration(node, opts) {
    assert("TSConstructSignatureDeclaration", node, opts);
}
function assertTSPropertySignature(node, opts) {
    assert("TSPropertySignature", node, opts);
}
function assertTSMethodSignature(node, opts) {
    assert("TSMethodSignature", node, opts);
}
function assertTSIndexSignature(node, opts) {
    assert("TSIndexSignature", node, opts);
}
function assertTSAnyKeyword(node, opts) {
    assert("TSAnyKeyword", node, opts);
}
function assertTSBooleanKeyword(node, opts) {
    assert("TSBooleanKeyword", node, opts);
}
function assertTSBigIntKeyword(node, opts) {
    assert("TSBigIntKeyword", node, opts);
}
function assertTSIntrinsicKeyword(node, opts) {
    assert("TSIntrinsicKeyword", node, opts);
}
function assertTSNeverKeyword(node, opts) {
    assert("TSNeverKeyword", node, opts);
}
function assertTSNullKeyword(node, opts) {
    assert("TSNullKeyword", node, opts);
}
function assertTSNumberKeyword(node, opts) {
    assert("TSNumberKeyword", node, opts);
}
function assertTSObjectKeyword(node, opts) {
    assert("TSObjectKeyword", node, opts);
}
function assertTSStringKeyword(node, opts) {
    assert("TSStringKeyword", node, opts);
}
function assertTSSymbolKeyword(node, opts) {
    assert("TSSymbolKeyword", node, opts);
}
function assertTSUndefinedKeyword(node, opts) {
    assert("TSUndefinedKeyword", node, opts);
}
function assertTSUnknownKeyword(node, opts) {
    assert("TSUnknownKeyword", node, opts);
}
function assertTSVoidKeyword(node, opts) {
    assert("TSVoidKeyword", node, opts);
}
function assertTSThisType(node, opts) {
    assert("TSThisType", node, opts);
}
function assertTSFunctionType(node, opts) {
    assert("TSFunctionType", node, opts);
}
function assertTSConstructorType(node, opts) {
    assert("TSConstructorType", node, opts);
}
function assertTSTypeReference(node, opts) {
    assert("TSTypeReference", node, opts);
}
function assertTSTypePredicate(node, opts) {
    assert("TSTypePredicate", node, opts);
}
function assertTSTypeQuery(node, opts) {
    assert("TSTypeQuery", node, opts);
}
function assertTSTypeLiteral(node, opts) {
    assert("TSTypeLiteral", node, opts);
}
function assertTSArrayType(node, opts) {
    assert("TSArrayType", node, opts);
}
function assertTSTupleType(node, opts) {
    assert("TSTupleType", node, opts);
}
function assertTSOptionalType(node, opts) {
    assert("TSOptionalType", node, opts);
}
function assertTSRestType(node, opts) {
    assert("TSRestType", node, opts);
}
function assertTSNamedTupleMember(node, opts) {
    assert("TSNamedTupleMember", node, opts);
}
function assertTSUnionType(node, opts) {
    assert("TSUnionType", node, opts);
}
function assertTSIntersectionType(node, opts) {
    assert("TSIntersectionType", node, opts);
}
function assertTSConditionalType(node, opts) {
    assert("TSConditionalType", node, opts);
}
function assertTSInferType(node, opts) {
    assert("TSInferType", node, opts);
}
function assertTSParenthesizedType(node, opts) {
    assert("TSParenthesizedType", node, opts);
}
function assertTSTypeOperator(node, opts) {
    assert("TSTypeOperator", node, opts);
}
function assertTSIndexedAccessType(node, opts) {
    assert("TSIndexedAccessType", node, opts);
}
function assertTSMappedType(node, opts) {
    assert("TSMappedType", node, opts);
}
function assertTSLiteralType(node, opts) {
    assert("TSLiteralType", node, opts);
}
function assertTSExpressionWithTypeArguments(node, opts) {
    assert("TSExpressionWithTypeArguments", node, opts);
}
function assertTSInterfaceDeclaration(node, opts) {
    assert("TSInterfaceDeclaration", node, opts);
}
function assertTSInterfaceBody(node, opts) {
    assert("TSInterfaceBody", node, opts);
}
function assertTSTypeAliasDeclaration(node, opts) {
    assert("TSTypeAliasDeclaration", node, opts);
}
function assertTSAsExpression(node, opts) {
    assert("TSAsExpression", node, opts);
}
function assertTSTypeAssertion(node, opts) {
    assert("TSTypeAssertion", node, opts);
}
function assertTSEnumDeclaration(node, opts) {
    assert("TSEnumDeclaration", node, opts);
}
function assertTSEnumMember(node, opts) {
    assert("TSEnumMember", node, opts);
}
function assertTSModuleDeclaration(node, opts) {
    assert("TSModuleDeclaration", node, opts);
}
function assertTSModuleBlock(node, opts) {
    assert("TSModuleBlock", node, opts);
}
function assertTSImportType(node, opts) {
    assert("TSImportType", node, opts);
}
function assertTSImportEqualsDeclaration(node, opts) {
    assert("TSImportEqualsDeclaration", node, opts);
}
function assertTSExternalModuleReference(node, opts) {
    assert("TSExternalModuleReference", node, opts);
}
function assertTSNonNullExpression(node, opts) {
    assert("TSNonNullExpression", node, opts);
}
function assertTSExportAssignment(node, opts) {
    assert("TSExportAssignment", node, opts);
}
function assertTSNamespaceExportDeclaration(node, opts) {
    assert("TSNamespaceExportDeclaration", node, opts);
}
function assertTSTypeAnnotation(node, opts) {
    assert("TSTypeAnnotation", node, opts);
}
function assertTSTypeParameterInstantiation(node, opts) {
    assert("TSTypeParameterInstantiation", node, opts);
}
function assertTSTypeParameterDeclaration(node, opts) {
    assert("TSTypeParameterDeclaration", node, opts);
}
function assertTSTypeParameter(node, opts) {
    assert("TSTypeParameter", node, opts);
}
function assertStandardized(node, opts) {
    assert("Standardized", node, opts);
}
function assertExpression(node, opts) {
    assert("Expression", node, opts);
}
function assertBinary(node, opts) {
    assert("Binary", node, opts);
}
function assertScopable(node, opts) {
    assert("Scopable", node, opts);
}
function assertBlockParent(node, opts) {
    assert("BlockParent", node, opts);
}
function assertBlock(node, opts) {
    assert("Block", node, opts);
}
function assertStatement(node, opts) {
    assert("Statement", node, opts);
}
function assertTerminatorless(node, opts) {
    assert("Terminatorless", node, opts);
}
function assertCompletionStatement(node, opts) {
    assert("CompletionStatement", node, opts);
}
function assertConditional(node, opts) {
    assert("Conditional", node, opts);
}
function assertLoop(node, opts) {
    assert("Loop", node, opts);
}
function assertWhile(node, opts) {
    assert("While", node, opts);
}
function assertExpressionWrapper(node, opts) {
    assert("ExpressionWrapper", node, opts);
}
function assertFor(node, opts) {
    assert("For", node, opts);
}
function assertForXStatement(node, opts) {
    assert("ForXStatement", node, opts);
}
function assertFunction(node, opts) {
    assert("Function", node, opts);
}
function assertFunctionParent(node, opts) {
    assert("FunctionParent", node, opts);
}
function assertPureish(node, opts) {
    assert("Pureish", node, opts);
}
function assertDeclaration(node, opts) {
    assert("Declaration", node, opts);
}
function assertPatternLike(node, opts) {
    assert("PatternLike", node, opts);
}
function assertLVal(node, opts) {
    assert("LVal", node, opts);
}
function assertTSEntityName(node, opts) {
    assert("TSEntityName", node, opts);
}
function assertLiteral(node, opts) {
    assert("Literal", node, opts);
}
function assertImmutable(node, opts) {
    assert("Immutable", node, opts);
}
function assertUserWhitespacable(node, opts) {
    assert("UserWhitespacable", node, opts);
}
function assertMethod(node, opts) {
    assert("Method", node, opts);
}
function assertObjectMember(node, opts) {
    assert("ObjectMember", node, opts);
}
function assertProperty(node, opts) {
    assert("Property", node, opts);
}
function assertUnaryLike(node, opts) {
    assert("UnaryLike", node, opts);
}
function assertPattern(node, opts) {
    assert("Pattern", node, opts);
}
function assertClass(node, opts) {
    assert("Class", node, opts);
}
function assertModuleDeclaration(node, opts) {
    assert("ModuleDeclaration", node, opts);
}
function assertExportDeclaration(node, opts) {
    assert("ExportDeclaration", node, opts);
}
function assertModuleSpecifier(node, opts) {
    assert("ModuleSpecifier", node, opts);
}
function assertPrivate(node, opts) {
    assert("Private", node, opts);
}
function assertFlow(node, opts) {
    assert("Flow", node, opts);
}
function assertFlowType(node, opts) {
    assert("FlowType", node, opts);
}
function assertFlowBaseAnnotation(node, opts) {
    assert("FlowBaseAnnotation", node, opts);
}
function assertFlowDeclaration(node, opts) {
    assert("FlowDeclaration", node, opts);
}
function assertFlowPredicate(node, opts) {
    assert("FlowPredicate", node, opts);
}
function assertEnumBody(node, opts) {
    assert("EnumBody", node, opts);
}
function assertEnumMember(node, opts) {
    assert("EnumMember", node, opts);
}
function assertJSX(node, opts) {
    assert("JSX", node, opts);
}
function assertMiscellaneous(node, opts) {
    assert("Miscellaneous", node, opts);
}
function assertTypeScript(node, opts) {
    assert("TypeScript", node, opts);
}
function assertTSTypeElement(node, opts) {
    assert("TSTypeElement", node, opts);
}
function assertTSType(node, opts) {
    assert("TSType", node, opts);
}
function assertTSBaseType(node, opts) {
    assert("TSBaseType", node, opts);
}
function assertNumberLiteral(node, opts) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    assert("NumberLiteral", node, opts);
}
function assertRegexLiteral(node, opts) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    assert("RegexLiteral", node, opts);
}
function assertRestProperty(node, opts) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    assert("RestProperty", node, opts);
}
function assertSpreadProperty(node, opts) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    assert("SpreadProperty", node, opts);
}

},{"../../validators/is":"bRiMB"}],"8aSMk":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _generated = require("../generated");
var _default = createTypeAnnotationBasedOnTypeof;
exports.default = _default;
function createTypeAnnotationBasedOnTypeof(type) {
    switch(type){
        case "string":
            return (0, _generated.stringTypeAnnotation)();
        case "number":
            return (0, _generated.numberTypeAnnotation)();
        case "undefined":
            return (0, _generated.voidTypeAnnotation)();
        case "boolean":
            return (0, _generated.booleanTypeAnnotation)();
        case "function":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
        case "object":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
        case "symbol":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
        case "bigint":
            return (0, _generated.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + type);
}

},{"../generated":"hCpMg"}],"5T1it":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createFlowUnionType;
var _generated = require("../generated");
var _removeTypeDuplicates = require("../../modifications/flow/removeTypeDuplicates");
function createFlowUnionType(types) {
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) return flattened[0];
    else return (0, _generated.unionTypeAnnotation)(flattened);
}

},{"../generated":"hCpMg","../../modifications/flow/removeTypeDuplicates":"a8UyD"}],"a8UyD":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removeTypeDuplicates;
var _generated = require("../../validators/generated");
function getQualifiedName(node) {
    return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
}
function removeTypeDuplicates(nodes) {
    const generics = {
    };
    const bases = {
    };
    const typeGroups = new Set();
    const types = [];
    for(let i = 0; i < nodes.length; i++){
        const node = nodes[i];
        if (!node) continue;
        if (types.indexOf(node) >= 0) continue;
        if ((0, _generated.isAnyTypeAnnotation)(node)) return [
            node
        ];
        if ((0, _generated.isFlowBaseAnnotation)(node)) {
            bases[node.type] = node;
            continue;
        }
        if ((0, _generated.isUnionTypeAnnotation)(node)) {
            if (!typeGroups.has(node.types)) {
                nodes = nodes.concat(node.types);
                typeGroups.add(node.types);
            }
            continue;
        }
        if ((0, _generated.isGenericTypeAnnotation)(node)) {
            const name = getQualifiedName(node.id);
            if (generics[name]) {
                let existing = generics[name];
                if (existing.typeParameters) {
                    if (node.typeParameters) existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
                } else existing = node.typeParameters;
            } else generics[name] = node;
            continue;
        }
        types.push(node);
    }
    for (const type of Object.keys(bases))types.push(bases[type]);
    for (const name of Object.keys(generics))types.push(generics[name]);
    return types;
}

},{"../../validators/generated":"4WRSt"}],"5F1Xy":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createTSUnionType;
var _generated = require("../generated");
var _removeTypeDuplicates = require("../../modifications/typescript/removeTypeDuplicates");
function createTSUnionType(typeAnnotations) {
    const types = typeAnnotations.map((type)=>type.typeAnnotation
    );
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) return flattened[0];
    else return (0, _generated.tsUnionType)(flattened);
}

},{"../generated":"hCpMg","../../modifications/typescript/removeTypeDuplicates":"9UlXJ"}],"9UlXJ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removeTypeDuplicates;
var _generated = require("../../validators/generated");
function removeTypeDuplicates(nodes) {
    const generics = {
    };
    const bases = {
    };
    const typeGroups = new Set();
    const types = [];
    for(let i = 0; i < nodes.length; i++){
        const node = nodes[i];
        if (!node) continue;
        if (types.indexOf(node) >= 0) continue;
        if ((0, _generated.isTSAnyKeyword)(node)) return [
            node
        ];
        if ((0, _generated.isTSBaseType)(node)) {
            bases[node.type] = node;
            continue;
        }
        if ((0, _generated.isTSUnionType)(node)) {
            if (!typeGroups.has(node.types)) {
                nodes.push(...node.types);
                typeGroups.add(node.types);
            }
            continue;
        }
        types.push(node);
    }
    for (const type of Object.keys(bases))types.push(bases[type]);
    for (const name of Object.keys(generics))types.push(generics[name]);
    return types;
}

},{"../../validators/generated":"4WRSt"}],"btwPm":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AnyTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.anyTypeAnnotation;
    }
});
Object.defineProperty(exports, "ArgumentPlaceholder", {
    enumerable: true,
    get: function() {
        return _index.argumentPlaceholder;
    }
});
Object.defineProperty(exports, "ArrayExpression", {
    enumerable: true,
    get: function() {
        return _index.arrayExpression;
    }
});
Object.defineProperty(exports, "ArrayPattern", {
    enumerable: true,
    get: function() {
        return _index.arrayPattern;
    }
});
Object.defineProperty(exports, "ArrayTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.arrayTypeAnnotation;
    }
});
Object.defineProperty(exports, "ArrowFunctionExpression", {
    enumerable: true,
    get: function() {
        return _index.arrowFunctionExpression;
    }
});
Object.defineProperty(exports, "AssignmentExpression", {
    enumerable: true,
    get: function() {
        return _index.assignmentExpression;
    }
});
Object.defineProperty(exports, "AssignmentPattern", {
    enumerable: true,
    get: function() {
        return _index.assignmentPattern;
    }
});
Object.defineProperty(exports, "AwaitExpression", {
    enumerable: true,
    get: function() {
        return _index.awaitExpression;
    }
});
Object.defineProperty(exports, "BigIntLiteral", {
    enumerable: true,
    get: function() {
        return _index.bigIntLiteral;
    }
});
Object.defineProperty(exports, "BinaryExpression", {
    enumerable: true,
    get: function() {
        return _index.binaryExpression;
    }
});
Object.defineProperty(exports, "BindExpression", {
    enumerable: true,
    get: function() {
        return _index.bindExpression;
    }
});
Object.defineProperty(exports, "BlockStatement", {
    enumerable: true,
    get: function() {
        return _index.blockStatement;
    }
});
Object.defineProperty(exports, "BooleanLiteral", {
    enumerable: true,
    get: function() {
        return _index.booleanLiteral;
    }
});
Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.booleanLiteralTypeAnnotation;
    }
});
Object.defineProperty(exports, "BooleanTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.booleanTypeAnnotation;
    }
});
Object.defineProperty(exports, "BreakStatement", {
    enumerable: true,
    get: function() {
        return _index.breakStatement;
    }
});
Object.defineProperty(exports, "CallExpression", {
    enumerable: true,
    get: function() {
        return _index.callExpression;
    }
});
Object.defineProperty(exports, "CatchClause", {
    enumerable: true,
    get: function() {
        return _index.catchClause;
    }
});
Object.defineProperty(exports, "ClassBody", {
    enumerable: true,
    get: function() {
        return _index.classBody;
    }
});
Object.defineProperty(exports, "ClassDeclaration", {
    enumerable: true,
    get: function() {
        return _index.classDeclaration;
    }
});
Object.defineProperty(exports, "ClassExpression", {
    enumerable: true,
    get: function() {
        return _index.classExpression;
    }
});
Object.defineProperty(exports, "ClassImplements", {
    enumerable: true,
    get: function() {
        return _index.classImplements;
    }
});
Object.defineProperty(exports, "ClassMethod", {
    enumerable: true,
    get: function() {
        return _index.classMethod;
    }
});
Object.defineProperty(exports, "ClassPrivateMethod", {
    enumerable: true,
    get: function() {
        return _index.classPrivateMethod;
    }
});
Object.defineProperty(exports, "ClassPrivateProperty", {
    enumerable: true,
    get: function() {
        return _index.classPrivateProperty;
    }
});
Object.defineProperty(exports, "ClassProperty", {
    enumerable: true,
    get: function() {
        return _index.classProperty;
    }
});
Object.defineProperty(exports, "ConditionalExpression", {
    enumerable: true,
    get: function() {
        return _index.conditionalExpression;
    }
});
Object.defineProperty(exports, "ContinueStatement", {
    enumerable: true,
    get: function() {
        return _index.continueStatement;
    }
});
Object.defineProperty(exports, "DebuggerStatement", {
    enumerable: true,
    get: function() {
        return _index.debuggerStatement;
    }
});
Object.defineProperty(exports, "DecimalLiteral", {
    enumerable: true,
    get: function() {
        return _index.decimalLiteral;
    }
});
Object.defineProperty(exports, "DeclareClass", {
    enumerable: true,
    get: function() {
        return _index.declareClass;
    }
});
Object.defineProperty(exports, "DeclareExportAllDeclaration", {
    enumerable: true,
    get: function() {
        return _index.declareExportAllDeclaration;
    }
});
Object.defineProperty(exports, "DeclareExportDeclaration", {
    enumerable: true,
    get: function() {
        return _index.declareExportDeclaration;
    }
});
Object.defineProperty(exports, "DeclareFunction", {
    enumerable: true,
    get: function() {
        return _index.declareFunction;
    }
});
Object.defineProperty(exports, "DeclareInterface", {
    enumerable: true,
    get: function() {
        return _index.declareInterface;
    }
});
Object.defineProperty(exports, "DeclareModule", {
    enumerable: true,
    get: function() {
        return _index.declareModule;
    }
});
Object.defineProperty(exports, "DeclareModuleExports", {
    enumerable: true,
    get: function() {
        return _index.declareModuleExports;
    }
});
Object.defineProperty(exports, "DeclareOpaqueType", {
    enumerable: true,
    get: function() {
        return _index.declareOpaqueType;
    }
});
Object.defineProperty(exports, "DeclareTypeAlias", {
    enumerable: true,
    get: function() {
        return _index.declareTypeAlias;
    }
});
Object.defineProperty(exports, "DeclareVariable", {
    enumerable: true,
    get: function() {
        return _index.declareVariable;
    }
});
Object.defineProperty(exports, "DeclaredPredicate", {
    enumerable: true,
    get: function() {
        return _index.declaredPredicate;
    }
});
Object.defineProperty(exports, "Decorator", {
    enumerable: true,
    get: function() {
        return _index.decorator;
    }
});
Object.defineProperty(exports, "Directive", {
    enumerable: true,
    get: function() {
        return _index.directive;
    }
});
Object.defineProperty(exports, "DirectiveLiteral", {
    enumerable: true,
    get: function() {
        return _index.directiveLiteral;
    }
});
Object.defineProperty(exports, "DoExpression", {
    enumerable: true,
    get: function() {
        return _index.doExpression;
    }
});
Object.defineProperty(exports, "DoWhileStatement", {
    enumerable: true,
    get: function() {
        return _index.doWhileStatement;
    }
});
Object.defineProperty(exports, "EmptyStatement", {
    enumerable: true,
    get: function() {
        return _index.emptyStatement;
    }
});
Object.defineProperty(exports, "EmptyTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.emptyTypeAnnotation;
    }
});
Object.defineProperty(exports, "EnumBooleanBody", {
    enumerable: true,
    get: function() {
        return _index.enumBooleanBody;
    }
});
Object.defineProperty(exports, "EnumBooleanMember", {
    enumerable: true,
    get: function() {
        return _index.enumBooleanMember;
    }
});
Object.defineProperty(exports, "EnumDeclaration", {
    enumerable: true,
    get: function() {
        return _index.enumDeclaration;
    }
});
Object.defineProperty(exports, "EnumDefaultedMember", {
    enumerable: true,
    get: function() {
        return _index.enumDefaultedMember;
    }
});
Object.defineProperty(exports, "EnumNumberBody", {
    enumerable: true,
    get: function() {
        return _index.enumNumberBody;
    }
});
Object.defineProperty(exports, "EnumNumberMember", {
    enumerable: true,
    get: function() {
        return _index.enumNumberMember;
    }
});
Object.defineProperty(exports, "EnumStringBody", {
    enumerable: true,
    get: function() {
        return _index.enumStringBody;
    }
});
Object.defineProperty(exports, "EnumStringMember", {
    enumerable: true,
    get: function() {
        return _index.enumStringMember;
    }
});
Object.defineProperty(exports, "EnumSymbolBody", {
    enumerable: true,
    get: function() {
        return _index.enumSymbolBody;
    }
});
Object.defineProperty(exports, "ExistsTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.existsTypeAnnotation;
    }
});
Object.defineProperty(exports, "ExportAllDeclaration", {
    enumerable: true,
    get: function() {
        return _index.exportAllDeclaration;
    }
});
Object.defineProperty(exports, "ExportDefaultDeclaration", {
    enumerable: true,
    get: function() {
        return _index.exportDefaultDeclaration;
    }
});
Object.defineProperty(exports, "ExportDefaultSpecifier", {
    enumerable: true,
    get: function() {
        return _index.exportDefaultSpecifier;
    }
});
Object.defineProperty(exports, "ExportNamedDeclaration", {
    enumerable: true,
    get: function() {
        return _index.exportNamedDeclaration;
    }
});
Object.defineProperty(exports, "ExportNamespaceSpecifier", {
    enumerable: true,
    get: function() {
        return _index.exportNamespaceSpecifier;
    }
});
Object.defineProperty(exports, "ExportSpecifier", {
    enumerable: true,
    get: function() {
        return _index.exportSpecifier;
    }
});
Object.defineProperty(exports, "ExpressionStatement", {
    enumerable: true,
    get: function() {
        return _index.expressionStatement;
    }
});
Object.defineProperty(exports, "File", {
    enumerable: true,
    get: function() {
        return _index.file;
    }
});
Object.defineProperty(exports, "ForInStatement", {
    enumerable: true,
    get: function() {
        return _index.forInStatement;
    }
});
Object.defineProperty(exports, "ForOfStatement", {
    enumerable: true,
    get: function() {
        return _index.forOfStatement;
    }
});
Object.defineProperty(exports, "ForStatement", {
    enumerable: true,
    get: function() {
        return _index.forStatement;
    }
});
Object.defineProperty(exports, "FunctionDeclaration", {
    enumerable: true,
    get: function() {
        return _index.functionDeclaration;
    }
});
Object.defineProperty(exports, "FunctionExpression", {
    enumerable: true,
    get: function() {
        return _index.functionExpression;
    }
});
Object.defineProperty(exports, "FunctionTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.functionTypeAnnotation;
    }
});
Object.defineProperty(exports, "FunctionTypeParam", {
    enumerable: true,
    get: function() {
        return _index.functionTypeParam;
    }
});
Object.defineProperty(exports, "GenericTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.genericTypeAnnotation;
    }
});
Object.defineProperty(exports, "Identifier", {
    enumerable: true,
    get: function() {
        return _index.identifier;
    }
});
Object.defineProperty(exports, "IfStatement", {
    enumerable: true,
    get: function() {
        return _index.ifStatement;
    }
});
Object.defineProperty(exports, "Import", {
    enumerable: true,
    get: function() {
        return _index.import;
    }
});
Object.defineProperty(exports, "ImportAttribute", {
    enumerable: true,
    get: function() {
        return _index.importAttribute;
    }
});
Object.defineProperty(exports, "ImportDeclaration", {
    enumerable: true,
    get: function() {
        return _index.importDeclaration;
    }
});
Object.defineProperty(exports, "ImportDefaultSpecifier", {
    enumerable: true,
    get: function() {
        return _index.importDefaultSpecifier;
    }
});
Object.defineProperty(exports, "ImportNamespaceSpecifier", {
    enumerable: true,
    get: function() {
        return _index.importNamespaceSpecifier;
    }
});
Object.defineProperty(exports, "ImportSpecifier", {
    enumerable: true,
    get: function() {
        return _index.importSpecifier;
    }
});
Object.defineProperty(exports, "IndexedAccessType", {
    enumerable: true,
    get: function() {
        return _index.indexedAccessType;
    }
});
Object.defineProperty(exports, "InferredPredicate", {
    enumerable: true,
    get: function() {
        return _index.inferredPredicate;
    }
});
Object.defineProperty(exports, "InterfaceDeclaration", {
    enumerable: true,
    get: function() {
        return _index.interfaceDeclaration;
    }
});
Object.defineProperty(exports, "InterfaceExtends", {
    enumerable: true,
    get: function() {
        return _index.interfaceExtends;
    }
});
Object.defineProperty(exports, "InterfaceTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.interfaceTypeAnnotation;
    }
});
Object.defineProperty(exports, "InterpreterDirective", {
    enumerable: true,
    get: function() {
        return _index.interpreterDirective;
    }
});
Object.defineProperty(exports, "IntersectionTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.intersectionTypeAnnotation;
    }
});
Object.defineProperty(exports, "JSXAttribute", {
    enumerable: true,
    get: function() {
        return _index.jsxAttribute;
    }
});
Object.defineProperty(exports, "JSXClosingElement", {
    enumerable: true,
    get: function() {
        return _index.jsxClosingElement;
    }
});
Object.defineProperty(exports, "JSXClosingFragment", {
    enumerable: true,
    get: function() {
        return _index.jsxClosingFragment;
    }
});
Object.defineProperty(exports, "JSXElement", {
    enumerable: true,
    get: function() {
        return _index.jsxElement;
    }
});
Object.defineProperty(exports, "JSXEmptyExpression", {
    enumerable: true,
    get: function() {
        return _index.jsxEmptyExpression;
    }
});
Object.defineProperty(exports, "JSXExpressionContainer", {
    enumerable: true,
    get: function() {
        return _index.jsxExpressionContainer;
    }
});
Object.defineProperty(exports, "JSXFragment", {
    enumerable: true,
    get: function() {
        return _index.jsxFragment;
    }
});
Object.defineProperty(exports, "JSXIdentifier", {
    enumerable: true,
    get: function() {
        return _index.jsxIdentifier;
    }
});
Object.defineProperty(exports, "JSXMemberExpression", {
    enumerable: true,
    get: function() {
        return _index.jsxMemberExpression;
    }
});
Object.defineProperty(exports, "JSXNamespacedName", {
    enumerable: true,
    get: function() {
        return _index.jsxNamespacedName;
    }
});
Object.defineProperty(exports, "JSXOpeningElement", {
    enumerable: true,
    get: function() {
        return _index.jsxOpeningElement;
    }
});
Object.defineProperty(exports, "JSXOpeningFragment", {
    enumerable: true,
    get: function() {
        return _index.jsxOpeningFragment;
    }
});
Object.defineProperty(exports, "JSXSpreadAttribute", {
    enumerable: true,
    get: function() {
        return _index.jsxSpreadAttribute;
    }
});
Object.defineProperty(exports, "JSXSpreadChild", {
    enumerable: true,
    get: function() {
        return _index.jsxSpreadChild;
    }
});
Object.defineProperty(exports, "JSXText", {
    enumerable: true,
    get: function() {
        return _index.jsxText;
    }
});
Object.defineProperty(exports, "LabeledStatement", {
    enumerable: true,
    get: function() {
        return _index.labeledStatement;
    }
});
Object.defineProperty(exports, "LogicalExpression", {
    enumerable: true,
    get: function() {
        return _index.logicalExpression;
    }
});
Object.defineProperty(exports, "MemberExpression", {
    enumerable: true,
    get: function() {
        return _index.memberExpression;
    }
});
Object.defineProperty(exports, "MetaProperty", {
    enumerable: true,
    get: function() {
        return _index.metaProperty;
    }
});
Object.defineProperty(exports, "MixedTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.mixedTypeAnnotation;
    }
});
Object.defineProperty(exports, "ModuleExpression", {
    enumerable: true,
    get: function() {
        return _index.moduleExpression;
    }
});
Object.defineProperty(exports, "NewExpression", {
    enumerable: true,
    get: function() {
        return _index.newExpression;
    }
});
Object.defineProperty(exports, "Noop", {
    enumerable: true,
    get: function() {
        return _index.noop;
    }
});
Object.defineProperty(exports, "NullLiteral", {
    enumerable: true,
    get: function() {
        return _index.nullLiteral;
    }
});
Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.nullLiteralTypeAnnotation;
    }
});
Object.defineProperty(exports, "NullableTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.nullableTypeAnnotation;
    }
});
Object.defineProperty(exports, "NumberLiteral", {
    enumerable: true,
    get: function() {
        return _index.numberLiteral;
    }
});
Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.numberLiteralTypeAnnotation;
    }
});
Object.defineProperty(exports, "NumberTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.numberTypeAnnotation;
    }
});
Object.defineProperty(exports, "NumericLiteral", {
    enumerable: true,
    get: function() {
        return _index.numericLiteral;
    }
});
Object.defineProperty(exports, "ObjectExpression", {
    enumerable: true,
    get: function() {
        return _index.objectExpression;
    }
});
Object.defineProperty(exports, "ObjectMethod", {
    enumerable: true,
    get: function() {
        return _index.objectMethod;
    }
});
Object.defineProperty(exports, "ObjectPattern", {
    enumerable: true,
    get: function() {
        return _index.objectPattern;
    }
});
Object.defineProperty(exports, "ObjectProperty", {
    enumerable: true,
    get: function() {
        return _index.objectProperty;
    }
});
Object.defineProperty(exports, "ObjectTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.objectTypeAnnotation;
    }
});
Object.defineProperty(exports, "ObjectTypeCallProperty", {
    enumerable: true,
    get: function() {
        return _index.objectTypeCallProperty;
    }
});
Object.defineProperty(exports, "ObjectTypeIndexer", {
    enumerable: true,
    get: function() {
        return _index.objectTypeIndexer;
    }
});
Object.defineProperty(exports, "ObjectTypeInternalSlot", {
    enumerable: true,
    get: function() {
        return _index.objectTypeInternalSlot;
    }
});
Object.defineProperty(exports, "ObjectTypeProperty", {
    enumerable: true,
    get: function() {
        return _index.objectTypeProperty;
    }
});
Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
    enumerable: true,
    get: function() {
        return _index.objectTypeSpreadProperty;
    }
});
Object.defineProperty(exports, "OpaqueType", {
    enumerable: true,
    get: function() {
        return _index.opaqueType;
    }
});
Object.defineProperty(exports, "OptionalCallExpression", {
    enumerable: true,
    get: function() {
        return _index.optionalCallExpression;
    }
});
Object.defineProperty(exports, "OptionalIndexedAccessType", {
    enumerable: true,
    get: function() {
        return _index.optionalIndexedAccessType;
    }
});
Object.defineProperty(exports, "OptionalMemberExpression", {
    enumerable: true,
    get: function() {
        return _index.optionalMemberExpression;
    }
});
Object.defineProperty(exports, "ParenthesizedExpression", {
    enumerable: true,
    get: function() {
        return _index.parenthesizedExpression;
    }
});
Object.defineProperty(exports, "PipelineBareFunction", {
    enumerable: true,
    get: function() {
        return _index.pipelineBareFunction;
    }
});
Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
    enumerable: true,
    get: function() {
        return _index.pipelinePrimaryTopicReference;
    }
});
Object.defineProperty(exports, "PipelineTopicExpression", {
    enumerable: true,
    get: function() {
        return _index.pipelineTopicExpression;
    }
});
Object.defineProperty(exports, "Placeholder", {
    enumerable: true,
    get: function() {
        return _index.placeholder;
    }
});
Object.defineProperty(exports, "PrivateName", {
    enumerable: true,
    get: function() {
        return _index.privateName;
    }
});
Object.defineProperty(exports, "Program", {
    enumerable: true,
    get: function() {
        return _index.program;
    }
});
Object.defineProperty(exports, "QualifiedTypeIdentifier", {
    enumerable: true,
    get: function() {
        return _index.qualifiedTypeIdentifier;
    }
});
Object.defineProperty(exports, "RecordExpression", {
    enumerable: true,
    get: function() {
        return _index.recordExpression;
    }
});
Object.defineProperty(exports, "RegExpLiteral", {
    enumerable: true,
    get: function() {
        return _index.regExpLiteral;
    }
});
Object.defineProperty(exports, "RegexLiteral", {
    enumerable: true,
    get: function() {
        return _index.regexLiteral;
    }
});
Object.defineProperty(exports, "RestElement", {
    enumerable: true,
    get: function() {
        return _index.restElement;
    }
});
Object.defineProperty(exports, "RestProperty", {
    enumerable: true,
    get: function() {
        return _index.restProperty;
    }
});
Object.defineProperty(exports, "ReturnStatement", {
    enumerable: true,
    get: function() {
        return _index.returnStatement;
    }
});
Object.defineProperty(exports, "SequenceExpression", {
    enumerable: true,
    get: function() {
        return _index.sequenceExpression;
    }
});
Object.defineProperty(exports, "SpreadElement", {
    enumerable: true,
    get: function() {
        return _index.spreadElement;
    }
});
Object.defineProperty(exports, "SpreadProperty", {
    enumerable: true,
    get: function() {
        return _index.spreadProperty;
    }
});
Object.defineProperty(exports, "StaticBlock", {
    enumerable: true,
    get: function() {
        return _index.staticBlock;
    }
});
Object.defineProperty(exports, "StringLiteral", {
    enumerable: true,
    get: function() {
        return _index.stringLiteral;
    }
});
Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.stringLiteralTypeAnnotation;
    }
});
Object.defineProperty(exports, "StringTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.stringTypeAnnotation;
    }
});
Object.defineProperty(exports, "Super", {
    enumerable: true,
    get: function() {
        return _index.super;
    }
});
Object.defineProperty(exports, "SwitchCase", {
    enumerable: true,
    get: function() {
        return _index.switchCase;
    }
});
Object.defineProperty(exports, "SwitchStatement", {
    enumerable: true,
    get: function() {
        return _index.switchStatement;
    }
});
Object.defineProperty(exports, "SymbolTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.symbolTypeAnnotation;
    }
});
Object.defineProperty(exports, "TSAnyKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsAnyKeyword;
    }
});
Object.defineProperty(exports, "TSArrayType", {
    enumerable: true,
    get: function() {
        return _index.tsArrayType;
    }
});
Object.defineProperty(exports, "TSAsExpression", {
    enumerable: true,
    get: function() {
        return _index.tsAsExpression;
    }
});
Object.defineProperty(exports, "TSBigIntKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsBigIntKeyword;
    }
});
Object.defineProperty(exports, "TSBooleanKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsBooleanKeyword;
    }
});
Object.defineProperty(exports, "TSCallSignatureDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsCallSignatureDeclaration;
    }
});
Object.defineProperty(exports, "TSConditionalType", {
    enumerable: true,
    get: function() {
        return _index.tsConditionalType;
    }
});
Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsConstructSignatureDeclaration;
    }
});
Object.defineProperty(exports, "TSConstructorType", {
    enumerable: true,
    get: function() {
        return _index.tsConstructorType;
    }
});
Object.defineProperty(exports, "TSDeclareFunction", {
    enumerable: true,
    get: function() {
        return _index.tsDeclareFunction;
    }
});
Object.defineProperty(exports, "TSDeclareMethod", {
    enumerable: true,
    get: function() {
        return _index.tsDeclareMethod;
    }
});
Object.defineProperty(exports, "TSEnumDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsEnumDeclaration;
    }
});
Object.defineProperty(exports, "TSEnumMember", {
    enumerable: true,
    get: function() {
        return _index.tsEnumMember;
    }
});
Object.defineProperty(exports, "TSExportAssignment", {
    enumerable: true,
    get: function() {
        return _index.tsExportAssignment;
    }
});
Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
    enumerable: true,
    get: function() {
        return _index.tsExpressionWithTypeArguments;
    }
});
Object.defineProperty(exports, "TSExternalModuleReference", {
    enumerable: true,
    get: function() {
        return _index.tsExternalModuleReference;
    }
});
Object.defineProperty(exports, "TSFunctionType", {
    enumerable: true,
    get: function() {
        return _index.tsFunctionType;
    }
});
Object.defineProperty(exports, "TSImportEqualsDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsImportEqualsDeclaration;
    }
});
Object.defineProperty(exports, "TSImportType", {
    enumerable: true,
    get: function() {
        return _index.tsImportType;
    }
});
Object.defineProperty(exports, "TSIndexSignature", {
    enumerable: true,
    get: function() {
        return _index.tsIndexSignature;
    }
});
Object.defineProperty(exports, "TSIndexedAccessType", {
    enumerable: true,
    get: function() {
        return _index.tsIndexedAccessType;
    }
});
Object.defineProperty(exports, "TSInferType", {
    enumerable: true,
    get: function() {
        return _index.tsInferType;
    }
});
Object.defineProperty(exports, "TSInterfaceBody", {
    enumerable: true,
    get: function() {
        return _index.tsInterfaceBody;
    }
});
Object.defineProperty(exports, "TSInterfaceDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsInterfaceDeclaration;
    }
});
Object.defineProperty(exports, "TSIntersectionType", {
    enumerable: true,
    get: function() {
        return _index.tsIntersectionType;
    }
});
Object.defineProperty(exports, "TSIntrinsicKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsIntrinsicKeyword;
    }
});
Object.defineProperty(exports, "TSLiteralType", {
    enumerable: true,
    get: function() {
        return _index.tsLiteralType;
    }
});
Object.defineProperty(exports, "TSMappedType", {
    enumerable: true,
    get: function() {
        return _index.tsMappedType;
    }
});
Object.defineProperty(exports, "TSMethodSignature", {
    enumerable: true,
    get: function() {
        return _index.tsMethodSignature;
    }
});
Object.defineProperty(exports, "TSModuleBlock", {
    enumerable: true,
    get: function() {
        return _index.tsModuleBlock;
    }
});
Object.defineProperty(exports, "TSModuleDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsModuleDeclaration;
    }
});
Object.defineProperty(exports, "TSNamedTupleMember", {
    enumerable: true,
    get: function() {
        return _index.tsNamedTupleMember;
    }
});
Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsNamespaceExportDeclaration;
    }
});
Object.defineProperty(exports, "TSNeverKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsNeverKeyword;
    }
});
Object.defineProperty(exports, "TSNonNullExpression", {
    enumerable: true,
    get: function() {
        return _index.tsNonNullExpression;
    }
});
Object.defineProperty(exports, "TSNullKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsNullKeyword;
    }
});
Object.defineProperty(exports, "TSNumberKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsNumberKeyword;
    }
});
Object.defineProperty(exports, "TSObjectKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsObjectKeyword;
    }
});
Object.defineProperty(exports, "TSOptionalType", {
    enumerable: true,
    get: function() {
        return _index.tsOptionalType;
    }
});
Object.defineProperty(exports, "TSParameterProperty", {
    enumerable: true,
    get: function() {
        return _index.tsParameterProperty;
    }
});
Object.defineProperty(exports, "TSParenthesizedType", {
    enumerable: true,
    get: function() {
        return _index.tsParenthesizedType;
    }
});
Object.defineProperty(exports, "TSPropertySignature", {
    enumerable: true,
    get: function() {
        return _index.tsPropertySignature;
    }
});
Object.defineProperty(exports, "TSQualifiedName", {
    enumerable: true,
    get: function() {
        return _index.tsQualifiedName;
    }
});
Object.defineProperty(exports, "TSRestType", {
    enumerable: true,
    get: function() {
        return _index.tsRestType;
    }
});
Object.defineProperty(exports, "TSStringKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsStringKeyword;
    }
});
Object.defineProperty(exports, "TSSymbolKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsSymbolKeyword;
    }
});
Object.defineProperty(exports, "TSThisType", {
    enumerable: true,
    get: function() {
        return _index.tsThisType;
    }
});
Object.defineProperty(exports, "TSTupleType", {
    enumerable: true,
    get: function() {
        return _index.tsTupleType;
    }
});
Object.defineProperty(exports, "TSTypeAliasDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsTypeAliasDeclaration;
    }
});
Object.defineProperty(exports, "TSTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.tsTypeAnnotation;
    }
});
Object.defineProperty(exports, "TSTypeAssertion", {
    enumerable: true,
    get: function() {
        return _index.tsTypeAssertion;
    }
});
Object.defineProperty(exports, "TSTypeLiteral", {
    enumerable: true,
    get: function() {
        return _index.tsTypeLiteral;
    }
});
Object.defineProperty(exports, "TSTypeOperator", {
    enumerable: true,
    get: function() {
        return _index.tsTypeOperator;
    }
});
Object.defineProperty(exports, "TSTypeParameter", {
    enumerable: true,
    get: function() {
        return _index.tsTypeParameter;
    }
});
Object.defineProperty(exports, "TSTypeParameterDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsTypeParameterDeclaration;
    }
});
Object.defineProperty(exports, "TSTypeParameterInstantiation", {
    enumerable: true,
    get: function() {
        return _index.tsTypeParameterInstantiation;
    }
});
Object.defineProperty(exports, "TSTypePredicate", {
    enumerable: true,
    get: function() {
        return _index.tsTypePredicate;
    }
});
Object.defineProperty(exports, "TSTypeQuery", {
    enumerable: true,
    get: function() {
        return _index.tsTypeQuery;
    }
});
Object.defineProperty(exports, "TSTypeReference", {
    enumerable: true,
    get: function() {
        return _index.tsTypeReference;
    }
});
Object.defineProperty(exports, "TSUndefinedKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsUndefinedKeyword;
    }
});
Object.defineProperty(exports, "TSUnionType", {
    enumerable: true,
    get: function() {
        return _index.tsUnionType;
    }
});
Object.defineProperty(exports, "TSUnknownKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsUnknownKeyword;
    }
});
Object.defineProperty(exports, "TSVoidKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsVoidKeyword;
    }
});
Object.defineProperty(exports, "TaggedTemplateExpression", {
    enumerable: true,
    get: function() {
        return _index.taggedTemplateExpression;
    }
});
Object.defineProperty(exports, "TemplateElement", {
    enumerable: true,
    get: function() {
        return _index.templateElement;
    }
});
Object.defineProperty(exports, "TemplateLiteral", {
    enumerable: true,
    get: function() {
        return _index.templateLiteral;
    }
});
Object.defineProperty(exports, "ThisExpression", {
    enumerable: true,
    get: function() {
        return _index.thisExpression;
    }
});
Object.defineProperty(exports, "ThisTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.thisTypeAnnotation;
    }
});
Object.defineProperty(exports, "ThrowStatement", {
    enumerable: true,
    get: function() {
        return _index.throwStatement;
    }
});
Object.defineProperty(exports, "TopicReference", {
    enumerable: true,
    get: function() {
        return _index.topicReference;
    }
});
Object.defineProperty(exports, "TryStatement", {
    enumerable: true,
    get: function() {
        return _index.tryStatement;
    }
});
Object.defineProperty(exports, "TupleExpression", {
    enumerable: true,
    get: function() {
        return _index.tupleExpression;
    }
});
Object.defineProperty(exports, "TupleTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.tupleTypeAnnotation;
    }
});
Object.defineProperty(exports, "TypeAlias", {
    enumerable: true,
    get: function() {
        return _index.typeAlias;
    }
});
Object.defineProperty(exports, "TypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.typeAnnotation;
    }
});
Object.defineProperty(exports, "TypeCastExpression", {
    enumerable: true,
    get: function() {
        return _index.typeCastExpression;
    }
});
Object.defineProperty(exports, "TypeParameter", {
    enumerable: true,
    get: function() {
        return _index.typeParameter;
    }
});
Object.defineProperty(exports, "TypeParameterDeclaration", {
    enumerable: true,
    get: function() {
        return _index.typeParameterDeclaration;
    }
});
Object.defineProperty(exports, "TypeParameterInstantiation", {
    enumerable: true,
    get: function() {
        return _index.typeParameterInstantiation;
    }
});
Object.defineProperty(exports, "TypeofTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.typeofTypeAnnotation;
    }
});
Object.defineProperty(exports, "UnaryExpression", {
    enumerable: true,
    get: function() {
        return _index.unaryExpression;
    }
});
Object.defineProperty(exports, "UnionTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.unionTypeAnnotation;
    }
});
Object.defineProperty(exports, "UpdateExpression", {
    enumerable: true,
    get: function() {
        return _index.updateExpression;
    }
});
Object.defineProperty(exports, "V8IntrinsicIdentifier", {
    enumerable: true,
    get: function() {
        return _index.v8IntrinsicIdentifier;
    }
});
Object.defineProperty(exports, "VariableDeclaration", {
    enumerable: true,
    get: function() {
        return _index.variableDeclaration;
    }
});
Object.defineProperty(exports, "VariableDeclarator", {
    enumerable: true,
    get: function() {
        return _index.variableDeclarator;
    }
});
Object.defineProperty(exports, "Variance", {
    enumerable: true,
    get: function() {
        return _index.variance;
    }
});
Object.defineProperty(exports, "VoidTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.voidTypeAnnotation;
    }
});
Object.defineProperty(exports, "WhileStatement", {
    enumerable: true,
    get: function() {
        return _index.whileStatement;
    }
});
Object.defineProperty(exports, "WithStatement", {
    enumerable: true,
    get: function() {
        return _index.withStatement;
    }
});
Object.defineProperty(exports, "YieldExpression", {
    enumerable: true,
    get: function() {
        return _index.yieldExpression;
    }
});
var _index = require("./index");

},{"./index":"hCpMg"}],"drsCY":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cloneNode;
var _definitions = require("../definitions");
var _generated = require("../validators/generated");
const has = Function.call.bind(Object.prototype.hasOwnProperty);
function cloneIfNode(obj, deep, withoutLoc) {
    if (obj && typeof obj.type === "string") return cloneNode(obj, deep, withoutLoc);
    return obj;
}
function cloneIfNodeOrArray(obj, deep, withoutLoc) {
    if (Array.isArray(obj)) return obj.map((node)=>cloneIfNode(node, deep, withoutLoc)
    );
    return cloneIfNode(obj, deep, withoutLoc);
}
function cloneNode(node, deep = true, withoutLoc = false) {
    if (!node) return node;
    const { type  } = node;
    const newNode = {
        type: node.type
    };
    if ((0, _generated.isIdentifier)(node)) {
        newNode.name = node.name;
        if (has(node, "optional") && typeof node.optional === "boolean") newNode.optional = node.optional;
        if (has(node, "typeAnnotation")) newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;
    } else if (!has(_definitions.NODE_FIELDS, type)) throw new Error(`Unknown node type: "${type}"`);
    else {
        for (const field of Object.keys(_definitions.NODE_FIELDS[type]))if (has(node, field)) {
            if (deep) newNode[field] = (0, _generated.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);
            else newNode[field] = node[field];
        }
    }
    if (has(node, "loc")) {
        if (withoutLoc) newNode.loc = null;
        else newNode.loc = node.loc;
    }
    if (has(node, "leadingComments")) newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);
    if (has(node, "innerComments")) newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);
    if (has(node, "trailingComments")) newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);
    if (has(node, "extra")) newNode.extra = Object.assign({
    }, node.extra);
    return newNode;
}
function maybeCloneComments(comments, deep, withoutLoc) {
    if (!comments || !deep) return comments;
    return comments.map(({ type , value , loc  })=>{
        if (withoutLoc) return {
            type,
            value,
            loc: null
        };
        return {
            type,
            value,
            loc
        };
    });
}

},{"../definitions":"iA9Wj","../validators/generated":"4WRSt"}],"eaYGs":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = clone;
var _cloneNode = require("./cloneNode");
function clone(node) {
    return (0, _cloneNode.default)(node, false);
}

},{"./cloneNode":"drsCY"}],"c8KjF":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cloneDeep;
var _cloneNode = require("./cloneNode");
function cloneDeep(node) {
    return (0, _cloneNode.default)(node);
}

},{"./cloneNode":"drsCY"}],"Samcq":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cloneDeepWithoutLoc;
var _cloneNode = require("./cloneNode");
function cloneDeepWithoutLoc(node) {
    return (0, _cloneNode.default)(node, true, true);
}

},{"./cloneNode":"drsCY"}],"1akix":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cloneWithoutLoc;
var _cloneNode = require("./cloneNode");
function cloneWithoutLoc(node) {
    return (0, _cloneNode.default)(node, false, true);
}

},{"./cloneNode":"drsCY"}],"i4fvF":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = addComment;
var _addComments = require("./addComments");
function addComment(node, type, content, line) {
    return (0, _addComments.default)(node, type, [
        {
            type: line ? "CommentLine" : "CommentBlock",
            value: content
        }
    ]);
}

},{"./addComments":"fYJ72"}],"fYJ72":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = addComments;
function addComments(node, type, comments) {
    if (!comments || !node) return node;
    const key = `${type}Comments`;
    if (node[key]) {
        if (type === "leading") node[key] = comments.concat(node[key]);
        else node[key].push(...comments);
    } else node[key] = comments;
    return node;
}

},{}],"fKVCQ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inheritInnerComments;
var _inherit = require("../utils/inherit");
function inheritInnerComments(child, parent) {
    (0, _inherit.default)("innerComments", child, parent);
}

},{"../utils/inherit":"aQuCz"}],"aQuCz":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inherit;
function inherit(key, child, parent) {
    if (child && parent) child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
}

},{}],"dw9pq":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inheritLeadingComments;
var _inherit = require("../utils/inherit");
function inheritLeadingComments(child, parent) {
    (0, _inherit.default)("leadingComments", child, parent);
}

},{"../utils/inherit":"aQuCz"}],"kEqtV":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inheritsComments;
var _inheritTrailingComments = require("./inheritTrailingComments");
var _inheritLeadingComments = require("./inheritLeadingComments");
var _inheritInnerComments = require("./inheritInnerComments");
function inheritsComments(child, parent) {
    (0, _inheritTrailingComments.default)(child, parent);
    (0, _inheritLeadingComments.default)(child, parent);
    (0, _inheritInnerComments.default)(child, parent);
    return child;
}

},{"./inheritTrailingComments":"anJMN","./inheritLeadingComments":"dw9pq","./inheritInnerComments":"fKVCQ"}],"anJMN":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inheritTrailingComments;
var _inherit = require("../utils/inherit");
function inheritTrailingComments(child, parent) {
    (0, _inherit.default)("trailingComments", child, parent);
}

},{"../utils/inherit":"aQuCz"}],"9zkYM":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removeComments;
var _constants = require("../constants");
function removeComments(node) {
    _constants.COMMENT_KEYS.forEach((key)=>{
        node[key] = null;
    });
    return node;
}

},{"../constants":"b9TVI"}],"7tbeC":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = void 0;
var _definitions = require("../../definitions");
const STANDARDIZED_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Standardized"];
exports.STANDARDIZED_TYPES = STANDARDIZED_TYPES;
const EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
const BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
exports.BINARY_TYPES = BINARY_TYPES;
const SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
const BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
const BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
exports.BLOCK_TYPES = BLOCK_TYPES;
const STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
exports.STATEMENT_TYPES = STATEMENT_TYPES;
const TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
const COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
const CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
const LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
exports.LOOP_TYPES = LOOP_TYPES;
const WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
exports.WHILE_TYPES = WHILE_TYPES;
const EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
const FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
exports.FOR_TYPES = FOR_TYPES;
const FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
const FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
exports.FUNCTION_TYPES = FUNCTION_TYPES;
const FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
const PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
exports.PUREISH_TYPES = PUREISH_TYPES;
const DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
exports.DECLARATION_TYPES = DECLARATION_TYPES;
const PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
const LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
exports.LVAL_TYPES = LVAL_TYPES;
const TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
const LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
exports.LITERAL_TYPES = LITERAL_TYPES;
const IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
const USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
const METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
exports.METHOD_TYPES = METHOD_TYPES;
const OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
const PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
exports.PROPERTY_TYPES = PROPERTY_TYPES;
const UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
const PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
exports.PATTERN_TYPES = PATTERN_TYPES;
const CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
exports.CLASS_TYPES = CLASS_TYPES;
const MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
const EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
const MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
const PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];
exports.PRIVATE_TYPES = PRIVATE_TYPES;
const FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
exports.FLOW_TYPES = FLOW_TYPES;
const FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
const FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
const FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
const FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
const ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumBody"];
exports.ENUMBODY_TYPES = ENUMBODY_TYPES;
const ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumMember"];
exports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
const JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
exports.JSX_TYPES = JSX_TYPES;
const MISCELLANEOUS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Miscellaneous"];
exports.MISCELLANEOUS_TYPES = MISCELLANEOUS_TYPES;
const TYPESCRIPT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TypeScript"];
exports.TYPESCRIPT_TYPES = TYPESCRIPT_TYPES;
const TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
const TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
exports.TSTYPE_TYPES = TSTYPE_TYPES;
const TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSBaseType"];
exports.TSBASETYPE_TYPES = TSBASETYPE_TYPES;

},{"../../definitions":"iA9Wj"}],"80Ciq":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = ensureBlock;
var _toBlock = require("./toBlock");
function ensureBlock(node, key = "body") {
    return node[key] = (0, _toBlock.default)(node[key], node);
}

},{"./toBlock":"grhkK"}],"grhkK":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toBlock;
var _generated = require("../validators/generated");
var _generated2 = require("../builders/generated");
function toBlock(node, parent) {
    if ((0, _generated.isBlockStatement)(node)) return node;
    let blockNodes = [];
    if ((0, _generated.isEmptyStatement)(node)) blockNodes = [];
    else {
        if (!(0, _generated.isStatement)(node)) {
            if ((0, _generated.isFunction)(parent)) node = (0, _generated2.returnStatement)(node);
            else node = (0, _generated2.expressionStatement)(node);
        }
        blockNodes = [
            node
        ];
    }
    return (0, _generated2.blockStatement)(blockNodes);
}

},{"../validators/generated":"4WRSt","../builders/generated":"hCpMg"}],"ikqrZ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toBindingIdentifierName;
var _toIdentifier = require("./toIdentifier");
function toBindingIdentifierName(name) {
    name = (0, _toIdentifier.default)(name);
    if (name === "eval" || name === "arguments") name = "_" + name;
    return name;
}

},{"./toIdentifier":"7Gjjf"}],"7Gjjf":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toIdentifier;
var _isValidIdentifier = require("../validators/isValidIdentifier");
var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");
function toIdentifier(input) {
    input = input + "";
    let name = "";
    for (const c1 of input)name += (0, _helperValidatorIdentifier.isIdentifierChar)(c1.codePointAt(0)) ? c1 : "-";
    name = name.replace(/^[-0-9]+/, "");
    name = name.replace(/[-\s]+(.)?/g, function(match, c) {
        return c ? c.toUpperCase() : "";
    });
    if (!(0, _isValidIdentifier.default)(name)) name = `_${name}`;
    return name || "_";
}

},{"../validators/isValidIdentifier":"aPv9j","@babel/helper-validator-identifier":"awkZV"}],"6AJwm":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toComputedKey;
var _generated = require("../validators/generated");
var _generated2 = require("../builders/generated");
function toComputedKey(node, key = node.key || node.property) {
    if (!node.computed && (0, _generated.isIdentifier)(key)) key = (0, _generated2.stringLiteral)(key.name);
    return key;
}

},{"../validators/generated":"4WRSt","../builders/generated":"hCpMg"}],"eVb1C":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _generated = require("../validators/generated");
var _default = toExpression;
exports.default = _default;
function toExpression(node) {
    if ((0, _generated.isExpressionStatement)(node)) node = node.expression;
    if ((0, _generated.isExpression)(node)) return node;
    if ((0, _generated.isClass)(node)) node.type = "ClassExpression";
    else if ((0, _generated.isFunction)(node)) node.type = "FunctionExpression";
    if (!(0, _generated.isExpression)(node)) throw new Error(`cannot turn ${node.type} to an expression`);
    return node;
}

},{"../validators/generated":"4WRSt"}],"dMc5N":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toKeyAlias;
var _generated = require("../validators/generated");
var _cloneNode = require("../clone/cloneNode");
var _removePropertiesDeep = require("../modifications/removePropertiesDeep");
function toKeyAlias(node, key = node.key) {
    let alias;
    if (node.kind === "method") return toKeyAlias.increment() + "";
    else if ((0, _generated.isIdentifier)(key)) alias = key.name;
    else if ((0, _generated.isStringLiteral)(key)) alias = JSON.stringify(key.value);
    else alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
    if (node.computed) alias = `[${alias}]`;
    if (node.static) alias = `static:${alias}`;
    return alias;
}
toKeyAlias.uid = 0;
toKeyAlias.increment = function() {
    if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) return toKeyAlias.uid = 0;
    else return toKeyAlias.uid++;
};

},{"../validators/generated":"4WRSt","../clone/cloneNode":"drsCY","../modifications/removePropertiesDeep":"1fNiX"}],"1fNiX":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removePropertiesDeep;
var _traverseFast = require("../traverse/traverseFast");
var _removeProperties = require("./removeProperties");
function removePropertiesDeep(tree, opts) {
    (0, _traverseFast.default)(tree, _removeProperties.default, opts);
    return tree;
}

},{"../traverse/traverseFast":"4e3QR","./removeProperties":"iofQP"}],"4e3QR":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = traverseFast;
var _definitions = require("../definitions");
function traverseFast(node, enter, opts) {
    if (!node) return;
    const keys = _definitions.VISITOR_KEYS[node.type];
    if (!keys) return;
    opts = opts || {
    };
    enter(node, opts);
    for (const key of keys){
        const subNode = node[key];
        if (Array.isArray(subNode)) for (const node1 of subNode)traverseFast(node1, enter, opts);
        else traverseFast(subNode, enter, opts);
    }
}

},{"../definitions":"iA9Wj"}],"iofQP":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removeProperties;
var _constants = require("../constants");
const CLEAR_KEYS = [
    "tokens",
    "start",
    "end",
    "loc",
    "raw",
    "rawValue"
];
const CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat([
    "comments"
]).concat(CLEAR_KEYS);
function removeProperties(node, opts = {
}) {
    const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
    for (const key of map)if (node[key] != null) node[key] = undefined;
    for (const key1 of Object.keys(node))if (key1[0] === "_" && node[key1] != null) node[key1] = undefined;
    const symbols = Object.getOwnPropertySymbols(node);
    for (const sym of symbols)node[sym] = null;
}

},{"../constants":"b9TVI"}],"6FiDO":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toSequenceExpression;
var _gatherSequenceExpressions = require("./gatherSequenceExpressions");
function toSequenceExpression(nodes, scope) {
    if (!(nodes != null && nodes.length)) return;
    const declars = [];
    const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
    if (!result) return;
    for (const declar of declars)scope.push(declar);
    return result;
}

},{"./gatherSequenceExpressions":"7KvON"}],"7KvON":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = gatherSequenceExpressions;
var _getBindingIdentifiers = require("../retrievers/getBindingIdentifiers");
var _generated = require("../validators/generated");
var _generated2 = require("../builders/generated");
var _cloneNode = require("../clone/cloneNode");
function gatherSequenceExpressions(nodes, scope, declars) {
    const exprs = [];
    let ensureLastUndefined = true;
    for (const node of nodes){
        if (!(0, _generated.isEmptyStatement)(node)) ensureLastUndefined = false;
        if ((0, _generated.isExpression)(node)) exprs.push(node);
        else if ((0, _generated.isExpressionStatement)(node)) exprs.push(node.expression);
        else if ((0, _generated.isVariableDeclaration)(node)) {
            if (node.kind !== "var") return;
            for (const declar of node.declarations){
                const bindings = (0, _getBindingIdentifiers.default)(declar);
                for (const key of Object.keys(bindings))declars.push({
                    kind: node.kind,
                    id: (0, _cloneNode.default)(bindings[key])
                });
                if (declar.init) exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
            }
            ensureLastUndefined = true;
        } else if ((0, _generated.isIfStatement)(node)) {
            const consequent = node.consequent ? gatherSequenceExpressions([
                node.consequent
            ], scope, declars) : scope.buildUndefinedNode();
            const alternate = node.alternate ? gatherSequenceExpressions([
                node.alternate
            ], scope, declars) : scope.buildUndefinedNode();
            if (!consequent || !alternate) return;
            exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
        } else if ((0, _generated.isBlockStatement)(node)) {
            const body = gatherSequenceExpressions(node.body, scope, declars);
            if (!body) return;
            exprs.push(body);
        } else if ((0, _generated.isEmptyStatement)(node)) {
            if (nodes.indexOf(node) === 0) ensureLastUndefined = true;
        } else return;
    }
    if (ensureLastUndefined) exprs.push(scope.buildUndefinedNode());
    if (exprs.length === 1) return exprs[0];
    else return (0, _generated2.sequenceExpression)(exprs);
}

},{"../retrievers/getBindingIdentifiers":"hcSqe","../validators/generated":"4WRSt","../builders/generated":"hCpMg","../clone/cloneNode":"drsCY"}],"hcSqe":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getBindingIdentifiers;
var _generated = require("../validators/generated");
function getBindingIdentifiers(node, duplicates, outerOnly) {
    let search = [].concat(node);
    const ids = Object.create(null);
    while(search.length){
        const id = search.shift();
        if (!id) continue;
        const keys = getBindingIdentifiers.keys[id.type];
        if ((0, _generated.isIdentifier)(id)) {
            if (duplicates) {
                const _ids = ids[id.name] = ids[id.name] || [];
                _ids.push(id);
            } else ids[id.name] = id;
            continue;
        }
        if ((0, _generated.isExportDeclaration)(id) && !(0, _generated.isExportAllDeclaration)(id)) {
            if ((0, _generated.isDeclaration)(id.declaration)) search.push(id.declaration);
            continue;
        }
        if (outerOnly) {
            if ((0, _generated.isFunctionDeclaration)(id)) {
                search.push(id.id);
                continue;
            }
            if ((0, _generated.isFunctionExpression)(id)) continue;
        }
        if (keys) for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            if (id[key]) search = search.concat(id[key]);
        }
    }
    return ids;
}
getBindingIdentifiers.keys = {
    DeclareClass: [
        "id"
    ],
    DeclareFunction: [
        "id"
    ],
    DeclareModule: [
        "id"
    ],
    DeclareVariable: [
        "id"
    ],
    DeclareInterface: [
        "id"
    ],
    DeclareTypeAlias: [
        "id"
    ],
    DeclareOpaqueType: [
        "id"
    ],
    InterfaceDeclaration: [
        "id"
    ],
    TypeAlias: [
        "id"
    ],
    OpaqueType: [
        "id"
    ],
    CatchClause: [
        "param"
    ],
    LabeledStatement: [
        "label"
    ],
    UnaryExpression: [
        "argument"
    ],
    AssignmentExpression: [
        "left"
    ],
    ImportSpecifier: [
        "local"
    ],
    ImportNamespaceSpecifier: [
        "local"
    ],
    ImportDefaultSpecifier: [
        "local"
    ],
    ImportDeclaration: [
        "specifiers"
    ],
    ExportSpecifier: [
        "exported"
    ],
    ExportNamespaceSpecifier: [
        "exported"
    ],
    ExportDefaultSpecifier: [
        "exported"
    ],
    FunctionDeclaration: [
        "id",
        "params"
    ],
    FunctionExpression: [
        "id",
        "params"
    ],
    ArrowFunctionExpression: [
        "params"
    ],
    ObjectMethod: [
        "params"
    ],
    ClassMethod: [
        "params"
    ],
    ClassPrivateMethod: [
        "params"
    ],
    ForInStatement: [
        "left"
    ],
    ForOfStatement: [
        "left"
    ],
    ClassDeclaration: [
        "id"
    ],
    ClassExpression: [
        "id"
    ],
    RestElement: [
        "argument"
    ],
    UpdateExpression: [
        "argument"
    ],
    ObjectProperty: [
        "value"
    ],
    AssignmentPattern: [
        "left"
    ],
    ArrayPattern: [
        "elements"
    ],
    ObjectPattern: [
        "properties"
    ],
    VariableDeclaration: [
        "declarations"
    ],
    VariableDeclarator: [
        "id"
    ]
};

},{"../validators/generated":"4WRSt"}],"a4mOK":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _generated = require("../validators/generated");
var _generated2 = require("../builders/generated");
var _default = toStatement;
exports.default = _default;
function toStatement(node, ignore) {
    if ((0, _generated.isStatement)(node)) return node;
    let mustHaveId = false;
    let newType;
    if ((0, _generated.isClass)(node)) {
        mustHaveId = true;
        newType = "ClassDeclaration";
    } else if ((0, _generated.isFunction)(node)) {
        mustHaveId = true;
        newType = "FunctionDeclaration";
    } else if ((0, _generated.isAssignmentExpression)(node)) return (0, _generated2.expressionStatement)(node);
    if (mustHaveId && !node.id) newType = false;
    if (!newType) {
        if (ignore) return false;
        else throw new Error(`cannot turn ${node.type} to a statement`);
    }
    node.type = newType;
    return node;
}

},{"../validators/generated":"4WRSt","../builders/generated":"hCpMg"}],"6CbNq":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _isValidIdentifier = require("../validators/isValidIdentifier");
var _generated = require("../builders/generated");
var _default = valueToNode;
exports.default = _default;
const objectToString = Function.call.bind(Object.prototype.toString);
function isRegExp(value) {
    return objectToString(value) === "[object RegExp]";
}
function isPlainObject(value) {
    if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") return false;
    const proto = Object.getPrototypeOf(value);
    return proto === null || Object.getPrototypeOf(proto) === null;
}
function valueToNode(value) {
    if (value === undefined) return (0, _generated.identifier)("undefined");
    if (value === true || value === false) return (0, _generated.booleanLiteral)(value);
    if (value === null) return (0, _generated.nullLiteral)();
    if (typeof value === "string") return (0, _generated.stringLiteral)(value);
    if (typeof value === "number") {
        let result;
        if (Number.isFinite(value)) result = (0, _generated.numericLiteral)(Math.abs(value));
        else {
            let numerator;
            if (Number.isNaN(value)) numerator = (0, _generated.numericLiteral)(0);
            else numerator = (0, _generated.numericLiteral)(1);
            result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
        }
        if (value < 0 || Object.is(value, -0)) result = (0, _generated.unaryExpression)("-", result);
        return result;
    }
    if (isRegExp(value)) {
        const pattern = value.source;
        const flags = value.toString().match(/\/([a-z]+|)$/)[1];
        return (0, _generated.regExpLiteral)(pattern, flags);
    }
    if (Array.isArray(value)) return (0, _generated.arrayExpression)(value.map(valueToNode));
    if (isPlainObject(value)) {
        const props = [];
        for (const key of Object.keys(value)){
            let nodeKey;
            if ((0, _isValidIdentifier.default)(key)) nodeKey = (0, _generated.identifier)(key);
            else nodeKey = (0, _generated.stringLiteral)(key);
            props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
        }
        return (0, _generated.objectExpression)(props);
    }
    throw new Error("don't know how to turn this value into a node");
}

},{"../validators/isValidIdentifier":"aPv9j","../builders/generated":"hCpMg"}],"9rhZT":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = appendToMemberExpression;
var _generated = require("../builders/generated");
function appendToMemberExpression(member, append, computed = false) {
    member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);
    member.property = append;
    member.computed = !!computed;
    return member;
}

},{"../builders/generated":"hCpMg"}],"iyQwr":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inherits;
var _constants = require("../constants");
var _inheritsComments = require("../comments/inheritsComments");
function inherits(child, parent) {
    if (!child || !parent) return child;
    for (const key of _constants.INHERIT_KEYS.optional)if (child[key] == null) child[key] = parent[key];
    for (const key1 of Object.keys(parent))if (key1[0] === "_" && key1 !== "__clone") child[key1] = parent[key1];
    for (const key2 of _constants.INHERIT_KEYS.force)child[key2] = parent[key2];
    (0, _inheritsComments.default)(child, parent);
    return child;
}

},{"../constants":"b9TVI","../comments/inheritsComments":"kEqtV"}],"k3tfB":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = prependToMemberExpression;
var _generated = require("../builders/generated");
function prependToMemberExpression(member, prepend) {
    member.object = (0, _generated.memberExpression)(prepend, member.object);
    return member;
}

},{"../builders/generated":"hCpMg"}],"3gUiO":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _getBindingIdentifiers = require("./getBindingIdentifiers");
var _default = getOuterBindingIdentifiers;
exports.default = _default;
function getOuterBindingIdentifiers(node, duplicates) {
    return (0, _getBindingIdentifiers.default)(node, duplicates, true);
}

},{"./getBindingIdentifiers":"hcSqe"}],"jZKDK":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = traverse;
var _definitions = require("../definitions");
function traverse(node, handlers, state) {
    if (typeof handlers === "function") handlers = {
        enter: handlers
    };
    const { enter , exit  } = handlers;
    traverseSimpleImpl(node, enter, exit, state, []);
}
function traverseSimpleImpl(node, enter, exit, state, ancestors) {
    const keys = _definitions.VISITOR_KEYS[node.type];
    if (!keys) return;
    if (enter) enter(node, ancestors, state);
    for (const key of keys){
        const subNode = node[key];
        if (Array.isArray(subNode)) for(let i = 0; i < subNode.length; i++){
            const child = subNode[i];
            if (!child) continue;
            ancestors.push({
                node,
                key,
                index: i
            });
            traverseSimpleImpl(child, enter, exit, state, ancestors);
            ancestors.pop();
        }
        else if (subNode) {
            ancestors.push({
                node,
                key
            });
            traverseSimpleImpl(subNode, enter, exit, state, ancestors);
            ancestors.pop();
        }
    }
    if (exit) exit(node, ancestors, state);
}

},{"../definitions":"iA9Wj"}],"lUdA1":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isBinding;
var _getBindingIdentifiers = require("../retrievers/getBindingIdentifiers");
function isBinding(node, parent, grandparent) {
    if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") return false;
    const keys = _getBindingIdentifiers.default.keys[parent.type];
    if (keys) for(let i = 0; i < keys.length; i++){
        const key = keys[i];
        const val = parent[key];
        if (Array.isArray(val)) {
            if (val.indexOf(node) >= 0) return true;
        } else {
            if (val === node) return true;
        }
    }
    return false;
}

},{"../retrievers/getBindingIdentifiers":"hcSqe"}],"4yEks":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isBlockScoped;
var _generated = require("./generated");
var _isLet = require("./isLet");
function isBlockScoped(node) {
    return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
}

},{"./generated":"4WRSt","./isLet":"d9OPw"}],"d9OPw":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isLet;
var _generated = require("./generated");
var _constants = require("../constants");
function isLet(node) {
    return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
}

},{"./generated":"4WRSt","../constants":"b9TVI"}],"kFXB2":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isImmutable;
var _isType = require("./isType");
var _generated = require("./generated");
function isImmutable(node) {
    if ((0, _isType.default)(node.type, "Immutable")) return true;
    if ((0, _generated.isIdentifier)(node)) {
        if (node.name === "undefined") return true;
        else return false;
    }
    return false;
}

},{"./isType":"7Y6bU","./generated":"4WRSt"}],"jO6jz":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isNodesEquivalent;
var _definitions = require("../definitions");
function isNodesEquivalent(a, b) {
    if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) return a === b;
    if (a.type !== b.type) return false;
    const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);
    const visitorKeys = _definitions.VISITOR_KEYS[a.type];
    for (const field of fields){
        if (typeof a[field] !== typeof b[field]) return false;
        if (a[field] == null && b[field] == null) continue;
        else if (a[field] == null || b[field] == null) return false;
        if (Array.isArray(a[field])) {
            if (!Array.isArray(b[field])) return false;
            if (a[field].length !== b[field].length) return false;
            for(let i = 0; i < a[field].length; i++){
                if (!isNodesEquivalent(a[field][i], b[field][i])) return false;
            }
            continue;
        }
        if (typeof a[field] === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
            for (const key of Object.keys(a[field])){
                if (a[field][key] !== b[field][key]) return false;
            }
            continue;
        }
        if (!isNodesEquivalent(a[field], b[field])) return false;
    }
    return true;
}

},{"../definitions":"iA9Wj"}],"abhPI":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isReferenced;
function isReferenced(node, parent, grandparent) {
    switch(parent.type){
        case "MemberExpression":
        case "OptionalMemberExpression":
            if (parent.property === node) return !!parent.computed;
            return parent.object === node;
        case "JSXMemberExpression":
            return parent.object === node;
        case "VariableDeclarator":
            return parent.init === node;
        case "ArrowFunctionExpression":
            return parent.body === node;
        case "PrivateName":
            return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
            if (parent.key === node) return !!parent.computed;
            return false;
        case "ObjectProperty":
            if (parent.key === node) return !!parent.computed;
            return !grandparent || grandparent.type !== "ObjectPattern";
        case "ClassProperty":
            if (parent.key === node) return !!parent.computed;
            return true;
        case "ClassPrivateProperty":
            return parent.key !== node;
        case "ClassDeclaration":
        case "ClassExpression":
            return parent.superClass === node;
        case "AssignmentExpression":
            return parent.right === node;
        case "AssignmentPattern":
            return parent.right === node;
        case "LabeledStatement":
            return false;
        case "CatchClause":
            return false;
        case "RestElement":
            return false;
        case "BreakStatement":
        case "ContinueStatement":
            return false;
        case "FunctionDeclaration":
        case "FunctionExpression":
            return false;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
            return false;
        case "ExportSpecifier":
            if (grandparent != null && grandparent.source) return false;
            return parent.local === node;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
            return false;
        case "ImportAttribute":
            return false;
        case "JSXAttribute":
            return false;
        case "ObjectPattern":
        case "ArrayPattern":
            return false;
        case "MetaProperty":
            return false;
        case "ObjectTypeProperty":
            return parent.key !== node;
        case "TSEnumMember":
            return parent.id !== node;
        case "TSPropertySignature":
            if (parent.key === node) return !!parent.computed;
            return true;
    }
    return true;
}

},{}],"gaHb8":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isScope;
var _generated = require("./generated");
function isScope(node, parent) {
    if ((0, _generated.isBlockStatement)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) return false;
    if ((0, _generated.isPattern)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) return true;
    return (0, _generated.isScopable)(node);
}

},{"./generated":"4WRSt"}],"bSRM1":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isSpecifierDefault;
var _generated = require("./generated");
function isSpecifierDefault(specifier) {
    return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
        name: "default"
    });
}

},{"./generated":"4WRSt"}],"e9B0e":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isValidES3Identifier;
var _isValidIdentifier = require("./isValidIdentifier");
const RESERVED_WORDS_ES3_ONLY = new Set([
    "abstract",
    "boolean",
    "byte",
    "char",
    "double",
    "enum",
    "final",
    "float",
    "goto",
    "implements",
    "int",
    "interface",
    "long",
    "native",
    "package",
    "private",
    "protected",
    "public",
    "short",
    "static",
    "synchronized",
    "throws",
    "transient",
    "volatile"
]);
function isValidES3Identifier(name) {
    return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
}

},{"./isValidIdentifier":"aPv9j"}],"d3p3m":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isVar;
var _generated = require("./generated");
var _constants = require("../constants");
function isVar(node) {
    return (0, _generated.isVariableDeclaration)(node, {
        kind: "var"
    }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
}

},{"./generated":"4WRSt","../constants":"b9TVI"}],"cFoYG":[function(require,module,exports) {

},{}],"7OInV":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
function binaryOperation(operator, left, right) {
    switch(operator){
        case '+':
            return left + right;
        case '-':
            return left - right;
        case '/':
            return left / right;
        case '%':
            return left % right;
        case '*':
            return left * right;
        case '**':
            return Math.pow(left, right);
        case '&':
            return left & right;
        case '|':
            return left | right;
        case '>>':
            return left >> right;
        case '>>>':
            return left >>> right;
        case '<<':
            return left << right;
        case '^':
            return left ^ right;
        case '==':
            return left == right;
        case '===':
            return left === right;
        case '!=':
            return left != right;
        case '!==':
            return left !== right;
        case 'in':
            return left in right;
        case 'instanceof':
            return left instanceof right;
        case '>':
            return left > right;
        case '<':
            return left < right;
        case '>=':
            return left >= right;
        case '<=':
            return left <= right;
    }
}
exports["default"] = binaryOperation;

},{}],"j76HK":[function(require,module,exports) {
'use strict';
var assert = require('assert');
var walk = require('pug-walk');
function error() {
    throw require('pug-error').apply(null, arguments);
}
module.exports = link;
function link(ast) {
    assert(ast.type === 'Block', 'The top level element should always be a block');
    var extendsNode = null;
    if (ast.nodes.length) {
        var hasExtends = ast.nodes[0].type === 'Extends';
        checkExtendPosition(ast, hasExtends);
        if (hasExtends) extendsNode = ast.nodes.shift();
    }
    ast = applyIncludes(ast);
    ast.declaredBlocks = findDeclaredBlocks(ast);
    if (extendsNode) {
        var mixins = [];
        var expectedBlocks = [];
        ast.nodes.forEach(function addNode(node) {
            if (node.type === 'NamedBlock') expectedBlocks.push(node);
            else if (node.type === 'Block') node.nodes.forEach(addNode);
            else if (node.type === 'Mixin' && node.call === false) mixins.push(node);
            else error('UNEXPECTED_NODES_IN_EXTENDING_ROOT', 'Only named blocks and mixins can appear at the top level of an extending template', node);
        });
        var parent = link(extendsNode.file.ast);
        extend(parent.declaredBlocks, ast);
        var foundBlockNames = [];
        walk(parent, function(node) {
            if (node.type === 'NamedBlock') foundBlockNames.push(node.name);
        });
        expectedBlocks.forEach(function(expectedBlock) {
            if (foundBlockNames.indexOf(expectedBlock.name) === -1) error('UNEXPECTED_BLOCK', 'Unexpected block ' + expectedBlock.name, expectedBlock);
        });
        Object.keys(ast.declaredBlocks).forEach(function(name) {
            parent.declaredBlocks[name] = ast.declaredBlocks[name];
        });
        parent.nodes = mixins.concat(parent.nodes);
        parent.hasExtends = true;
        return parent;
    }
    return ast;
}
function findDeclaredBlocks(ast) /*: {[name: string]: Array<BlockNode>}*/ {
    var definitions = {
    };
    walk(ast, function before(node) {
        if (node.type === 'NamedBlock' && node.mode === 'replace') {
            definitions[node.name] = definitions[node.name] || [];
            definitions[node.name].push(node);
        }
    });
    return definitions;
}
function flattenParentBlocks(parentBlocks, accumulator) {
    accumulator = accumulator || [];
    parentBlocks.forEach(function(parentBlock) {
        if (parentBlock.parents) flattenParentBlocks(parentBlock.parents, accumulator);
        accumulator.push(parentBlock);
    });
    return accumulator;
}
function extend(parentBlocks, ast) {
    var stack = {
    };
    walk(ast, function before(node) {
        if (node.type === 'NamedBlock') {
            if (stack[node.name] === node.name) return node.ignore = true;
            stack[node.name] = node.name;
            var parentBlockList = parentBlocks[node.name] ? flattenParentBlocks(parentBlocks[node.name]) : [];
            if (parentBlockList.length) {
                node.parents = parentBlockList;
                parentBlockList.forEach(function(parentBlock) {
                    switch(node.mode){
                        case 'append':
                            parentBlock.nodes = parentBlock.nodes.concat(node.nodes);
                            break;
                        case 'prepend':
                            parentBlock.nodes = node.nodes.concat(parentBlock.nodes);
                            break;
                        case 'replace':
                            parentBlock.nodes = node.nodes;
                            break;
                    }
                });
            }
        }
    }, function after(node) {
        if (node.type === 'NamedBlock' && !node.ignore) delete stack[node.name];
    });
}
function applyIncludes(ast, child) {
    return walk(ast, function before(node, replace) {
        if (node.type === 'RawInclude') replace({
            type: 'Text',
            val: node.file.str.replace(/\r/g, '')
        });
    }, function after(node, replace) {
        if (node.type === 'Include') {
            var childAST = link(node.file.ast);
            if (childAST.hasExtends) childAST = removeBlocks(childAST);
            replace(applyYield(childAST, node.block));
        }
    });
}
function removeBlocks(ast) {
    return walk(ast, function(node, replace) {
        if (node.type === 'NamedBlock') replace({
            type: 'Block',
            nodes: node.nodes
        });
    });
}
function applyYield(ast, block) {
    if (!block || !block.nodes.length) return ast;
    var replaced = false;
    ast = walk(ast, null, function(node, replace) {
        if (node.type === 'YieldBlock') {
            replaced = true;
            node.type = 'Block';
            node.nodes = [
                block
            ];
        }
    });
    function defaultYieldLocation(node) {
        var res = node;
        for(var i = 0; i < node.nodes.length; i++){
            if (node.nodes[i].textOnly) continue;
            if (node.nodes[i].type === 'Block') res = defaultYieldLocation(node.nodes[i]);
            else if (node.nodes[i].block && node.nodes[i].block.nodes.length) res = defaultYieldLocation(node.nodes[i].block);
        }
        return res;
    }
    if (!replaced) // todo: probably should deprecate this with a warning
    defaultYieldLocation(ast).nodes.push(block);
    return ast;
}
function checkExtendPosition(ast, hasExtends) {
    var legitExtendsReached = false;
    walk(ast, function(node) {
        if (node.type === 'Extends') {
            if (hasExtends && !legitExtendsReached) legitExtendsReached = true;
            else error('EXTENDS_NOT_FIRST', 'Declaration of template inheritance ("extends") should be the first thing in the file. There can only be one extends statement per file.', node);
        }
    });
}

},{"assert":"bTbxk","pug-walk":"dSk0a","pug-error":"lbNNk"}],"cjaX6":[function(require,module,exports) {
'use strict';
var doctypes = require('doctypes');
var makeError = require('pug-error');
var buildRuntime = require('pug-runtime/build');
var runtime = require('pug-runtime');
var compileAttrs = require('pug-attrs');
var selfClosing = require('void-elements');
var constantinople = require('constantinople');
var stringify = require('js-stringify');
var addWith = require('with');
// This is used to prevent pretty printing inside certain tags
var WHITE_SPACE_SENSITIVE_TAGS = {
    pre: true,
    textarea: true
};
var INTERNAL_VARIABLES = [
    'pug',
    'pug_mixins',
    'pug_interp',
    'pug_debug_filename',
    'pug_debug_line',
    'pug_debug_sources',
    'pug_html', 
];
module.exports = generateCode;
module.exports.CodeGenerator = Compiler;
function generateCode(ast, options) {
    return new Compiler(ast, options).compile();
}
function isConstant(src) {
    return constantinople(src, {
        pug: runtime,
        pug_interp: undefined
    });
}
function toConstant(src) {
    return constantinople.toConstant(src, {
        pug: runtime,
        pug_interp: undefined
    });
}
/**
 * Initialize `Compiler` with the given `node`.
 *
 * @param {Node} node
 * @param {Object} options
 * @api public
 */ function Compiler(node, options) {
    this.options = options = options || {
    };
    this.node = node;
    this.bufferedConcatenationCount = 0;
    this.hasCompiledDoctype = false;
    this.hasCompiledTag = false;
    this.pp = options.pretty || false;
    if (this.pp && typeof this.pp !== 'string') this.pp = '  ';
    if (this.pp && !/^\s+$/.test(this.pp)) throw new Error('The pretty parameter should either be a boolean or whitespace only string');
    this.debug = false !== options.compileDebug;
    this.indents = 0;
    this.parentIndents = 0;
    this.terse = false;
    this.mixins = {
    };
    this.dynamicMixins = false;
    this.eachCount = 0;
    if (options.doctype) this.setDoctype(options.doctype);
    this.runtimeFunctionsUsed = [];
    this.inlineRuntimeFunctions = options.inlineRuntimeFunctions || false;
    if (this.debug && this.inlineRuntimeFunctions) this.runtimeFunctionsUsed.push('rethrow');
}
/**
 * Compiler prototype.
 */ Compiler.prototype = {
    runtime: function(name) {
        if (this.inlineRuntimeFunctions) {
            this.runtimeFunctionsUsed.push(name);
            return 'pug_' + name;
        } else return 'pug.' + name;
    },
    error: function(message, code, node) {
        var err = makeError(code, message, {
            line: node.line,
            column: node.column,
            filename: node.filename
        });
        throw err;
    },
    /**
   * Compile parse tree to JavaScript.
   *
   * @api public
   */ compile: function() {
        this.buf = [];
        if (this.pp) this.buf.push('var pug_indent = [];');
        this.lastBufferedIdx = -1;
        this.visit(this.node);
        if (!this.dynamicMixins) {
            // if there are no dynamic mixins we can remove any un-used mixins
            var mixinNames = Object.keys(this.mixins);
            for(var i = 0; i < mixinNames.length; i++){
                var mixin = this.mixins[mixinNames[i]];
                if (!mixin.used) {
                    for(var x = 0; x < mixin.instances.length; x++)for(var y = mixin.instances[x].start; y < mixin.instances[x].end; y++)this.buf[y] = '';
                }
            }
        }
        var js = this.buf.join('\n');
        var globals = this.options.globals ? this.options.globals.concat(INTERNAL_VARIABLES) : INTERNAL_VARIABLES;
        if (this.options.self) js = 'var self = locals || {};' + js;
        else js = addWith('locals || {}', js, globals.concat(this.runtimeFunctionsUsed.map(function(name) {
            return 'pug_' + name;
        })));
        if (this.debug) {
            if (this.options.includeSources) js = 'var pug_debug_sources = ' + stringify(this.options.includeSources) + ';\n' + js;
            js = "var pug_debug_filename, pug_debug_line;try {" + js + '} catch (err) {' + (this.inlineRuntimeFunctions ? 'pug_rethrow' : 'pug.rethrow') + '(err, pug_debug_filename, pug_debug_line' + (this.options.includeSources ? ', pug_debug_sources[pug_debug_filename]' : '') + ');' + '}';
        }
        return buildRuntime(this.runtimeFunctionsUsed) + 'function ' + (this.options.templateName || 'template') + '(locals) {var pug_html = "", pug_mixins = {}, pug_interp;' + js + ';return pug_html;}';
    },
    /**
   * Sets the default doctype `name`. Sets terse mode to `true` when
   * html 5 is used, causing self-closing tags to end with ">" vs "/>",
   * and boolean attributes are not mirrored.
   *
   * @param {string} name
   * @api public
   */ setDoctype: function(name) {
        this.doctype = doctypes[name.toLowerCase()] || '<!DOCTYPE ' + name + '>';
        this.terse = this.doctype.toLowerCase() == '<!doctype html>';
        this.xml = 0 == this.doctype.indexOf('<?xml');
    },
    /**
   * Buffer the given `str` exactly as is or with interpolation
   *
   * @param {String} str
   * @param {Boolean} interpolate
   * @api public
   */ buffer: function(str) {
        var self = this;
        str = stringify(str);
        str = str.substr(1, str.length - 2);
        if (this.lastBufferedIdx == this.buf.length && this.bufferedConcatenationCount < 100) {
            if (this.lastBufferedType === 'code') {
                this.lastBuffered += ' + "';
                this.bufferedConcatenationCount++;
            }
            this.lastBufferedType = 'text';
            this.lastBuffered += str;
            this.buf[this.lastBufferedIdx - 1] = 'pug_html = pug_html + ' + this.bufferStartChar + this.lastBuffered + '";';
        } else {
            this.bufferedConcatenationCount = 0;
            this.buf.push('pug_html = pug_html + "' + str + '";');
            this.lastBufferedType = 'text';
            this.bufferStartChar = '"';
            this.lastBuffered = str;
            this.lastBufferedIdx = this.buf.length;
        }
    },
    /**
   * Buffer the given `src` so it is evaluated at run time
   *
   * @param {String} src
   * @api public
   */ bufferExpression: function(src) {
        if (isConstant(src)) return this.buffer(toConstant(src) + '');
        if (this.lastBufferedIdx == this.buf.length && this.bufferedConcatenationCount < 100) {
            this.bufferedConcatenationCount++;
            if (this.lastBufferedType === 'text') this.lastBuffered += '"';
            this.lastBufferedType = 'code';
            this.lastBuffered += ' + (' + src + ')';
            this.buf[this.lastBufferedIdx - 1] = 'pug_html = pug_html + (' + this.bufferStartChar + this.lastBuffered + ');';
        } else {
            this.bufferedConcatenationCount = 0;
            this.buf.push('pug_html = pug_html + (' + src + ');');
            this.lastBufferedType = 'code';
            this.bufferStartChar = '';
            this.lastBuffered = '(' + src + ')';
            this.lastBufferedIdx = this.buf.length;
        }
    },
    /**
   * Buffer an indent based on the current `indent`
   * property and an additional `offset`.
   *
   * @param {Number} offset
   * @param {Boolean} newline
   * @api public
   */ prettyIndent: function(offset, newline) {
        offset = offset || 0;
        newline = newline ? '\n' : '';
        this.buffer(newline + Array(this.indents + offset).join(this.pp));
        if (this.parentIndents) this.buf.push('pug_html = pug_html + pug_indent.join("");');
    },
    /**
   * Visit `node`.
   *
   * @param {Node} node
   * @api public
   */ visit: function(node, parent) {
        var debug = this.debug;
        if (!node) {
            var msg;
            if (parent) msg = 'A child of ' + parent.type + ' (' + (parent.filename || 'Pug') + ':' + parent.line + ')';
            else msg = 'A top-level node';
            msg += ' is ' + node + ', expected a Pug AST Node.';
            throw new TypeError(msg);
        }
        if (debug && node.debug !== false && node.type !== 'Block') {
            if (node.line) {
                var js = ';pug_debug_line = ' + node.line;
                if (node.filename) js += ';pug_debug_filename = ' + stringify(node.filename);
                this.buf.push(js + ';');
            }
        }
        if (!this['visit' + node.type]) {
            var msg;
            if (parent) msg = 'A child of ' + parent.type;
            else msg = 'A top-level node';
            msg += ' (' + (node.filename || 'Pug') + ':' + node.line + ')' + ' is of type ' + node.type + ',' + ' which is not supported by pug-code-gen.';
            switch(node.type){
                case 'Filter':
                    msg += ' Please use pug-filters to preprocess this AST.';
                    break;
                case 'Extends':
                case 'Include':
                case 'NamedBlock':
                case 'FileReference':
                    msg += ' Please use pug-linker to preprocess this AST.';
                    break;
            }
            throw new TypeError(msg);
        }
        this.visitNode(node);
    },
    /**
   * Visit `node`.
   *
   * @param {Node} node
   * @api public
   */ visitNode: function(node) {
        return this['visit' + node.type](node);
    },
    /**
   * Visit case `node`.
   *
   * @param {Literal} node
   * @api public
   */ visitCase: function(node) {
        this.buf.push('switch (' + node.expr + '){');
        this.visit(node.block, node);
        this.buf.push('}');
    },
    /**
   * Visit when `node`.
   *
   * @param {Literal} node
   * @api public
   */ visitWhen: function(node) {
        if ('default' == node.expr) this.buf.push('default:');
        else this.buf.push('case ' + node.expr + ':');
        if (node.block) {
            this.visit(node.block, node);
            this.buf.push('  break;');
        }
    },
    /**
   * Visit literal `node`.
   *
   * @param {Literal} node
   * @api public
   */ visitLiteral: function(node) {
        this.buffer(node.str);
    },
    visitNamedBlock: function(block) {
        return this.visitBlock(block);
    },
    /**
   * Visit all nodes in `block`.
   *
   * @param {Block} block
   * @api public
   */ visitBlock: function(block) {
        var escapePrettyMode = this.escapePrettyMode;
        var pp = this.pp;
        // Pretty print multi-line text
        if (pp && block.nodes.length > 1 && !escapePrettyMode && block.nodes[0].type === 'Text' && block.nodes[1].type === 'Text') this.prettyIndent(1, true);
        for(var i = 0; i < block.nodes.length; ++i){
            // Pretty print text
            if (pp && i > 0 && !escapePrettyMode && block.nodes[i].type === 'Text' && block.nodes[i - 1].type === 'Text' && /\n$/.test(block.nodes[i - 1].val)) this.prettyIndent(1, false);
            this.visit(block.nodes[i], block);
        }
    },
    /**
   * Visit a mixin's `block` keyword.
   *
   * @param {MixinBlock} block
   * @api public
   */ visitMixinBlock: function(block) {
        if (this.pp) this.buf.push('pug_indent.push(' + stringify(Array(this.indents + 1).join(this.pp)) + ');');
        this.buf.push('block && block();');
        if (this.pp) this.buf.push('pug_indent.pop();');
    },
    /**
   * Visit `doctype`. Sets terse mode to `true` when html 5
   * is used, causing self-closing tags to end with ">" vs "/>",
   * and boolean attributes are not mirrored.
   *
   * @param {Doctype} doctype
   * @api public
   */ visitDoctype: function(doctype) {
        if (doctype && (doctype.val || !this.doctype)) this.setDoctype(doctype.val || 'html');
        if (this.doctype) this.buffer(this.doctype);
        this.hasCompiledDoctype = true;
    },
    /**
   * Visit `mixin`, generating a function that
   * may be called within the template.
   *
   * @param {Mixin} mixin
   * @api public
   */ visitMixin: function(mixin) {
        var name = 'pug_mixins[';
        var args = mixin.args || '';
        var block = mixin.block;
        var attrs = mixin.attrs;
        var attrsBlocks = this.attributeBlocks(mixin.attributeBlocks);
        var pp = this.pp;
        var dynamic = mixin.name[0] === '#';
        var key = mixin.name;
        if (dynamic) this.dynamicMixins = true;
        name += (dynamic ? mixin.name.substr(2, mixin.name.length - 3) : '"' + mixin.name + '"') + ']';
        this.mixins[key] = this.mixins[key] || {
            used: false,
            instances: []
        };
        if (mixin.call) {
            this.mixins[key].used = true;
            if (pp) this.buf.push('pug_indent.push(' + stringify(Array(this.indents + 1).join(pp)) + ');');
            if (block || attrs.length || attrsBlocks.length) {
                this.buf.push(name + '.call({');
                if (block) {
                    this.buf.push('block: function(){');
                    // Render block with no indents, dynamically added when rendered
                    this.parentIndents++;
                    var _indents = this.indents;
                    this.indents = 0;
                    this.visit(mixin.block, mixin);
                    this.indents = _indents;
                    this.parentIndents--;
                    if (attrs.length || attrsBlocks.length) this.buf.push('},');
                    else this.buf.push('}');
                }
                if (attrsBlocks.length) {
                    if (attrs.length) {
                        var val = this.attrs(attrs);
                        attrsBlocks.unshift(val);
                    }
                    if (attrsBlocks.length > 1) this.buf.push('attributes: ' + this.runtime('merge') + '([' + attrsBlocks.join(',') + '])');
                    else this.buf.push('attributes: ' + attrsBlocks[0]);
                } else if (attrs.length) {
                    var val = this.attrs(attrs);
                    this.buf.push('attributes: ' + val);
                }
                if (args) this.buf.push('}, ' + args + ');');
                else this.buf.push('});');
            } else this.buf.push(name + '(' + args + ');');
            if (pp) this.buf.push('pug_indent.pop();');
        } else {
            var mixin_start = this.buf.length;
            args = args ? args.split(',') : [];
            var rest;
            if (args.length && /^\.\.\./.test(args[args.length - 1].trim())) rest = args.pop().trim().replace(/^\.\.\./, '');
            // we need use pug_interp here for v8: https://code.google.com/p/v8/issues/detail?id=4165
            // once fixed, use this: this.buf.push(name + ' = function(' + args.join(',') + '){');
            this.buf.push(name + ' = pug_interp = function(' + args.join(',') + '){');
            this.buf.push('var block = (this && this.block), attributes = (this && this.attributes) || {};');
            if (rest) {
                this.buf.push('var ' + rest + ' = [];');
                this.buf.push('for (pug_interp = ' + args.length + '; pug_interp < arguments.length; pug_interp++) {');
                this.buf.push('  ' + rest + '.push(arguments[pug_interp]);');
                this.buf.push('}');
            }
            this.parentIndents++;
            this.visit(block, mixin);
            this.parentIndents--;
            this.buf.push('};');
            var mixin_end = this.buf.length;
            this.mixins[key].instances.push({
                start: mixin_start,
                end: mixin_end
            });
        }
    },
    /**
   * Visit `tag` buffering tag markup, generating
   * attributes, visiting the `tag`'s code and block.
   *
   * @param {Tag} tag
   * @param {boolean} interpolated
   * @api public
   */ visitTag: function(tag1, interpolated) {
        this.indents++;
        var name = tag1.name, pp = this.pp, self = this;
        function bufferName() {
            if (interpolated) self.bufferExpression(tag1.expr);
            else self.buffer(name);
        }
        if (WHITE_SPACE_SENSITIVE_TAGS[tag1.name] === true) this.escapePrettyMode = true;
        if (!this.hasCompiledTag) {
            if (!this.hasCompiledDoctype && 'html' == name) this.visitDoctype();
            this.hasCompiledTag = true;
        }
        // pretty print
        if (pp && !tag1.isInline) this.prettyIndent(0, true);
        if (tag1.selfClosing || !this.xml && selfClosing[tag1.name]) {
            this.buffer('<');
            bufferName();
            this.visitAttributes(tag1.attrs, this.attributeBlocks(tag1.attributeBlocks));
            if (this.terse && !tag1.selfClosing) this.buffer('>');
            else this.buffer('/>');
            // if it is non-empty throw an error
            if (tag1.code || tag1.block && !(tag1.block.type === 'Block' && tag1.block.nodes.length === 0) && tag1.block.nodes.some(function(tag) {
                return tag.type !== 'Text' || !/^\s*$/.test(tag.val);
            })) this.error(name + ' is a self closing element: <' + name + '/> but contains nested content.', 'SELF_CLOSING_CONTENT', tag1);
        } else {
            // Optimize attributes buffering
            this.buffer('<');
            bufferName();
            this.visitAttributes(tag1.attrs, this.attributeBlocks(tag1.attributeBlocks));
            this.buffer('>');
            if (tag1.code) this.visitCode(tag1.code);
            this.visit(tag1.block, tag1);
            // pretty print
            if (pp && !tag1.isInline && WHITE_SPACE_SENSITIVE_TAGS[tag1.name] !== true && !tagCanInline(tag1)) this.prettyIndent(0, true);
            this.buffer('</');
            bufferName();
            this.buffer('>');
        }
        if (WHITE_SPACE_SENSITIVE_TAGS[tag1.name] === true) this.escapePrettyMode = false;
        this.indents--;
    },
    /**
   * Visit InterpolatedTag.
   *
   * @param {InterpolatedTag} tag
   * @api public
   */ visitInterpolatedTag: function(tag) {
        return this.visitTag(tag, true);
    },
    /**
   * Visit `text` node.
   *
   * @param {Text} text
   * @api public
   */ visitText: function(text) {
        this.buffer(text.val);
    },
    /**
   * Visit a `comment`, only buffering when the buffer flag is set.
   *
   * @param {Comment} comment
   * @api public
   */ visitComment: function(comment) {
        if (!comment.buffer) return;
        if (this.pp) this.prettyIndent(1, true);
        this.buffer('<!--' + comment.val + '-->');
    },
    /**
   * Visit a `YieldBlock`.
   *
   * This is necessary since we allow compiling a file with `yield`.
   *
   * @param {YieldBlock} block
   * @api public
   */ visitYieldBlock: function(block) {
    },
    /**
   * Visit a `BlockComment`.
   *
   * @param {Comment} comment
   * @api public
   */ visitBlockComment: function(comment) {
        if (!comment.buffer) return;
        if (this.pp) this.prettyIndent(1, true);
        this.buffer('<!--' + (comment.val || ''));
        this.visit(comment.block, comment);
        if (this.pp) this.prettyIndent(1, true);
        this.buffer('-->');
    },
    /**
   * Visit `code`, respecting buffer / escape flags.
   * If the code is followed by a block, wrap it in
   * a self-calling function.
   *
   * @param {Code} code
   * @api public
   */ visitCode: function(code) {
        // Wrap code blocks with {}.
        // we only wrap unbuffered code blocks ATM
        // since they are usually flow control
        // Buffer code
        if (code.buffer) {
            var val = code.val.trim();
            val = 'null == (pug_interp = ' + val + ') ? "" : pug_interp';
            if (code.mustEscape !== false) val = this.runtime('escape') + '(' + val + ')';
            this.bufferExpression(val);
        } else this.buf.push(code.val);
        // Block support
        if (code.block) {
            if (!code.buffer) this.buf.push('{');
            this.visit(code.block, code);
            if (!code.buffer) this.buf.push('}');
        }
    },
    /**
   * Visit `Conditional`.
   *
   * @param {Conditional} cond
   * @api public
   */ visitConditional: function(cond) {
        var test = cond.test;
        this.buf.push('if (' + test + ') {');
        this.visit(cond.consequent, cond);
        this.buf.push('}');
        if (cond.alternate) {
            if (cond.alternate.type === 'Conditional') {
                this.buf.push('else');
                this.visitConditional(cond.alternate);
            } else {
                this.buf.push('else {');
                this.visit(cond.alternate, cond);
                this.buf.push('}');
            }
        }
    },
    /**
   * Visit `While`.
   *
   * @param {While} loop
   * @api public
   */ visitWhile: function(loop) {
        var test = loop.test;
        this.buf.push('while (' + test + ') {');
        this.visit(loop.block, loop);
        this.buf.push('}');
    },
    /**
   * Visit `each` block.
   *
   * @param {Each} each
   * @api public
   */ visitEach: function(each) {
        var indexVarName = each.key || 'pug_index' + this.eachCount;
        this.eachCount++;
        this.buf.push("// iterate " + each.obj + '\n' + ';(function(){\n' + '  var $$obj = ' + each.obj + ';\n' + "  if ('number' == typeof $$obj.length) {");
        if (each.alternate) this.buf.push('    if ($$obj.length) {');
        this.buf.push("      for (var " + indexVarName + ' = 0, $$l = $$obj.length; ' + indexVarName + ' < $$l; ' + indexVarName + '++) {\n' + '        var ' + each.val + ' = $$obj[' + indexVarName + '];');
        this.visit(each.block, each);
        this.buf.push('      }');
        if (each.alternate) {
            this.buf.push('    } else {');
            this.visit(each.alternate, each);
            this.buf.push('    }');
        }
        this.buf.push("  } else {\n    var $$l = 0;\n    for (var " + indexVarName + ' in $$obj) {\n' + '      $$l++;\n' + '      var ' + each.val + ' = $$obj[' + indexVarName + '];');
        this.visit(each.block, each);
        this.buf.push('    }');
        if (each.alternate) {
            this.buf.push('    if ($$l === 0) {');
            this.visit(each.alternate, each);
            this.buf.push('    }');
        }
        this.buf.push('  }\n}).call(this);\n');
    },
    visitEachOf: function(each) {
        this.buf.push("// iterate " + each.obj + '\n' + 'for (const ' + each.val + ' of ' + each.obj + ') {\n');
        this.visit(each.block, each);
        this.buf.push('}\n');
    },
    /**
   * Visit `attrs`.
   *
   * @param {Array} attrs
   * @api public
   */ visitAttributes: function(attrs, attributeBlocks) {
        if (attributeBlocks.length) {
            if (attrs.length) {
                var val = this.attrs(attrs);
                attributeBlocks.unshift(val);
            }
            if (attributeBlocks.length > 1) this.bufferExpression(this.runtime('attrs') + '(' + this.runtime('merge') + '([' + attributeBlocks.join(',') + ']), ' + stringify(this.terse) + ')');
            else this.bufferExpression(this.runtime('attrs') + '(' + attributeBlocks[0] + ', ' + stringify(this.terse) + ')');
        } else if (attrs.length) this.attrs(attrs, true);
    },
    /**
   * Compile attributes.
   */ attrs: function(attrs, buffer) {
        var res = compileAttrs(attrs, {
            terse: this.terse,
            format: buffer ? 'html' : 'object',
            runtime: this.runtime.bind(this)
        });
        if (buffer) this.bufferExpression(res);
        return res;
    },
    /**
   * Compile attribute blocks.
   */ attributeBlocks: function(attributeBlocks) {
        return attributeBlocks && attributeBlocks.slice().map(function(attrBlock) {
            return attrBlock.val;
        });
    }
};
function tagCanInline(tag) {
    function isInline(node) {
        // Recurse if the node is a block
        if (node.type === 'Block') return node.nodes.every(isInline);
        // When there is a YieldBlock here, it is an indication that the file is
        // expected to be included but is not. If this is the case, the block
        // must be empty.
        if (node.type === 'YieldBlock') return true;
        return node.type === 'Text' && !/\n/.test(node.val) || node.isInline;
    }
    return tag.block.nodes.every(isInline);
}

},{"doctypes":"dDYTP","pug-error":"lbNNk","pug-runtime/build":"fcmhr","pug-runtime":"dOa8V","pug-attrs":"2Br9m","void-elements":"e9AKQ","constantinople":"hYgg9","js-stringify":"l22oi","with":"2guVQ"}],"dDYTP":[function(require,module,exports) {
'use strict';
module.exports = {
    'html': '<!DOCTYPE html>',
    'xml': '<?xml version="1.0" encoding="utf-8" ?>',
    'transitional': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">',
    'strict': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">',
    'frameset': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">',
    '1.1': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">',
    'basic': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">',
    'mobile': '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" "http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">',
    'plist': '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">'
};

},{}],"fcmhr":[function(require,module,exports) {
'use strict';
var fs = require('fs');
var dependencies = require('./lib/dependencies.js');
var internals = require('./lib/internals.js');
var sources = require('./lib/sources.js');
module.exports = build;
function build(functions) {
    var fns = [];
    functions = functions.filter(function(fn) {
        return !internals[fn];
    });
    for(var i = 0; i < functions.length; i++)if (fns.indexOf(functions[i]) === -1) {
        fns.push(functions[i]);
        functions.push.apply(functions, dependencies[functions[i]]);
    }
    return fns.sort().map(function(name) {
        return sources[name];
    }).join('\n');
}

},{"fs":"joWnX","./lib/dependencies.js":"exjL0","./lib/internals.js":"6Tevq","./lib/sources.js":"5GMDP"}],"exjL0":[function(require,module,exports) {
module.exports = {
    "has_own_property": [],
    "merge": [
        "style"
    ],
    "classes_array": [
        "classes",
        "escape"
    ],
    "classes_object": [
        "has_own_property"
    ],
    "classes": [
        "classes_array",
        "classes_object"
    ],
    "style": [
        "has_own_property"
    ],
    "attr": [
        "escape"
    ],
    "attrs": [
        "attr",
        "classes",
        "has_own_property",
        "style"
    ],
    "match_html": [],
    "escape": [
        "match_html"
    ],
    "rethrow": []
};

},{}],"6Tevq":[function(require,module,exports) {
module.exports = {
    "dependencies": true,
    "internals": true,
    "has_own_property": true,
    "classes_array": true,
    "classes_object": true,
    "match_html": true
};

},{}],"5GMDP":[function(require,module,exports) {
module.exports = {
    "has_own_property": "var pug_has_own_property=Object.prototype.hasOwnProperty;",
    "merge": "function pug_merge(e,r){if(1===arguments.length){for(var t=e[0],g=1;g<e.length;g++)t=pug_merge(t,e[g]);return t}for(var l in r)if(\"class\"===l){var n=e[l]||[];e[l]=(Array.isArray(n)?n:[n]).concat(r[l]||[])}else if(\"style\"===l){var n=pug_style(e[l]);n=n&&\";\"!==n[n.length-1]?n+\";\":n;var a=pug_style(r[l]);a=a&&\";\"!==a[a.length-1]?a+\";\":a,e[l]=n+a}else e[l]=r[l];return e}",
    "classes_array": "function pug_classes_array(r,a){for(var s,e=\"\",u=\"\",c=Array.isArray(a),g=0;g<r.length;g++)(s=pug_classes(r[g]))&&(c&&a[g]&&(s=pug_escape(s)),e=e+u+s,u=\" \");return e}",
    "classes_object": "function pug_classes_object(r){var a=\"\",n=\"\";for(var o in r)o&&r[o]&&pug_has_own_property.call(r,o)&&(a=a+n+o,n=\" \");return a}",
    "classes": "function pug_classes(s,r){return Array.isArray(s)?pug_classes_array(s,r):s&&\"object\"==typeof s?pug_classes_object(s):s||\"\"}",
    "style": "function pug_style(r){if(!r)return\"\";if(\"object\"==typeof r){var t=\"\";for(var e in r)pug_has_own_property.call(r,e)&&(t=t+e+\":\"+r[e]+\";\");return t}return r+\"\"}",
    "attr": "function pug_attr(t,e,n,r){if(!1===e||null==e||!e&&(\"class\"===t||\"style\"===t))return\"\";if(!0===e)return\" \"+(r?t:t+'=\"'+t+'\"');var f=typeof e;return\"object\"!==f&&\"function\"!==f||\"function\"!=typeof e.toJSON||(e=e.toJSON()),\"string\"==typeof e||(e=JSON.stringify(e),n||-1===e.indexOf('\"'))?(n&&(e=pug_escape(e)),\" \"+t+'=\"'+e+'\"'):\" \"+t+\"='\"+e.replace(/'/g,\"&#39;\")+\"'\"}",
    "attrs": "function pug_attrs(t,r){var a=\"\";for(var s in t)if(pug_has_own_property.call(t,s)){var u=t[s];if(\"class\"===s){u=pug_classes(u),a=pug_attr(s,u,!1,r)+a;continue}\"style\"===s&&(u=pug_style(u)),a+=pug_attr(s,u,!1,r)}return a}",
    "match_html": "var pug_match_html=/[\"&<>]/;",
    "escape": "function pug_escape(e){var a=\"\"+e,t=pug_match_html.exec(a);if(!t)return e;var r,c,n,s=\"\";for(r=t.index,c=0;r<a.length;r++){switch(a.charCodeAt(r)){case 34:n=\"&quot;\";break;case 38:n=\"&amp;\";break;case 60:n=\"&lt;\";break;case 62:n=\"&gt;\";break;default:continue}c!==r&&(s+=a.substring(c,r)),c=r+1,s+=n}return c!==r?s+a.substring(c,r):s}",
    "rethrow": "function pug_rethrow(e,n,r,t){if(!(e instanceof Error))throw e;if(!(\"undefined\"==typeof window&&n||t))throw e.message+=\" on line \"+r,e;var o,a,i,s;try{t=t||require(\"fs\").readFileSync(n,{encoding:\"utf8\"}),o=3,a=t.split(\"\\n\"),i=Math.max(r-o,0),s=Math.min(a.length,r+o)}catch(t){return e.message+=\" - could not read from \"+n+\" (\"+t.message+\")\",void pug_rethrow(e,null,r)}o=a.slice(i,s).map(function(e,n){var t=n+i+1;return(t==r?\"  > \":\"    \")+t+\"| \"+e}).join(\"\\n\"),e.path=n;try{e.message=(n||\"Pug\")+\":\"+r+\"\\n\"+o+\"\\n\\n\"+e.message}catch(e){}throw e}"
};

},{}],"dOa8V":[function(require,module,exports) {
'use strict';
var pug_has_own_property = Object.prototype.hasOwnProperty;
/**
 * Merge two attribute objects giving precedence
 * to values in object `b`. Classes are special-cased
 * allowing for arrays and merging/joining appropriately
 * resulting in a string.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api private
 */ exports.merge = pug_merge;
function pug_merge(a, b) {
    if (arguments.length === 1) {
        var attrs = a[0];
        for(var i = 1; i < a.length; i++)attrs = pug_merge(attrs, a[i]);
        return attrs;
    }
    for(var key in b){
        if (key === 'class') {
            var valA = a[key] || [];
            a[key] = (Array.isArray(valA) ? valA : [
                valA
            ]).concat(b[key] || []);
        } else if (key === 'style') {
            var valA = pug_style(a[key]);
            valA = valA && valA[valA.length - 1] !== ';' ? valA + ';' : valA;
            var valB = pug_style(b[key]);
            valB = valB && valB[valB.length - 1] !== ';' ? valB + ';' : valB;
            a[key] = valA + valB;
        } else a[key] = b[key];
    }
    return a;
}
/**
 * Process array, object, or string as a string of classes delimited by a space.
 *
 * If `val` is an array, all members of it and its subarrays are counted as
 * classes. If `escaping` is an array, then whether or not the item in `val` is
 * escaped depends on the corresponding item in `escaping`. If `escaping` is
 * not an array, no escaping is done.
 *
 * If `val` is an object, all the keys whose value is truthy are counted as
 * classes. No escaping is done.
 *
 * If `val` is a string, it is counted as a class. No escaping is done.
 *
 * @param {(Array.<string>|Object.<string, boolean>|string)} val
 * @param {?Array.<string>} escaping
 * @return {String}
 */ exports.classes = pug_classes;
function pug_classes_array(val, escaping) {
    var classString = '', className, padding = '', escapeEnabled = Array.isArray(escaping);
    for(var i = 0; i < val.length; i++){
        className = pug_classes(val[i]);
        if (!className) continue;
        escapeEnabled && escaping[i] && (className = pug_escape(className));
        classString = classString + padding + className;
        padding = ' ';
    }
    return classString;
}
function pug_classes_object(val) {
    var classString = '', padding = '';
    for(var key in val)if (key && val[key] && pug_has_own_property.call(val, key)) {
        classString = classString + padding + key;
        padding = ' ';
    }
    return classString;
}
function pug_classes(val, escaping) {
    if (Array.isArray(val)) return pug_classes_array(val, escaping);
    else if (val && typeof val === 'object') return pug_classes_object(val);
    else return val || '';
}
/**
 * Convert object or string to a string of CSS styles delimited by a semicolon.
 *
 * @param {(Object.<string, string>|string)} val
 * @return {String}
 */ exports.style = pug_style;
function pug_style(val) {
    if (!val) return '';
    if (typeof val === 'object') {
        var out = '';
        for(var style in val)/* istanbul ignore else */ if (pug_has_own_property.call(val, style)) out = out + style + ':' + val[style] + ';';
        return out;
    } else return val + '';
}
/**
 * Render the given attribute.
 *
 * @param {String} key
 * @param {String} val
 * @param {Boolean} escaped
 * @param {Boolean} terse
 * @return {String}
 */ exports.attr = pug_attr;
function pug_attr(key, val, escaped, terse) {
    if (val === false || val == null || !val && (key === 'class' || key === 'style')) return '';
    if (val === true) return ' ' + (terse ? key : key + '="' + key + '"');
    var type = typeof val;
    if ((type === 'object' || type === 'function') && typeof val.toJSON === 'function') val = val.toJSON();
    if (typeof val !== 'string') {
        val = JSON.stringify(val);
        if (!escaped && val.indexOf('"') !== -1) return ' ' + key + "='" + val.replace(/'/g, '&#39;') + "'";
    }
    if (escaped) val = pug_escape(val);
    return ' ' + key + '="' + val + '"';
}
/**
 * Render the given attributes object.
 *
 * @param {Object} obj
 * @param {Object} terse whether to use HTML5 terse boolean attributes
 * @return {String}
 */ exports.attrs = pug_attrs;
function pug_attrs(obj, terse) {
    var attrs = '';
    for(var key in obj)if (pug_has_own_property.call(obj, key)) {
        var val = obj[key];
        if ('class' === key) {
            val = pug_classes(val);
            attrs = pug_attr(key, val, false, terse) + attrs;
            continue;
        }
        if ('style' === key) val = pug_style(val);
        attrs += pug_attr(key, val, false, terse);
    }
    return attrs;
}
/**
 * Escape the given string of `html`.
 *
 * @param {String} html
 * @return {String}
 * @api private
 */ var pug_match_html = /["&<>]/;
exports.escape = pug_escape;
function pug_escape(_html) {
    var html = '' + _html;
    var regexResult = pug_match_html.exec(html);
    if (!regexResult) return _html;
    var result = '';
    var i, lastIndex, escape;
    for(i = regexResult.index, lastIndex = 0; i < html.length; i++){
        switch(html.charCodeAt(i)){
            case 34:
                escape = '&quot;';
                break;
            case 38:
                escape = '&amp;';
                break;
            case 60:
                escape = '&lt;';
                break;
            case 62:
                escape = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== i) result += html.substring(lastIndex, i);
        lastIndex = i + 1;
        result += escape;
    }
    if (lastIndex !== i) return result + html.substring(lastIndex, i);
    else return result;
}
/**
 * Re-throw the given `err` in context to the
 * the pug in `filename` at the given `lineno`.
 *
 * @param {Error} err
 * @param {String} filename
 * @param {String} lineno
 * @param {String} str original source
 * @api private
 */ exports.rethrow = pug_rethrow;
function pug_rethrow(err, filename, lineno, str) {
    if (!(err instanceof Error)) throw err;
    if ((typeof window != 'undefined' || !filename) && !str) {
        err.message += ' on line ' + lineno;
        throw err;
    }
    var context, lines, start, end;
    try {
        str = str || require('fs').readFileSync(filename, {
            encoding: 'utf8'
        });
        context = 3;
        lines = str.split('\n');
        start = Math.max(lineno - context, 0);
        end = Math.min(lines.length, lineno + context);
    } catch (ex) {
        err.message += ' - could not read from ' + filename + ' (' + ex.message + ')';
        pug_rethrow(err, null, lineno);
        return;
    }
    // Error context
    context = lines.slice(start, end).map(function(line, i) {
        var curr = i + start + 1;
        return (curr == lineno ? '  > ' : '    ') + curr + '| ' + line;
    }).join('\n');
    // Alter exception message
    err.path = filename;
    try {
        err.message = (filename || 'Pug') + ':' + lineno + '\n' + context + '\n\n' + err.message;
    } catch (e) {
    }
    throw err;
}

},{"fs":"joWnX"}],"2Br9m":[function(require,module,exports) {
'use strict';
var assert = require('assert');
var constantinople = require('constantinople');
var runtime = require('pug-runtime');
var stringify = require('js-stringify');
function isConstant(src) {
    return constantinople(src, {
        pug: runtime,
        pug_interp: undefined
    });
}
function toConstant(src) {
    return constantinople.toConstant(src, {
        pug: runtime,
        pug_interp: undefined
    });
}
module.exports = compileAttrs;
/**
 * options:
 *  - terse
 *  - runtime
 *  - format ('html' || 'object')
 */ function compileAttrs(attrs, options) {
    assert(Array.isArray(attrs), 'Attrs should be an array');
    assert(attrs.every(function(attr) {
        return attr && typeof attr === 'object' && typeof attr.name === 'string' && (typeof attr.val === 'string' || typeof attr.val === 'boolean') && typeof attr.mustEscape === 'boolean';
    }), 'All attributes should be supplied as an object of the form {name, val, mustEscape}');
    assert(options && typeof options === 'object', 'Options should be an object');
    assert(typeof options.terse === 'boolean', 'Options.terse should be a boolean');
    assert(typeof options.runtime === 'function', 'Options.runtime should be a function that takes a runtime function name and returns the source code that will evaluate to that function at runtime');
    assert(options.format === 'html' || options.format === 'object', 'Options.format should be "html" or "object"');
    var buf1 = [];
    var classes = [];
    var classEscaping = [];
    function addAttribute(key, val, mustEscape, buf) {
        if (isConstant(val)) {
            if (options.format === 'html') {
                var str = stringify(runtime.attr(key, toConstant(val), mustEscape, options.terse));
                var last = buf[buf.length - 1];
                if (last && last[last.length - 1] === str[0]) buf[buf.length - 1] = last.substr(0, last.length - 1) + str.substr(1);
                else buf.push(str);
            } else {
                val = toConstant(val);
                if (mustEscape) val = runtime.escape(val);
                buf.push(stringify(key) + ': ' + stringify(val));
            }
        } else if (options.format === 'html') buf.push(options.runtime('attr') + '("' + key + '", ' + val + ', ' + stringify(mustEscape) + ', ' + stringify(options.terse) + ')');
        else {
            if (mustEscape) val = options.runtime('escape') + '(' + val + ')';
            buf.push(stringify(key) + ': ' + val);
        }
    }
    attrs.forEach(function(attr) {
        var key = attr.name;
        var val = attr.val;
        var mustEscape = attr.mustEscape;
        if (key === 'class') {
            classes.push(val);
            classEscaping.push(mustEscape);
        } else {
            if (key === 'style') {
                if (isConstant(val)) val = stringify(runtime.style(toConstant(val)));
                else val = options.runtime('style') + '(' + val + ')';
            }
            addAttribute(key, val, mustEscape, buf1);
        }
    });
    var classesBuf = [];
    if (classes.length) {
        if (classes.every(isConstant)) addAttribute('class', stringify(runtime.classes(classes.map(toConstant), classEscaping)), false, classesBuf);
        else {
            classes = classes.map(function(cls, i) {
                if (isConstant(cls)) {
                    cls = stringify(classEscaping[i] ? runtime.escape(toConstant(cls)) : toConstant(cls));
                    classEscaping[i] = false;
                }
                return cls;
            });
            addAttribute('class', options.runtime('classes') + '([' + classes.join(',') + '], ' + stringify(classEscaping) + ')', false, classesBuf);
        }
    }
    buf1 = classesBuf.concat(buf1);
    if (options.format === 'html') return buf1.length ? buf1.join('+') : '""';
    else return '{' + buf1.join(',') + '}';
}

},{"assert":"bTbxk","constantinople":"hYgg9","pug-runtime":"dOa8V","js-stringify":"l22oi"}],"l22oi":[function(require,module,exports) {
'use strict';
module.exports = stringify;
function stringify(obj) {
    if (obj instanceof Date) return 'new Date(' + stringify(obj.toISOString()) + ')';
    if (obj === undefined) return 'undefined';
    return JSON.stringify(obj).replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029').replace(/</g, '\\u003C').replace(/>/g, '\\u003E').replace(/\//g, '\\u002F');
}

},{}],"e9AKQ":[function(require,module,exports) {
/**
 * This file automatically generated from `pre-publish.js`.
 * Do not manually edit.
 */ module.exports = {
    "area": true,
    "base": true,
    "br": true,
    "col": true,
    "embed": true,
    "hr": true,
    "img": true,
    "input": true,
    "link": true,
    "meta": true,
    "param": true,
    "source": true,
    "track": true,
    "wbr": true
};

},{}],"2guVQ":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {
    };
    if (mod != null) {
        for(var k in mod)if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const parser_1 = require("@babel/parser");
const babel_walk_1 = require("babel-walk");
const t = __importStar(require("@babel/types"));
const globals_1 = __importDefault(require("./globals"));
const parseOptions = {
    allowReturnOutsideFunction: true,
    allowImportExportEverywhere: true
};
/**
 * Mimic `with` as far as possible but at compile time
 *
 * @param obj The object part of a with expression
 * @param src The body of the with expression
 * @param exclude A list of variable names to explicitly exclude
 */ function addWith(obj, src, exclude = []) {
    // tslint:disable-next-line: no-parameter-reassignment
    obj = obj + '';
    // tslint:disable-next-line: no-parameter-reassignment
    src = src + '';
    let ast;
    try {
        ast = parser_1.parse(src, parseOptions);
    } catch (e) {
        throw Object.assign(new Error('Error parsing body of the with expression'), {
            component: 'src',
            babylonError: e
        });
    }
    let objAst;
    try {
        objAst = parser_1.parse(obj, parseOptions);
    } catch (e1) {
        throw Object.assign(new Error('Error parsing object part of the with expression'), {
            component: 'obj',
            babylonError: e1
        });
    }
    const excludeSet = new Set([
        'undefined',
        'this',
        ...exclude,
        ...globals_1.default(objAst).map((g)=>g.name
        ), 
    ]);
    const vars = new Set(globals_1.default(ast).map((global)=>global.name
    ).filter((v)=>!excludeSet.has(v)
    ));
    if (vars.size === 0) return src;
    let declareLocal = '';
    let local = 'locals_for_with';
    let result = 'result_of_with';
    if (t.isValidIdentifier(obj)) local = obj;
    else {
        while(vars.has(local) || excludeSet.has(local))local += '_';
        declareLocal = `var ${local} = (${obj});`;
    }
    while(vars.has(result) || excludeSet.has(result))result += '_';
    const args = [
        'this',
        ...Array.from(vars).map((v)=>`${JSON.stringify(v)} in ${local} ?
        ${local}.${v} :
        typeof ${v} !== 'undefined' ? ${v} : undefined`
        ), 
    ];
    const unwrapped = unwrapReturns(ast, src, result);
    return `;
    ${declareLocal}
    ${unwrapped.before}
    (function (${Array.from(vars).join(', ')}) {
      ${unwrapped.body}
    }.call(${args.join(', ')}));
    ${unwrapped.after};`;
}
exports.default = addWith;
const unwrapReturnsVisitors = babel_walk_1.recursive({
    Function (_node, _state, _c) {
    // returns in these functions are not applicable
    },
    ReturnStatement (node, state) {
        state.hasReturn = true;
        let value = '';
        if (node.argument) value = `value: (${state.source(node.argument)})`;
        state.replace(node, `return {${value}};`);
    }
});
/**
 * Take a self calling function, and unwrap it such that return inside the function
 * results in return outside the function
 *
 * @param src    Some JavaScript code representing a self-calling function
 * @param result A temporary variable to store the result in
 */ function unwrapReturns(ast, src, result) {
    const charArray = src.split('');
    const state = {
        hasReturn: false,
        source (node) {
            return src.slice(node.start, node.end);
        },
        replace (node, str) {
            charArray.fill('', node.start, node.end);
            charArray[node.start] = str;
        }
    };
    unwrapReturnsVisitors(ast, state);
    return {
        before: state.hasReturn ? `var ${result} = ` : '',
        body: charArray.join(''),
        after: state.hasReturn ? `;if (${result}) return ${result}.value` : ''
    };
}
module.exports = addWith;
module.exports.default = addWith;

},{"@babel/parser":"l6i8u","babel-walk":"kNkE5","@babel/types":"3rtBJ","./globals":"5TFZI"}],"kNkE5":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {
    };
    if (mod != null) {
        for(var k in mod)if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.recursive = exports.ancestor = exports.simple = void 0;
const t = __importStar(require("@babel/types"));
const explode_1 = __importDefault(require("./explode"));
const VISITOR_KEYS = t.VISITOR_KEYS;
if (!(VISITOR_KEYS && // tslint:disable-next-line: strict-type-predicates
typeof VISITOR_KEYS === 'object' && Object.keys(VISITOR_KEYS).every((key)=>Array.isArray(VISITOR_KEYS[key]) && // tslint:disable-next-line: strict-type-predicates
    VISITOR_KEYS[key].every((v)=>typeof v === 'string'
    )
))) throw new Error('@babel/types VISITOR_KEYS does not match the expected type.');
function simple(visitors) {
    const vis = explode_1.default(visitors);
    return (node1, state)=>{
        (function recurse(node) {
            if (!node) return;
            const visitor = vis[node.type];
            if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) for (const v of visitor.enter)v(node, state);
            for (const key of VISITOR_KEYS[node.type] || []){
                const subNode = node[key];
                if (Array.isArray(subNode)) for (const subSubNode of subNode)recurse(subSubNode);
                else recurse(subNode);
            }
            if (visitor === null || visitor === void 0 ? void 0 : visitor.exit) for (const v1 of visitor.exit)v1(node, state);
        })(node1);
    };
}
exports.simple = simple;
function ancestor(visitors) {
    const vis = explode_1.default(visitors);
    return (node2, state)=>{
        const ancestors = [];
        (function recurse(node) {
            if (!node) return;
            const visitor = vis[node.type];
            const isNew = node !== ancestors[ancestors.length - 1];
            if (isNew) ancestors.push(node);
            if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) for (const v of visitor.enter)v(node, state, ancestors);
            for (const key of VISITOR_KEYS[node.type] || []){
                const subNode = node[key];
                if (Array.isArray(subNode)) for (const subSubNode of subNode)recurse(subSubNode);
                else recurse(subNode);
            }
            if (visitor === null || visitor === void 0 ? void 0 : visitor.exit) for (const v2 of visitor.exit)v2(node, state, ancestors);
            if (isNew) ancestors.pop();
        })(node2);
    };
}
exports.ancestor = ancestor;
function recursive(visitors) {
    const vis = explode_1.default(visitors);
    return (node3, state)=>{
        (function recurse(node) {
            if (!node) return;
            const visitor = vis[node.type];
            if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) for (const v of visitor.enter)v(node, state, recurse);
            else for (const key of VISITOR_KEYS[node.type] || []){
                const subNode = node[key];
                if (Array.isArray(subNode)) for (const subSubNode of subNode)recurse(subSubNode);
                else recurse(subNode);
            }
        })(node3);
    };
}
exports.recursive = recursive;

},{"@babel/types":"3rtBJ","./explode":"8elQh"}],"8elQh":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {
    };
    if (mod != null) {
        for(var k in mod)if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const t1 = __importStar(require("@babel/types"));
if (!(Array.isArray(t1.TYPES) && t1.TYPES.every((t)=>typeof t === 'string'
))) throw new Error('@babel/types TYPES does not match the expected type.');
const FLIPPED_ALIAS_KEYS = t1.FLIPPED_ALIAS_KEYS;
const TYPES = new Set(t1.TYPES);
if (!(FLIPPED_ALIAS_KEYS && // tslint:disable-next-line: strict-type-predicates
typeof FLIPPED_ALIAS_KEYS === 'object' && Object.keys(FLIPPED_ALIAS_KEYS).every((key)=>Array.isArray(FLIPPED_ALIAS_KEYS[key]) && // tslint:disable-next-line: strict-type-predicates
    FLIPPED_ALIAS_KEYS[key].every((v)=>typeof v === 'string'
    )
))) throw new Error('@babel/types FLIPPED_ALIAS_KEYS does not match the expected type.');
/**
 * This serves thre functions:
 *
 * 1. Take any "aliases" and explode them to refecence the concrete types
 * 2. Normalize all handlers to have an `{enter, exit}` pair, rather than raw functions
 * 3. make the enter and exit handlers arrays, so that multiple handlers can be merged
 */ function explode(input) {
    const results = {
    };
    for(const key in input){
        const aliases = FLIPPED_ALIAS_KEYS[key];
        if (aliases) for (const concreteKey of aliases){
            if (concreteKey in results) {
                if (typeof input[key] === 'function') results[concreteKey].enter.push(input[key]);
                else {
                    if (input[key].enter) results[concreteKey].enter.push(input[key].enter);
                    if (input[key].exit) results[concreteKey].exit.push(input[key].exit);
                }
            } else if (typeof input[key] === 'function') results[concreteKey] = {
                enter: [
                    input[key]
                ],
                exit: []
            };
            else results[concreteKey] = {
                enter: input[key].enter ? [
                    input[key].enter
                ] : [],
                exit: input[key].exit ? [
                    input[key].exit
                ] : []
            };
        }
        else if (TYPES.has(key)) {
            if (key in results) {
                if (typeof input[key] === 'function') results[key].enter.push(input[key]);
                else {
                    if (input[key].enter) results[key].enter.push(input[key].enter);
                    if (input[key].exit) results[key].exit.push(input[key].exit);
                }
            } else if (typeof input[key] === 'function') results[key] = {
                enter: [
                    input[key]
                ],
                exit: []
            };
            else results[key] = {
                enter: input[key].enter ? [
                    input[key].enter
                ] : [],
                exit: input[key].exit ? [
                    input[key].exit
                ] : []
            };
        }
    }
    return results;
}
exports.default = explode;

},{"@babel/types":"3rtBJ"}],"5TFZI":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {
    };
    if (mod != null) {
        for(var k in mod)if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const assert_never_1 = __importDefault(require("assert-never"));
const babel_walk_1 = require("babel-walk");
const t = __importStar(require("@babel/types"));
const reference_1 = __importDefault(require("./reference"));
const isScope = (node)=>t.isFunctionParent(node) || t.isProgram(node)
;
const isBlockScope = (node)=>t.isBlockStatement(node) || isScope(node)
;
const declaresArguments = (node)=>t.isFunction(node) && !t.isArrowFunctionExpression(node)
;
const declaresThis = declaresArguments;
const LOCALS_SYMBOL = Symbol('locals');
const getLocals = (node)=>node[LOCALS_SYMBOL]
;
const declareLocals = (node)=>node[LOCALS_SYMBOL] = node[LOCALS_SYMBOL] || new Set()
;
const setLocal = (node, name)=>declareLocals(node).add(name)
;
// First pass
function declareFunction(node) {
    for (const param of node.params)declarePattern(param, node);
    const id = node.id;
    if (id) setLocal(node, id.name);
}
function declarePattern(node, parent) {
    switch(node.type){
        case 'Identifier':
            setLocal(parent, node.name);
            break;
        case 'ObjectPattern':
            for (const prop of node.properties)switch(prop.type){
                case 'RestElement':
                    declarePattern(prop.argument, parent);
                    break;
                case 'ObjectProperty':
                    declarePattern(prop.value, parent);
                    break;
                default:
                    assert_never_1.default(prop);
                    break;
            }
            break;
        case 'ArrayPattern':
            for (const element of node.elements)if (element) declarePattern(element, parent);
            break;
        case 'RestElement':
            declarePattern(node.argument, parent);
            break;
        case 'AssignmentPattern':
            declarePattern(node.left, parent);
            break;
        // istanbul ignore next
        default:
            throw new Error('Unrecognized pattern type: ' + node.type);
    }
}
function declareModuleSpecifier(node, _state, parents) {
    for(let i = parents.length - 2; i >= 0; i--)if (isScope(parents[i])) {
        setLocal(parents[i], node.local.name);
        return;
    }
}
const firstPass = babel_walk_1.ancestor({
    VariableDeclaration (node, _state, parents) {
        for(let i = parents.length - 2; i >= 0; i--)if (node.kind === 'var' ? t.isFunctionParent(parents[i]) : isBlockScope(parents[i])) {
            for (const declaration of node.declarations)declarePattern(declaration.id, parents[i]);
            return;
        }
    },
    FunctionDeclaration (node, _state, parents) {
        if (node.id) {
            for(let i = parents.length - 2; i >= 0; i--)if (isScope(parents[i])) {
                setLocal(parents[i], node.id.name);
                return;
            }
        }
    },
    Function: declareFunction,
    ClassDeclaration (node, _state, parents) {
        for(let i = parents.length - 2; i >= 0; i--)if (isScope(parents[i])) {
            setLocal(parents[i], node.id.name);
            return;
        }
    },
    TryStatement (node) {
        if (node.handler === null) return;
        if (node.handler.param === null) return;
        declarePattern(node.handler.param, node.handler);
    },
    ImportDefaultSpecifier: declareModuleSpecifier,
    ImportSpecifier: declareModuleSpecifier,
    ImportNamespaceSpecifier: declareModuleSpecifier
});
// Second pass
const secondPass = babel_walk_1.ancestor({
    Identifier (node, state, parents) {
        var _a;
        const name = node.name;
        if (name === 'undefined') return;
        const lastParent = parents[parents.length - 2];
        if (lastParent) {
            if (!reference_1.default(node, lastParent)) return;
            for (const parent of parents){
                if (name === 'arguments' && declaresArguments(parent)) return;
                if ((_a = getLocals(parent)) === null || _a === void 0 ? void 0 : _a.has(name)) return;
            }
        }
        state.globals.push(node);
    },
    ThisExpression (node, state, parents) {
        for (const parent of parents){
            if (declaresThis(parent)) return;
        }
        state.globals.push(node);
    }
});
function findGlobals(ast) {
    const globals = [];
    // istanbul ignore if
    if (!t.isNode(ast)) throw new TypeError('Source must be a Babylon AST');
    firstPass(ast, undefined);
    secondPass(ast, {
        globals
    });
    const groupedGlobals = new Map();
    for (const node of globals){
        const name = node.type === 'ThisExpression' ? 'this' : node.name;
        const existing = groupedGlobals.get(name);
        if (existing) existing.push(node);
        else groupedGlobals.set(name, [
            node
        ]);
    }
    return [
        ...groupedGlobals
    ].map(([name, nodes])=>({
            name,
            nodes
        })
    ).sort((a, b)=>a.name < b.name ? -1 : 1
    );
}
exports.default = findGlobals;

},{"assert-never":"bYOwV","babel-walk":"kNkE5","@babel/types":"3rtBJ","./reference":"7qhnC"}],"bYOwV":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Helper function for exhaustive checks of discriminated unions.
 * https://basarat.gitbooks.io/typescript/docs/types/discriminated-unions.html
 *
 * @example
 *
 *    type A = {type: 'a'};
 *    type B = {type: 'b'};
 *    type Union = A | B;
 *
 *    function doSomething(arg: Union) {
 *      if (arg.type === 'a') {
 *        return something;
 *      }
 *
 *      if (arg.type === 'b') {
 *        return somethingElse;
 *      }
 *
 *      // TS will error if there are other types in the union
 *      // Will throw an Error when called at runtime.
 *      // Use `assertNever(arg, true)` instead to fail silently.
 *      return assertNever(arg);
 *    }
 */ function assertNever(value, noThrow) {
    if (noThrow) return value;
    throw new Error("Unhandled discriminated union member: " + JSON.stringify(value));
}
exports.assertNever = assertNever;
exports.default = assertNever;

},{}],"7qhnC":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {
    };
    if (mod != null) {
        for(var k in mod)if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const t = __importStar(require("@babel/types"));
function isReferenced(node, parent) {
    switch(parent.type){
        // yes: { [NODE]: '' }
        // yes: { NODE }
        // no: { NODE: '' }
        case 'ObjectProperty':
            return parent.value === node || parent.computed;
        // no: break NODE;
        // no: continue NODE;
        case 'BreakStatement':
        case 'ContinueStatement':
            return false;
        // yes: left = NODE;
        // yes: NODE = right;
        case 'AssignmentExpression':
            return true;
    }
    return t.isReferenced(node, parent);
}
exports.default = isReferenced;

},{"@babel/types":"3rtBJ"}],"lOpgd":[function(require,module,exports) {
var runtime = require('./');
module.exports = wrap;
function wrap(template, templateName) {
    templateName = templateName || 'template';
    return Function('pug', template + '\n' + 'return ' + templateName + ';')(runtime);
}

},{"./":"dOa8V"}],"48QSg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = `.chats
    article.chats__messages
        .chats__header 
            .chats__top-header 
                if dsplayUser
                    .chats__user 
                        img
                        p #{user}
                button.chats__control.chats__control--right Профиль
            .chats__search-wrap 
                input.chats__search(type='text')
        .chats__dialogs-wrap.dialog 
            each val, index in dialogs 
                .dialog__block(tabindex="0")
                    .dialog__avatar
                        img 
                    .dialog__text
                        p #{val.from} 
                        if val.content
                            span #{val.content}
                        else
                            span <b>Вы:</b> #{val.answer}
                    .dialog__etc
                        span #{val.time}
                        if val.unreadCount   
                            div #{val.unreadCount}
    .chats__current-chat.current-chat
        if activeChat
            .current-chat__header
                .current-chat__user 
                    img
                    p #{activeChatCompanion}
                .current-chat__menu-wrap.menu 
                    .menu__menu-btn 
                    .menu__list-wrap
                        ul.menu__list 
                            li
                                span.menu__icon.menu__icon--add
                                p Добавить пользователя
                            li
                                span.menu__icon.menu__icon--delete
                                p Удалить пользователя
                            li
                                span.menu__icon.menu__icon--exit
                                p Выйти
            .current-chat__body 
                .current-chat__date #{chatDate}
                each message, index in activeChatContent
                    div(class=message.type).current-chat__message
                        p #{message.text}
                        span #{message.time}
            form.current-chat__footer-form
                .menu 
                    .menu__menu-btn 
                    .menu__list-wrap.menu__list-wrap--position
                        ul.menu__list 
                            li
                                span.menu__icon
                                p Фото или видео
                            li
                                span.menu__icon
                                p Файл
                            li
                                span.menu__icon
                                p Локация
                input(type=chatInput.type name=chatInput.name placeholder="Сообщение")
                button(type="sunbmit")

        else 
            .current-chat__empty-chat
                p #{emptyChatText}`;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7fBG1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pug = require("pug");
var _pugDefault = parcelHelpers.interopDefault(_pug);
var _errorTmpl = require("./error.tmpl");
var _errorTmplDefault = parcelHelpers.interopDefault(_errorTmpl);
const error = _pugDefault.default.compile(_errorTmplDefault.default);
const data = {
    errorCode: 404,
    errorText: "Не туда попали",
    linkHref: "/#chat",
    linkText: "Назад к чатам"
};
exports.default = error(data);

},{"pug":"cV7MS","./error.tmpl":"ilMTI","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ilMTI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = `.fail
    p.fail__code #{errorCode}
    span.fail__text #{errorText}
    a.fail__link(href=linkHref) #{linkText}`;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4yaFC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pug = require("pug");
var _pugDefault = parcelHelpers.interopDefault(_pug);
var _loginTmpl = require("./login.tmpl");
var _loginTmplDefault = parcelHelpers.interopDefault(_loginTmpl);
const login = _pugDefault.default.compile(_loginTmplDefault.default);
const data = {
    title: "Вход",
    input: [
        {
            label: "Логин",
            type: "text",
            name: "login",
            validationError: "Неверный логин",
            value: 'ivan'
        },
        {
            label: "Пароль",
            type: "password",
            name: "password",
            validationError: "Неверный пароль",
            value: 'ivanon'
        }, 
    ],
    buttonText: "Войти",
    buttonType: "submit",
    linkHref: "/#registration",
    linkText: "Нет аккаунта?"
};
exports.default = login(data);

},{"pug":"cV7MS","./login.tmpl":"fUUBC","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fUUBC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = `div.mobile-form
    div.mobile-form__frame 
        h1.mobile-form__header #{title}
        div.mobile-form__fields
        each val, index in input
            div.mobile-form__input-wrap
                p.mobile-form__input-name.mobile-form__input-name--active #{val.label}
                input.mobile-form__input( type=val.type name=val.name value=val.value)
                span.mobile-form__err #{val.validationError}
        div.mobile-form__btn-wrap
            button.mobile-form__btn(type=buttonType) #{buttonText}
            a.mobile-form__link(href=linkHref) #{linkText}
            `;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kGPJH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pug = require("pug");
var _pugDefault = parcelHelpers.interopDefault(_pug);
var _modalAvatarTmpl = require("./modalAvatar.tmpl");
var _modalAvatarTmplDefault = parcelHelpers.interopDefault(_modalAvatarTmpl);
const modalAvatar = _pugDefault.default.compile(_modalAvatarTmplDefault.default);
const data = {
    title: "Файл загружен",
    buttonText: "Поменять",
    buttontype: "submit",
    error: ""
};
exports.default = modalAvatar(data);

},{"pug":"cV7MS","./modalAvatar.tmpl":"9ZKiM","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9ZKiM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = `.overlay
.modal
    h1.modal__header #{title}
    form.modal__form
        .modal__actions
            if file
                input.modal__input(type="file" name="avatar" value="Выбрать файл на компьюторе")
                label.modal__label(for="name") Выбрать файл на компьюторе
            else
                span.modal__file-name ivan.jpeg
        button.modal__button(type=buttonType) #{buttonText}
        if error
            span.modal__error Нужно выбрать файл`;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aQyB6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pug = require("pug");
var _pugDefault = parcelHelpers.interopDefault(_pug);
var _profileTmpl = require("./profile.tmpl");
var _profileTmplDefault = parcelHelpers.interopDefault(_profileTmpl);
const profile = _pugDefault.default.compile(_profileTmplDefault.default);
const data = {
    user: "Иван",
    inputCommon: [
        {
            label: "Почта",
            type: "email",
            name: "email",
            validationError: "",
            value: "pochta@yandex.ru"
        },
        {
            label: "Логин",
            type: "text",
            name: "login",
            validationError: "",
            value: "ivanivanov"
        },
        {
            label: "Имя",
            type: "text",
            name: "first_name",
            validationError: "",
            value: "Иван"
        },
        {
            label: "Фамилия",
            type: "text",
            name: "second_name",
            validationError: "",
            value: "Иванов"
        },
        {
            label: "Имя в чате",
            type: "text",
            name: "display_name",
            validationError: "",
            value: "Иван"
        },
        {
            label: "Телефон",
            type: "tel",
            name: "phone",
            validationError: "",
            value: "+7 (909) 967 30 30"
        },
        {
            label: "Пароль",
            type: "password",
            name: "password",
            validationError: "",
            value: "12345678"
        },
        {
            label: "Пароль (еще раз)",
            type: "password",
            name: "password2",
            validationError: "Пароли не совпадают",
            value: "12345678"
        }, 
    ],
    inputPassword: [
        {
            label: "Старый пароль",
            type: "password",
            name: "oldPassword",
            validationError: "",
            value: "ivaniv"
        },
        {
            label: " Новый пароль",
            type: "password",
            name: "newPassword",
            validationError: "",
            value: "ivanivoo"
        },
        {
            label: "Повторите пароль",
            type: "password",
            name: "newPassword2",
            validationError: "",
            value: "ivanivoo"
        }, 
    ],
    data: "full",
    state: "basic",
    buttonTextChangeData: "Изменить данные",
    buttonTypeChangeData: "button",
    buttonTextChangePassword: "Изменить пароль",
    buttonTypeChangePassword: "button",
    buttonTextSave: "Сохранить",
    buttonTypeSave: "submit",
    linkHref: "/#chat",
    linkText: "Выйти"
};
exports.default = profile(data);

},{"pug":"cV7MS","./profile.tmpl":"1g10h","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1g10h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = `.profile
    .profile__back 
        button.profile__back-btn(type="button")
    .profile__wrap
        .profile__main
            .profile__header 
                .profile__avatar-block 
                    img.profile__avatar
                p.profile__name #{user}
            if data==='full' 
                .profile__data-block
                    each val, index in inputCommon
                        .profile__data-row 
                            span.profile__data-name #{val.label}
                            input.profile__data(type=val.type="" name=val.name="" value=val.value) 
            else
                .profile__data-block
                    each val, index in inputPassword
                        .profile__data-row 
                            span.profile__data-name #{val.label}
                            input.profile__data(type=val.type="" name=val.name="" value=val.value) 

            if state==='basic'
                .profile__actions-block
                    .profile__data-row 
                        button.profile__action(type=buttonTypeChangeData) #{buttonTextChangeData}
                    .profile__data-row 
                        button.profile__action(type=buttonTypeChangePassword) #{buttonTextChangePassword}
                    .profile__data-row 
                        a.profile__exit(hreg=linkHref) #{linkText}
            else
                .profile__actions-block 
                    button.profile__action-btn(type=buttonTypeSave) #{buttonTextSave}`;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gbR8G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pug = require("pug");
var _pugDefault = parcelHelpers.interopDefault(_pug);
var _signinTmpl = require("./signin.tmpl");
var _signinTmplDefault = parcelHelpers.interopDefault(_signinTmpl);
const signin = _pugDefault.default.compile(_signinTmplDefault.default);
const data = {
    title: "Регистрация",
    input: [
        {
            label: "Почта",
            type: "email",
            name: "email",
            validationError: "",
            value: 'pochta@yandex.ru'
        },
        {
            label: "Логин",
            type: "text",
            name: "login",
            validationError: "",
            value: 'ivanivanov'
        },
        {
            label: "Имя",
            type: "text",
            name: "first_name",
            validationError: "",
            value: 'Иван'
        },
        {
            label: "Фамилия",
            type: "text",
            name: "second_name",
            validationError: "",
            value: 'Иванов'
        },
        {
            label: "Телефон",
            type: "tel",
            name: "phone",
            validationError: "",
            value: '+7 (909) 967 30 30'
        },
        {
            label: "Пароль",
            type: "password",
            name: "password",
            validationError: "",
            value: '12345678'
        },
        {
            label: "Пароль (еще раз)",
            type: "password",
            name: "password2",
            validationError: "Пароли не совпадают",
            value: '12345678'
        }, 
    ],
    buttonText: "Зарегистрироваться",
    buttonType: "submit",
    linkHref: "/#login",
    linkText: "Войти"
};
exports.default = signin(data);

},{"pug":"cV7MS","./signin.tmpl":"8k6ac","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8k6ac":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = `div.mobile-form
    div.mobile-form__frame 
        h1.mobile-form__header #{title}
        div.mobile-form__fields
            each val, index in input
                div.mobile-form__input-wrap
                    p.mobile-form__input-name.mobile-form__input-name--active #{val.label}
                    input.mobile-form__input( type=val.type name=val.name value=val.value)
                    span.mobile-form__err #{val.validationError}
        div.mobile-form__btn-wrap
            button.mobile-form__btn(type=buttonType) #{buttonText}
            a.mobile-form__link(href=linkHref) #{linkText}`;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}]},["jVewE","egpFc"], "egpFc", "parcelRequireab20")

//# sourceMappingURL=index.d60b904b.js.map
